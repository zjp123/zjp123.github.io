# ã€Šå‰ç«¯è®¾è®¡æ¨¡å¼å®æˆ˜æ‰‹å†Œã€‹

## ç¬¬å››ç« ï¼šå•ä¾‹æ¨¡å¼ï¼ˆSingleton Patternï¼‰

---

### ğŸ¯ ä¸€å¥è¯å¤§ç™½è¯

> **å•ä¾‹æ¨¡å¼å°±åƒä¸€ä¸ªå›½å®¶çš„æ€»ç»Ÿï¼šä¸ç®¡ä½ åœ¨å“ªä¸ªåŸå¸‚ï¼Œä¸ç®¡ä½ é—®å¤šå°‘æ¬¡ï¼Œ"æ€»ç»Ÿæ˜¯è°ï¼Ÿ"ç­”æ¡ˆæ°¸è¿œæ˜¯åŒä¸€ä¸ªäººã€‚å…¨å›½åªæœ‰ä¸€ä¸ªæ€»ç»Ÿï¼Œä¸ä¼šå› ä¸ºä½ å¤šé—®å‡ æ¬¡å°±å¤šå‡ºæ¥å‡ ä¸ªã€‚**

**æ ¸å¿ƒç†å¿µï¼šç¡®ä¿ä¸€ä¸ªç±»åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œå¹¶æä¾›ä¸€ä¸ªå…¨å±€è®¿é—®ç‚¹ã€‚**

---

### ğŸ¤” ä»€ä¹ˆæ—¶å€™éœ€è¦"å…¨å±€å”¯ä¸€"ï¼Ÿ

åœ¨å‰ç«¯å¼€å‘ä¸­ï¼Œæœ‰äº›ä¸œè¥¿å¤©ç”Ÿå°±åº”è¯¥æ˜¯"ç‹¬ä¸€æ— äºŒ"çš„ï¼š

| åœºæ™¯ | ä¸ºä»€ä¹ˆéœ€è¦å•ä¾‹ |
|------|--------------|
| **Redux Store** | æ•´ä¸ªåº”ç”¨åªèƒ½æœ‰ä¸€ä¸ªçŠ¶æ€æ ‘ |
| **WebSocket è¿æ¥** | åŒä¸€ä¸ªåœ°å€åªéœ€è¦ä¸€ä¸ªè¿æ¥ |
| **å…¨å±€å¼¹çª—ç®¡ç†å™¨** | é¿å…é‡å¤å¼¹å‡ºç›¸åŒçš„å¼¹çª— |
| **æ—¥å¿—è®°å½•å™¨** | ç»Ÿä¸€ç®¡ç†æ—¥å¿—è¾“å‡º |
| **ç¼“å­˜ç®¡ç†å™¨** | é¿å…å¤šä¸ªç¼“å­˜å®ä¾‹å¯¼è‡´æ•°æ®ä¸ä¸€è‡´ |
| **é…ç½®ç®¡ç†å™¨** | å…¨å±€é…ç½®åº”è¯¥ç»Ÿä¸€ç®¡ç† |
| **Loading çŠ¶æ€ç®¡ç†** | å…¨å±€ loading ä¸åº”è¯¥æœ‰å¤šä¸ªå®ä¾‹ |

---

### ğŸ˜« å‰ç«¯ç—›ç‚¹ï¼šæ²¡æœ‰å•ä¾‹æ—¶çš„å™©æ¢¦

#### åœºæ™¯ä¸€ï¼šWebSocket è¿æ¥æ³„æ¼

```tsx
// âŒ å™©æ¢¦ä»£ç ï¼šæ¯æ¬¡è¿›å…¥ç»„ä»¶éƒ½åˆ›å»ºæ–°è¿æ¥

// ChatRoom.tsx
const ChatRoom: React.FC = () => {
  useEffect(() => {
    // æ¯æ¬¡ç»„ä»¶æŒ‚è½½éƒ½åˆ›å»ºä¸€ä¸ªæ–°çš„ WebSocket è¿æ¥
    const ws = new WebSocket('wss://chat.example.com');
    
    ws.onmessage = (event) => {
      console.log('æ”¶åˆ°æ¶ˆæ¯:', event.data);
    };
    
    return () => {
      ws.close();  // ç»„ä»¶å¸è½½æ—¶å…³é—­
    };
  }, []);
  
  return <div>èŠå¤©å®¤</div>;
};

// é—®é¢˜ï¼š
// 1. ç”¨æˆ·åœ¨é¡µé¢é—´åˆ‡æ¢ï¼Œæ¯æ¬¡éƒ½åˆ›å»ºæ–°è¿æ¥ï¼ŒæœåŠ¡å™¨å‹åŠ›å±±å¤§
// 2. å¤šä¸ªç»„ä»¶éƒ½éœ€è¦ WebSocketï¼Œæ¯ä¸ªéƒ½åˆ›å»ºä¸€ä¸ªï¼Ÿ
// 3. è¿æ¥çŠ¶æ€éš¾ä»¥ç»Ÿä¸€ç®¡ç†
```

#### åœºæ™¯äºŒï¼šé‡å¤å¼¹çª—

```tsx
// âŒ å™©æ¢¦ä»£ç ï¼šåŒä¸€ä¸ªæç¤ºå¼¹å‡º N æ¬¡

// æŸä¸ªè¯·æ±‚å¤±è´¥æ—¶
const handleError = (error: Error) => {
  message.error('ç½‘ç»œé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•');  // å¼¹å‡ºæç¤º1
};

// å¦ä¸€ä¸ªåœ°æ–¹ä¹Ÿè°ƒç”¨äº†å¤±è´¥å¤„ç†
const handleApiError = (error: Error) => {
  message.error('ç½‘ç»œé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•');  // å¼¹å‡ºæç¤º2ï¼ˆé‡å¤ï¼ï¼‰
};

// æ‰¹é‡è¯·æ±‚æ—¶ï¼Œå¯èƒ½åŒæ—¶å¤±è´¥
Promise.all([api1(), api2(), api3()]).catch(() => {
  message.error('ç½‘ç»œé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•');  // å¯èƒ½å¼¹å‡º N ä¸ªç›¸åŒçš„æç¤º
});

// ç”¨æˆ·çœ‹åˆ°ï¼šå±å¹•ä¸Šå äº†ä¸€å †ä¸€æ¨¡ä¸€æ ·çš„é”™è¯¯æç¤º
```

#### åœºæ™¯ä¸‰ï¼šç¼“å­˜ä¸ä¸€è‡´

```tsx
// âŒ å™©æ¢¦ä»£ç ï¼šå¤šä¸ªç¼“å­˜å®ä¾‹

// userService.ts
class CacheManager {
  private cache = new Map();
  
  get(key: string) { return this.cache.get(key); }
  set(key: string, value: any) { this.cache.set(key, value); }
}

// æ¯æ¬¡ import éƒ½æ˜¯æ–°å®ä¾‹
const cache1 = new CacheManager();
const cache2 = new CacheManager();

cache1.set('user', { name: 'å¼ ä¸‰' });
console.log(cache2.get('user'));  // undefinedï¼å› ä¸ºæ˜¯ä¸åŒå®ä¾‹

// é—®é¢˜ï¼š
// 1. ç»„ä»¶ A ç¼“å­˜äº†æ•°æ®ï¼Œç»„ä»¶ B è¯»ä¸åˆ°
// 2. ç¼“å­˜æ•°æ®ä¸ä¸€è‡´ï¼Œå‡ºç°è¯¡å¼‚ bug
```

**è¿™äº›ä»£ç æœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿ**

| é—®é¢˜ | æè¿° |
|------|------|
| ğŸ”´ **èµ„æºæµªè´¹** | åˆ›å»ºå¤šä¸ªç›¸åŒçš„è¿æ¥/å®ä¾‹ï¼Œæµªè´¹å†…å­˜å’Œç½‘ç»œèµ„æº |
| ğŸ”´ **çŠ¶æ€ä¸ä¸€è‡´** | å¤šä¸ªå®ä¾‹å„è‡ªç»´æŠ¤çŠ¶æ€ï¼Œæ•°æ®åŒæ­¥å›°éš¾ |
| ğŸ”´ **éš¾ä»¥ç®¡ç†** | æ²¡æœ‰ç»Ÿä¸€çš„è®¿é—®ç‚¹ï¼Œåˆ°å¤„éƒ½åœ¨åˆ›å»ºå®ä¾‹ |
| ğŸ”´ **ç”¨æˆ·ä½“éªŒå·®** | é‡å¤å¼¹çª—ã€é‡å¤è¯·æ±‚ç­‰é—®é¢˜ |

---

### ğŸ’¡ æ¨¡å¼æ ¸å¿ƒæ¦‚å¿µ

å•ä¾‹æ¨¡å¼çš„æ ¸å¿ƒæ€æƒ³æ˜¯ï¼š

> **ç¡®ä¿ä¸€ä¸ªç±»åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œå¹¶æä¾›ä¸€ä¸ªå…¨å±€è®¿é—®ç‚¹æ¥è·å–è¿™ä¸ªå®ä¾‹ã€‚**

ç”¨å¤§ç™½è¯è¯´å°±æ˜¯ï¼š
- ç¬¬ä¸€æ¬¡è°ƒç”¨æ—¶åˆ›å»ºå®ä¾‹
- ä¹‹åçš„æ¯æ¬¡è°ƒç”¨éƒ½è¿”å›åŒä¸€ä¸ªå®ä¾‹
- æ•´ä¸ªåº”ç”¨ç”Ÿå‘½å‘¨æœŸå†…åªå­˜åœ¨ä¸€ä¸ªå®ä¾‹

**å®ç°è¦ç‚¹ï¼š**

```tsx
class Singleton {
  // 1. ç§æœ‰é™æ€å˜é‡ï¼Œå­˜å‚¨å”¯ä¸€å®ä¾‹
  private static instance: Singleton | null = null;
  
  // 2. ç§æœ‰æ„é€ å‡½æ•°ï¼Œé˜²æ­¢å¤–éƒ¨ new
  private constructor() {}
  
  // 3. å…¬å…±é™æ€æ–¹æ³•ï¼Œè·å–å”¯ä¸€å®ä¾‹
  public static getInstance(): Singleton {
    if (!Singleton.instance) {
      Singleton.instance = new Singleton();
    }
    return Singleton.instance;
  }
}

// ä½¿ç”¨
const s1 = Singleton.getInstance();
const s2 = Singleton.getInstance();
console.log(s1 === s2);  // trueï¼Œæ˜¯åŒä¸€ä¸ªå®ä¾‹
```

**ç±»æ¯”ç†è§£ï¼š**

```
æ™®é€šæ¨¡å¼ï¼šæ¯æ¬¡æ•²é—¨éƒ½æ¥ä¸€ä¸ªæ–°ä¿å®‰ â†’ ä¿å®‰å¤ªå¤šï¼Œäº’ç›¸ä¸è®¤è¯†
å•ä¾‹æ¨¡å¼ï¼šä¸ç®¡æ•²å¤šå°‘æ¬¡é—¨ï¼Œæ°¸è¿œæ˜¯åŒä¸€ä¸ªä¿å®‰å¼€é—¨ â†’ è¿™ä¸ªä¿å®‰è®°å¾—æ‰€æœ‰æ¥è®¿è®°å½•
```

---

### ğŸ”§ å‰ç«¯å®æˆ˜æ¡ˆä¾‹ä¸€ï¼šWebSocket è¿æ¥ç®¡ç†å™¨

#### åœºæ™¯æè¿°

å®ç°ä¸€ä¸ªå…¨å±€ WebSocket ç®¡ç†å™¨ï¼Œç¡®ä¿åŒä¸€ä¸ªåœ°å€åªå»ºç«‹ä¸€ä¸ªè¿æ¥ï¼Œæ”¯æŒè‡ªåŠ¨é‡è¿ã€‚

```tsx
// services/WebSocketManager.ts

type MessageHandler = (data: any) => void;
type ConnectionHandler = () => void;

interface WebSocketConfig {
  url: string;
  reconnectInterval?: number;  // é‡è¿é—´éš”ï¼ˆæ¯«ç§’ï¼‰
  maxReconnectAttempts?: number;  // æœ€å¤§é‡è¿æ¬¡æ•°
  heartbeatInterval?: number;  // å¿ƒè·³é—´éš”ï¼ˆæ¯«ç§’ï¼‰
}

/**
 * WebSocket è¿æ¥ç®¡ç†å™¨ï¼ˆå•ä¾‹ï¼‰
 * 
 * ç‰¹ç‚¹ï¼š
 * - å…¨å±€å”¯ä¸€å®ä¾‹ï¼Œé¿å…é‡å¤è¿æ¥
 * - è‡ªåŠ¨é‡è¿æœºåˆ¶
 * - å¿ƒè·³ä¿æ´»
 * - æ”¯æŒå¤šä¸ªè®¢é˜…è€…
 * 
 * @example
 * const ws = WebSocketManager.getInstance();
 * ws.connect({ url: 'wss://chat.example.com' });
 * ws.subscribe('chat', (data) => console.log(data));
 * ws.send({ type: 'message', content: 'Hello!' });
 */
class WebSocketManager {
  // ==================== å•ä¾‹å®ç° ====================
  
  private static instance: WebSocketManager | null = null;
  
  public static getInstance(): WebSocketManager {
    if (!WebSocketManager.instance) {
      WebSocketManager.instance = new WebSocketManager();
    }
    return WebSocketManager.instance;
  }
  
  // ç§æœ‰æ„é€ å‡½æ•°
  private constructor() {
    // é¡µé¢å…³é—­æ—¶æ–­å¼€è¿æ¥
    if (typeof window !== 'undefined') {
      window.addEventListener('beforeunload', () => {
        this.disconnect();
      });
    }
  }
  
  // ==================== å®ä¾‹å±æ€§ ====================
  
  private ws: WebSocket | null = null;
  private config: WebSocketConfig | null = null;
  private reconnectAttempts = 0;
  private reconnectTimer: NodeJS.Timeout | null = null;
  private heartbeatTimer: NodeJS.Timeout | null = null;
  
  // æ¶ˆæ¯è®¢é˜…è€…ï¼škey ä¸ºæ¶ˆæ¯ç±»å‹ï¼Œvalue ä¸ºå¤„ç†å‡½æ•°æ•°ç»„
  private subscribers: Map<string, MessageHandler[]> = new Map();
  
  // è¿æ¥çŠ¶æ€å›è°ƒ
  private onConnectCallbacks: ConnectionHandler[] = [];
  private onDisconnectCallbacks: ConnectionHandler[] = [];
  
  // ==================== å…¬å…±æ–¹æ³• ====================
  
  /**
   * å»ºç«‹ WebSocket è¿æ¥
   */
  connect(config: WebSocketConfig): void {
    // å¦‚æœå·²è¿æ¥åˆ°ç›¸åŒåœ°å€ï¼Œç›´æ¥è¿”å›
    if (this.ws?.readyState === WebSocket.OPEN && this.config?.url === config.url) {
      console.log('[WS] å·²è¿æ¥ï¼Œæ— éœ€é‡å¤è¿æ¥');
      return;
    }
    
    // å¦‚æœè¿æ¥åˆ°ä¸åŒåœ°å€ï¼Œå…ˆæ–­å¼€
    if (this.ws) {
      this.disconnect();
    }
    
    this.config = {
      reconnectInterval: 3000,
      maxReconnectAttempts: 5,
      heartbeatInterval: 30000,
      ...config,
    };
    
    this.createConnection();
  }
  
  /**
   * æ–­å¼€è¿æ¥
   */
  disconnect(): void {
    this.clearTimers();
    
    if (this.ws) {
      this.ws.onclose = null;  // é˜²æ­¢è§¦å‘é‡è¿
      this.ws.close();
      this.ws = null;
    }
    
    this.reconnectAttempts = 0;
    console.log('[WS] è¿æ¥å·²æ–­å¼€');
  }
  
  /**
   * å‘é€æ¶ˆæ¯
   */
  send(data: any): boolean {
    if (this.ws?.readyState !== WebSocket.OPEN) {
      console.warn('[WS] è¿æ¥æœªå°±ç»ªï¼Œæ— æ³•å‘é€æ¶ˆæ¯');
      return false;
    }
    
    const message = typeof data === 'string' ? data : JSON.stringify(data);
    this.ws.send(message);
    return true;
  }
  
  /**
   * è®¢é˜…æ¶ˆæ¯
   * @param type æ¶ˆæ¯ç±»å‹ï¼ˆå¦‚ 'chat', 'notification'ï¼‰
   * @param handler å¤„ç†å‡½æ•°
   * @returns å–æ¶ˆè®¢é˜…çš„å‡½æ•°
   */
  subscribe(type: string, handler: MessageHandler): () => void {
    if (!this.subscribers.has(type)) {
      this.subscribers.set(type, []);
    }
    this.subscribers.get(type)!.push(handler);
    
    // è¿”å›å–æ¶ˆè®¢é˜…å‡½æ•°
    return () => {
      const handlers = this.subscribers.get(type);
      if (handlers) {
        const index = handlers.indexOf(handler);
        if (index > -1) {
          handlers.splice(index, 1);
        }
      }
    };
  }
  
  /**
   * ç›‘å¬è¿æ¥æˆåŠŸ
   */
  onConnect(callback: ConnectionHandler): () => void {
    this.onConnectCallbacks.push(callback);
    return () => {
      const index = this.onConnectCallbacks.indexOf(callback);
      if (index > -1) {
        this.onConnectCallbacks.splice(index, 1);
      }
    };
  }
  
  /**
   * ç›‘å¬æ–­å¼€è¿æ¥
   */
  onDisconnect(callback: ConnectionHandler): () => void {
    this.onDisconnectCallbacks.push(callback);
    return () => {
      const index = this.onDisconnectCallbacks.indexOf(callback);
      if (index > -1) {
        this.onDisconnectCallbacks.splice(index, 1);
      }
    };
  }
  
  /**
   * è·å–è¿æ¥çŠ¶æ€
   */
  get isConnected(): boolean {
    return this.ws?.readyState === WebSocket.OPEN;
  }
  
  /**
   * è·å–è¿æ¥çŠ¶æ€æ–‡æœ¬
   */
  get status(): 'connecting' | 'connected' | 'disconnected' | 'reconnecting' {
    if (!this.ws) return 'disconnected';
    if (this.ws.readyState === WebSocket.CONNECTING) return 'connecting';
    if (this.ws.readyState === WebSocket.OPEN) return 'connected';
    if (this.reconnectAttempts > 0) return 'reconnecting';
    return 'disconnected';
  }
  
  // ==================== ç§æœ‰æ–¹æ³• ====================
  
  private createConnection(): void {
    if (!this.config) return;
    
    console.log(`[WS] æ­£åœ¨è¿æ¥: ${this.config.url}`);
    this.ws = new WebSocket(this.config.url);
    
    this.ws.onopen = () => {
      console.log('[WS] è¿æ¥æˆåŠŸ');
      this.reconnectAttempts = 0;
      this.startHeartbeat();
      this.onConnectCallbacks.forEach(cb => cb());
    };
    
    this.ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        this.handleMessage(data);
      } catch {
        // å¦‚æœä¸æ˜¯ JSONï¼Œä½œä¸ºæ™®é€šæ¶ˆæ¯å¤„ç†
        this.handleMessage({ type: 'raw', data: event.data });
      }
    };
    
    this.ws.onerror = (error) => {
      console.error('[WS] è¿æ¥é”™è¯¯:', error);
    };
    
    this.ws.onclose = () => {
      console.log('[WS] è¿æ¥å…³é—­');
      this.stopHeartbeat();
      this.onDisconnectCallbacks.forEach(cb => cb());
      this.attemptReconnect();
    };
  }
  
  private handleMessage(data: any): void {
    const type = data.type || 'default';
    const handlers = this.subscribers.get(type) || [];
    
    // é€šçŸ¥æ‰€æœ‰è®¢é˜…è¯¥ç±»å‹çš„å¤„ç†å‡½æ•°
    handlers.forEach(handler => {
      try {
        handler(data);
      } catch (error) {
        console.error('[WS] æ¶ˆæ¯å¤„ç†å‡ºé”™:', error);
      }
    });
    
    // åŒæ—¶é€šçŸ¥è®¢é˜… '*' çš„å¤„ç†å‡½æ•°ï¼ˆå…¨å±€ç›‘å¬ï¼‰
    const globalHandlers = this.subscribers.get('*') || [];
    globalHandlers.forEach(handler => {
      try {
        handler(data);
      } catch (error) {
        console.error('[WS] å…¨å±€æ¶ˆæ¯å¤„ç†å‡ºé”™:', error);
      }
    });
  }
  
  private attemptReconnect(): void {
    if (!this.config) return;
    
    const { maxReconnectAttempts, reconnectInterval } = this.config;
    
    if (this.reconnectAttempts >= maxReconnectAttempts!) {
      console.error('[WS] è¾¾åˆ°æœ€å¤§é‡è¿æ¬¡æ•°ï¼Œåœæ­¢é‡è¿');
      return;
    }
    
    this.reconnectAttempts++;
    console.log(`[WS] ${reconnectInterval}ms åè¿›è¡Œç¬¬ ${this.reconnectAttempts} æ¬¡é‡è¿...`);
    
    this.reconnectTimer = setTimeout(() => {
      this.createConnection();
    }, reconnectInterval);
  }
  
  private startHeartbeat(): void {
    if (!this.config?.heartbeatInterval) return;
    
    this.heartbeatTimer = setInterval(() => {
      this.send({ type: 'ping', timestamp: Date.now() });
    }, this.config.heartbeatInterval);
  }
  
  private stopHeartbeat(): void {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
  }
  
  private clearTimers(): void {
    this.stopHeartbeat();
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
  }
}

// å¯¼å‡ºå•ä¾‹è·å–æ–¹æ³•
export const getWebSocket = () => WebSocketManager.getInstance();

// ä¹Ÿå¯ä»¥ç›´æ¥å¯¼å‡ºå®ä¾‹ï¼ˆæ‡’åŠ è½½ï¼‰
export default WebSocketManager;
```

#### åœ¨ React ä¸­ä½¿ç”¨

```tsx
// hooks/useWebSocket.ts

import { useEffect, useState, useCallback } from 'react';
import { getWebSocket } from '../services/WebSocketManager';

interface UseWebSocketOptions {
  url: string;
  onMessage?: (data: any) => void;
  messageType?: string;
}

/**
 * WebSocket Hook
 * 
 * @example
 * const { isConnected, send } = useWebSocket({
 *   url: 'wss://chat.example.com',
 *   messageType: 'chat',
 *   onMessage: (data) => setMessages(prev => [...prev, data]),
 * });
 */
export const useWebSocket = (options: UseWebSocketOptions) => {
  const { url, onMessage, messageType = 'default' } = options;
  const [isConnected, setIsConnected] = useState(false);
  const [status, setStatus] = useState<'connecting' | 'connected' | 'disconnected' | 'reconnecting'>('disconnected');
  
  const ws = getWebSocket();
  
  useEffect(() => {
    // å»ºç«‹è¿æ¥
    ws.connect({ url });
    
    // ç›‘å¬è¿æ¥çŠ¶æ€
    const unsubConnect = ws.onConnect(() => {
      setIsConnected(true);
      setStatus('connected');
    });
    
    const unsubDisconnect = ws.onDisconnect(() => {
      setIsConnected(false);
      setStatus(ws.status);
    });
    
    // è®¢é˜…æ¶ˆæ¯
    let unsubMessage: (() => void) | undefined;
    if (onMessage) {
      unsubMessage = ws.subscribe(messageType, onMessage);
    }
    
    // åˆå§‹çŠ¶æ€
    setIsConnected(ws.isConnected);
    setStatus(ws.status);
    
    return () => {
      unsubConnect();
      unsubDisconnect();
      unsubMessage?.();
      // æ³¨æ„ï¼šä¸è¦åœ¨è¿™é‡Œæ–­å¼€è¿æ¥ï¼Œå› ä¸ºå…¶ä»–ç»„ä»¶å¯èƒ½è¿˜åœ¨ä½¿ç”¨
    };
  }, [url, messageType]);
  
  const send = useCallback((data: any) => {
    return ws.send(data);
  }, []);
  
  return { isConnected, status, send };
};
```

```tsx
// components/ChatRoom.tsx

import React, { useState } from 'react';
import { Input, Button, List } from 'antd';
import { useWebSocket } from '../hooks/useWebSocket';

interface Message {
  id: string;
  user: string;
  content: string;
  timestamp: number;
}

export const ChatRoom: React.FC = () => {
  const [messages, setMessages] = useState<Message[]>([]);
  const [inputValue, setInputValue] = useState('');
  
  // ä½¿ç”¨å•ä¾‹ WebSocket
  const { isConnected, status, send } = useWebSocket({
    url: 'wss://chat.example.com',
    messageType: 'chat',
    onMessage: (data) => {
      setMessages(prev => [...prev, data]);
    },
  });
  
  const handleSend = () => {
    if (!inputValue.trim()) return;
    
    send({
      type: 'chat',
      content: inputValue,
      timestamp: Date.now(),
    });
    
    setInputValue('');
  };
  
  return (
    <div>
      <div style={{ marginBottom: 16 }}>
        è¿æ¥çŠ¶æ€ï¼š
        <span style={{ color: isConnected ? 'green' : 'red' }}>
          {status}
        </span>
      </div>
      
      <List
        dataSource={messages}
        renderItem={(msg) => (
          <List.Item>
            <strong>{msg.user}ï¼š</strong>{msg.content}
          </List.Item>
        )}
        style={{ height: 300, overflow: 'auto', marginBottom: 16 }}
      />
      
      <Input.Search
        value={inputValue}
        onChange={(e) => setInputValue(e.target.value)}
        onSearch={handleSend}
        enterButton="å‘é€"
        disabled={!isConnected}
        placeholder={isConnected ? 'è¾“å…¥æ¶ˆæ¯...' : 'è¿æ¥ä¸­...'}
      />
    </div>
  );
};
```

---

### ğŸ”§ å‰ç«¯å®æˆ˜æ¡ˆä¾‹äºŒï¼šå…¨å±€ Loading ç®¡ç†å™¨

#### åœºæ™¯æè¿°

å®ç°ä¸€ä¸ªå…¨å±€ Loading ç®¡ç†å™¨ï¼Œæ”¯æŒå¤šä¸ªè¯·æ±‚åŒæ—¶ loading æ—¶åªæ˜¾ç¤ºä¸€ä¸ªï¼Œå…¨éƒ¨å®Œæˆåæ‰å…³é—­ã€‚

```tsx
// services/LoadingManager.ts

/**
 * å…¨å±€ Loading ç®¡ç†å™¨ï¼ˆå•ä¾‹ï¼‰
 * 
 * è§£å†³é—®é¢˜ï¼š
 * - å¤šä¸ªè¯·æ±‚åŒæ—¶å‘èµ·ï¼Œåªæ˜¾ç¤ºä¸€ä¸ª loading
 * - æœ€åä¸€ä¸ªè¯·æ±‚å®Œæˆåæ‰å…³é—­ loading
 * - é¿å… loading é—ªçƒ
 * 
 * @example
 * const loading = LoadingManager.getInstance();
 * loading.show('fetchUsers');  // å¼€å§‹åŠ è½½
 * loading.hide('fetchUsers');  // ç»“æŸåŠ è½½
 */
class LoadingManager {
  private static instance: LoadingManager | null = null;
  
  public static getInstance(): LoadingManager {
    if (!LoadingManager.instance) {
      LoadingManager.instance = new LoadingManager();
    }
    return LoadingManager.instance;
  }
  
  private constructor() {}
  
  // å½“å‰æ­£åœ¨ loading çš„è¯·æ±‚æ ‡è¯†é›†åˆ
  private loadingSet: Set<string> = new Set();
  
  // çŠ¶æ€å˜åŒ–å›è°ƒ
  private listeners: ((isLoading: boolean) => void)[] = [];
  
  // é˜²æŠ–å®šæ—¶å™¨
  private hideTimer: NodeJS.Timeout | null = null;
  
  // æœ€å°æ˜¾ç¤ºæ—¶é—´ï¼ˆé˜²æ­¢é—ªçƒï¼‰
  private minShowTime = 300;
  private showTimestamp = 0;
  
  /**
   * æ˜¾ç¤º loading
   * @param key å”¯ä¸€æ ‡è¯†ï¼ˆé€šå¸¸æ˜¯è¯·æ±‚çš„ URL æˆ–è‡ªå®šä¹‰ keyï¼‰
   */
  show(key: string = 'default'): void {
    const wasEmpty = this.loadingSet.size === 0;
    this.loadingSet.add(key);
    
    // å–æ¶ˆå»¶è¿Ÿéšè—
    if (this.hideTimer) {
      clearTimeout(this.hideTimer);
      this.hideTimer = null;
    }
    
    // å¦‚æœæ˜¯ç¬¬ä¸€ä¸ª loadingï¼Œè®°å½•å¼€å§‹æ—¶é—´å¹¶é€šçŸ¥
    if (wasEmpty) {
      this.showTimestamp = Date.now();
      this.notify(true);
    }
  }
  
  /**
   * éšè— loading
   * @param key å”¯ä¸€æ ‡è¯†
   */
  hide(key: string = 'default'): void {
    this.loadingSet.delete(key);
    
    // å¦‚æœè¿˜æœ‰å…¶ä»– loadingï¼Œä¸å¤„ç†
    if (this.loadingSet.size > 0) return;
    
    // è®¡ç®—å·²æ˜¾ç¤ºæ—¶é—´
    const elapsed = Date.now() - this.showTimestamp;
    const remaining = Math.max(0, this.minShowTime - elapsed);
    
    // å»¶è¿Ÿéšè—ï¼Œä¿è¯æœ€å°æ˜¾ç¤ºæ—¶é—´ï¼ˆé˜²æ­¢é—ªçƒï¼‰
    this.hideTimer = setTimeout(() => {
      if (this.loadingSet.size === 0) {
        this.notify(false);
      }
    }, remaining);
  }
  
  /**
   * å¼ºåˆ¶éšè—æ‰€æœ‰ loading
   */
  hideAll(): void {
    this.loadingSet.clear();
    if (this.hideTimer) {
      clearTimeout(this.hideTimer);
      this.hideTimer = null;
    }
    this.notify(false);
  }
  
  /**
   * è·å–å½“å‰æ˜¯å¦æ­£åœ¨ loading
   */
  get isLoading(): boolean {
    return this.loadingSet.size > 0;
  }
  
  /**
   * è·å–å½“å‰ loading çš„æ•°é‡
   */
  get count(): number {
    return this.loadingSet.size;
  }
  
  /**
   * è®¢é˜… loading çŠ¶æ€å˜åŒ–
   */
  subscribe(listener: (isLoading: boolean) => void): () => void {
    this.listeners.push(listener);
    // ç«‹å³é€šçŸ¥å½“å‰çŠ¶æ€
    listener(this.isLoading);
    
    return () => {
      const index = this.listeners.indexOf(listener);
      if (index > -1) {
        this.listeners.splice(index, 1);
      }
    };
  }
  
  private notify(isLoading: boolean): void {
    this.listeners.forEach(listener => listener(isLoading));
  }
}

export const loadingManager = LoadingManager.getInstance();
```

#### å°è£… axios æ‹¦æˆªå™¨

```tsx
// services/request.ts

import axios from 'axios';
import { loadingManager } from './LoadingManager';

const request = axios.create({
  baseURL: '/api',
  timeout: 30000,
});

// è¯·æ±‚æ‹¦æˆªå™¨
request.interceptors.request.use(
  (config) => {
    // ä½¿ç”¨è¯·æ±‚ URL ä½œä¸º loading çš„ key
    const loadingKey = `${config.method}-${config.url}`;
    
    // å¯ä»¥é€šè¿‡ config æ§åˆ¶æ˜¯å¦æ˜¾ç¤º loading
    if (config.headers?.showLoading !== false) {
      loadingManager.show(loadingKey);
    }
    
    // æŠŠ key å­˜èµ·æ¥ï¼Œå“åº”æ—¶ç”¨
    (config as any).__loadingKey = loadingKey;
    
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// å“åº”æ‹¦æˆªå™¨
request.interceptors.response.use(
  (response) => {
    const loadingKey = (response.config as any).__loadingKey;
    if (loadingKey) {
      loadingManager.hide(loadingKey);
    }
    return response;
  },
  (error) => {
    const loadingKey = error.config?.__loadingKey;
    if (loadingKey) {
      loadingManager.hide(loadingKey);
    }
    return Promise.reject(error);
  }
);

export default request;
```

#### å…¨å±€ Loading ç»„ä»¶

```tsx
// components/GlobalLoading.tsx

import React, { useEffect, useState } from 'react';
import { Spin } from 'antd';
import { loadingManager } from '../services/LoadingManager';

/**
 * å…¨å±€ Loading ç»„ä»¶
 * æ”¾åœ¨ App æ ¹ç»„ä»¶å³å¯
 */
export const GlobalLoading: React.FC = () => {
  const [isLoading, setIsLoading] = useState(false);
  
  useEffect(() => {
    // è®¢é˜… loading çŠ¶æ€
    const unsubscribe = loadingManager.subscribe(setIsLoading);
    return unsubscribe;
  }, []);
  
  if (!isLoading) return null;
  
  return (
    <div
      style={{
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: 'rgba(255, 255, 255, 0.7)',
        zIndex: 9999,
      }}
    >
      <Spin size="large" tip="åŠ è½½ä¸­..." />
    </div>
  );
};

// App.tsx ä¸­ä½¿ç”¨
// <App>
//   <GlobalLoading />
//   <Routes />
// </App>
```

---

### ğŸ”§ å‰ç«¯å®æˆ˜æ¡ˆä¾‹ä¸‰ï¼šå…¨å±€æ¶ˆæ¯å»é‡ç®¡ç†å™¨

#### åœºæ™¯æè¿°

é˜²æ­¢åŒä¸€æ¡æ¶ˆæ¯é‡å¤å¼¹å‡ºï¼Œæ¯”å¦‚ç½‘ç»œé”™è¯¯æç¤ºã€è¡¨å•éªŒè¯æç¤ºç­‰ã€‚

```tsx
// services/MessageManager.ts

import { message, notification } from 'antd';
import type { ArgsProps } from 'antd/es/message';

/**
 * å…¨å±€æ¶ˆæ¯ç®¡ç†å™¨ï¼ˆå•ä¾‹ï¼‰
 * 
 * è§£å†³é—®é¢˜ï¼š
 * - ç›¸åŒå†…å®¹çš„æ¶ˆæ¯ä¸é‡å¤å¼¹å‡º
 * - æ”¯æŒæ¶ˆæ¯é˜Ÿåˆ—å’Œå¹¶å‘æ§åˆ¶
 * - ç»Ÿä¸€çš„æ¶ˆæ¯æ ·å¼å’Œè¡Œä¸º
 * 
 * @example
 * const msg = MessageManager.getInstance();
 * msg.success('ä¿å­˜æˆåŠŸ');
 * msg.error('ç½‘ç»œé”™è¯¯');  // ç›¸åŒæ¶ˆæ¯ 3 ç§’å†…ä¸ä¼šé‡å¤
 */
class MessageManager {
  private static instance: MessageManager | null = null;
  
  public static getInstance(): MessageManager {
    if (!MessageManager.instance) {
      MessageManager.instance = new MessageManager();
    }
    return MessageManager.instance;
  }
  
  private constructor() {
    // é…ç½® antd message
    message.config({
      maxCount: 3,  // æœ€å¤šåŒæ—¶æ˜¾ç¤º 3 æ¡
      duration: 3,   // é»˜è®¤ 3 ç§’åå…³é—­
    });
  }
  
  // æ¶ˆæ¯å»é‡ç¼“å­˜ï¼škey ä¸ºæ¶ˆæ¯å†…å®¹çš„ hashï¼Œvalue ä¸ºè¿‡æœŸæ—¶é—´
  private messageCache: Map<string, number> = new Map();
  
  // å»é‡æ—¶é—´é—´éš”ï¼ˆæ¯«ç§’ï¼‰
  private dedupeInterval = 3000;
  
  /**
   * æˆåŠŸæ¶ˆæ¯
   */
  success(content: string, duration?: number): void {
    this.showMessage('success', content, duration);
  }
  
  /**
   * é”™è¯¯æ¶ˆæ¯
   */
  error(content: string, duration?: number): void {
    this.showMessage('error', content, duration);
  }
  
  /**
   * è­¦å‘Šæ¶ˆæ¯
   */
  warning(content: string, duration?: number): void {
    this.showMessage('warning', content, duration);
  }
  
  /**
   * ä¿¡æ¯æ¶ˆæ¯
   */
  info(content: string, duration?: number): void {
    this.showMessage('info', content, duration);
  }
  
  /**
   * åŠ è½½æ¶ˆæ¯ï¼ˆä¸å»é‡ï¼‰
   */
  loading(content: string, duration?: number): () => void {
    const hide = message.loading(content, duration || 0);
    return hide;
  }
  
  /**
   * æ˜¾ç¤ºé€šçŸ¥ï¼ˆå³ä¸Šè§’ï¼‰
   */
  notify(type: 'success' | 'error' | 'info' | 'warning', title: string, description: string): void {
    const key = this.hash(`notify-${type}-${title}-${description}`);
    
    if (this.isDuplicate(key)) {
      return;
    }
    
    notification[type]({
      message: title,
      description,
      placement: 'topRight',
    });
  }
  
  /**
   * æ¸…é™¤æ‰€æœ‰æ¶ˆæ¯
   */
  destroy(): void {
    message.destroy();
    notification.destroy();
    this.messageCache.clear();
  }
  
  // ==================== ç§æœ‰æ–¹æ³• ====================
  
  private showMessage(
    type: 'success' | 'error' | 'warning' | 'info',
    content: string,
    duration?: number
  ): void {
    const key = this.hash(`${type}-${content}`);
    
    // æ£€æŸ¥æ˜¯å¦é‡å¤
    if (this.isDuplicate(key)) {
      console.log(`[Message] æ¶ˆæ¯å·²å­˜åœ¨ï¼Œè·³è¿‡: ${content}`);
      return;
    }
    
    // æ˜¾ç¤ºæ¶ˆæ¯
    message[type](content, duration);
    
    // è®°å½•æ¶ˆæ¯ï¼Œè®¾ç½®è¿‡æœŸæ—¶é—´
    this.messageCache.set(key, Date.now() + this.dedupeInterval);
    
    // å®šæ—¶æ¸…ç†
    setTimeout(() => {
      this.messageCache.delete(key);
    }, this.dedupeInterval);
  }
  
  private isDuplicate(key: string): boolean {
    const expireTime = this.messageCache.get(key);
    if (!expireTime) return false;
    
    // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
    if (Date.now() > expireTime) {
      this.messageCache.delete(key);
      return false;
    }
    
    return true;
  }
  
  private hash(str: string): string {
    // ç®€å•çš„å­—ç¬¦ä¸² hash
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return hash.toString(36);
  }
}

// å¯¼å‡ºä¾¿æ·æ–¹æ³•
export const msg = MessageManager.getInstance();

// ä¹Ÿå¯ä»¥å¯¼å‡ºå¯¹è±¡å½¢å¼ï¼Œæ›´æ¥è¿‘ antd çš„ä½¿ç”¨ä¹ æƒ¯
export const globalMessage = {
  success: (content: string, duration?: number) => msg.success(content, duration),
  error: (content: string, duration?: number) => msg.error(content, duration),
  warning: (content: string, duration?: number) => msg.warning(content, duration),
  info: (content: string, duration?: number) => msg.info(content, duration),
  loading: (content: string, duration?: number) => msg.loading(content, duration),
  destroy: () => msg.destroy(),
};
```

#### ä½¿ç”¨ç¤ºä¾‹

```tsx
// services/api.ts

import axios from 'axios';
import { globalMessage } from './MessageManager';

// è¯·æ±‚æ‹¦æˆªå™¨ä¸­ç»Ÿä¸€å¤„ç†é”™è¯¯
axios.interceptors.response.use(
  (response) => response,
  (error) => {
    // ä½¿ç”¨å…¨å±€æ¶ˆæ¯ç®¡ç†å™¨ï¼Œç›¸åŒé”™è¯¯ä¸ä¼šé‡å¤å¼¹å‡º
    if (error.response?.status === 401) {
      globalMessage.error('ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•');
    } else if (error.response?.status === 403) {
      globalMessage.error('æ²¡æœ‰æƒé™è®¿é—®');
    } else if (error.response?.status >= 500) {
      globalMessage.error('æœåŠ¡å™¨é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•');
    } else if (error.code === 'ECONNABORTED') {
      globalMessage.error('è¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ');
    } else if (!error.response) {
      globalMessage.error('ç½‘ç»œè¿æ¥å¤±è´¥');  // å³ä½¿å¤šä¸ªè¯·æ±‚åŒæ—¶å¤±è´¥ï¼Œä¹Ÿåªå¼¹ä¸€æ¬¡
    }
    
    return Promise.reject(error);
  }
);
```

```tsx
// components/UserList.tsx

import React from 'react';
import { Button } from 'antd';
import { globalMessage } from '../services/MessageManager';

export const UserList: React.FC = () => {
  
  const handleBatchDelete = async () => {
    try {
      await Promise.all([
        deleteUser(1),
        deleteUser(2),
        deleteUser(3),
      ]);
      // å³ä½¿è°ƒç”¨ 3 æ¬¡ï¼Œä¹Ÿåªæ˜¾ç¤º 1 æ¡æˆåŠŸæ¶ˆæ¯
      globalMessage.success('åˆ é™¤æˆåŠŸ');
      globalMessage.success('åˆ é™¤æˆåŠŸ');
      globalMessage.success('åˆ é™¤æˆåŠŸ');
    } catch (error) {
      // åŒç†ï¼Œé”™è¯¯æ¶ˆæ¯ä¹Ÿåªæ˜¾ç¤º 1 æ¬¡
      globalMessage.error('åˆ é™¤å¤±è´¥');
    }
  };
  
  return (
    <Button onClick={handleBatchDelete}>æ‰¹é‡åˆ é™¤</Button>
  );
};
```

---

### ğŸ”§ å‰ç«¯å®æˆ˜æ¡ˆä¾‹å››ï¼šç¼“å­˜ç®¡ç†å™¨

#### åœºæ™¯æè¿°

å®ç°ä¸€ä¸ªæ”¯æŒè¿‡æœŸæ—¶é—´çš„å…¨å±€ç¼“å­˜ç®¡ç†å™¨ã€‚

```tsx
// services/CacheManager.ts

interface CacheItem<T> {
  value: T;
  expireAt: number | null;  // null è¡¨ç¤ºæ°¸ä¸è¿‡æœŸ
}

/**
 * å…¨å±€ç¼“å­˜ç®¡ç†å™¨ï¼ˆå•ä¾‹ï¼‰
 * 
 * ç‰¹ç‚¹ï¼š
 * - æ”¯æŒè¿‡æœŸæ—¶é—´
 * - æ”¯æŒ localStorage æŒä¹…åŒ–
 * - æ”¯æŒå‘½åç©ºé—´éš”ç¦»
 * 
 * @example
 * const cache = CacheManager.getInstance();
 * cache.set('user', userData, 3600);  // ç¼“å­˜ 1 å°æ—¶
 * const user = cache.get('user');
 */
class CacheManager {
  private static instance: CacheManager | null = null;
  
  public static getInstance(): CacheManager {
    if (!CacheManager.instance) {
      CacheManager.instance = new CacheManager();
    }
    return CacheManager.instance;
  }
  
  private constructor() {
    // å¯åŠ¨æ—¶æ¸…ç†è¿‡æœŸç¼“å­˜
    this.cleanup();
  }
  
  // å†…å­˜ç¼“å­˜
  private memoryCache: Map<string, CacheItem<any>> = new Map();
  
  // å­˜å‚¨å‰ç¼€
  private storagePrefix = 'app_cache_';
  
  /**
   * è®¾ç½®ç¼“å­˜
   * @param key ç¼“å­˜é”®
   * @param value ç¼“å­˜å€¼
   * @param ttl è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰ï¼Œä¸ä¼ åˆ™æ°¸ä¸è¿‡æœŸ
   * @param persist æ˜¯å¦æŒä¹…åŒ–åˆ° localStorage
   */
  set<T>(key: string, value: T, ttl?: number, persist = false): void {
    const expireAt = ttl ? Date.now() + ttl * 1000 : null;
    const item: CacheItem<T> = { value, expireAt };
    
    // å†…å­˜ç¼“å­˜
    this.memoryCache.set(key, item);
    
    // æŒä¹…åŒ–
    if (persist) {
      try {
        localStorage.setItem(
          this.storagePrefix + key,
          JSON.stringify(item)
        );
      } catch (error) {
        console.warn('[Cache] localStorage å­˜å‚¨å¤±è´¥:', error);
      }
    }
  }
  
  /**
   * è·å–ç¼“å­˜
   * @param key ç¼“å­˜é”®
   * @param fallback é»˜è®¤å€¼ï¼ˆç¼“å­˜ä¸å­˜åœ¨æˆ–å·²è¿‡æœŸæ—¶è¿”å›ï¼‰
   */
  get<T>(key: string, fallback?: T): T | undefined {
    // å…ˆä»å†…å­˜å–
    let item = this.memoryCache.get(key) as CacheItem<T> | undefined;
    
    // å†…å­˜æ²¡æœ‰ï¼Œå°è¯•ä» localStorage å–
    if (!item) {
      try {
        const stored = localStorage.getItem(this.storagePrefix + key);
        if (stored) {
          item = JSON.parse(stored);
          // åŒæ­¥åˆ°å†…å­˜
          if (item) {
            this.memoryCache.set(key, item);
          }
        }
      } catch {
        // å¿½ç•¥è§£æé”™è¯¯
      }
    }
    
    // ä¸å­˜åœ¨
    if (!item) {
      return fallback;
    }
    
    // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
    if (item.expireAt && Date.now() > item.expireAt) {
      this.delete(key);
      return fallback;
    }
    
    return item.value;
  }
  
  /**
   * åˆ é™¤ç¼“å­˜
   */
  delete(key: string): void {
    this.memoryCache.delete(key);
    try {
      localStorage.removeItem(this.storagePrefix + key);
    } catch {
      // å¿½ç•¥
    }
  }
  
  /**
   * æ£€æŸ¥ç¼“å­˜æ˜¯å¦å­˜åœ¨ä¸”æœ‰æ•ˆ
   */
  has(key: string): boolean {
    return this.get(key) !== undefined;
  }
  
  /**
   * æ¸…ç©ºæ‰€æœ‰ç¼“å­˜
   */
  clear(): void {
    this.memoryCache.clear();
    
    // æ¸…ç©º localStorage ä¸­çš„ç¼“å­˜
    try {
      const keys = Object.keys(localStorage);
      keys.forEach(key => {
        if (key.startsWith(this.storagePrefix)) {
          localStorage.removeItem(key);
        }
      });
    } catch {
      // å¿½ç•¥
    }
  }
  
  /**
   * è·å–æˆ–è®¾ç½®ç¼“å­˜ï¼ˆå¦‚æœä¸å­˜åœ¨åˆ™è°ƒç”¨ factory åˆ›å»ºï¼‰
   */
  async getOrSet<T>(
    key: string,
    factory: () => T | Promise<T>,
    ttl?: number,
    persist = false
  ): Promise<T> {
    const cached = this.get<T>(key);
    if (cached !== undefined) {
      return cached;
    }
    
    const value = await factory();
    this.set(key, value, ttl, persist);
    return value;
  }
  
  /**
   * æ¸…ç†è¿‡æœŸç¼“å­˜
   */
  private cleanup(): void {
    const now = Date.now();
    
    // æ¸…ç†å†…å­˜ç¼“å­˜
    this.memoryCache.forEach((item, key) => {
      if (item.expireAt && now > item.expireAt) {
        this.memoryCache.delete(key);
      }
    });
    
    // æ¸…ç† localStorage
    try {
      const keys = Object.keys(localStorage);
      keys.forEach(key => {
        if (key.startsWith(this.storagePrefix)) {
          try {
            const item = JSON.parse(localStorage.getItem(key) || '');
            if (item.expireAt && now > item.expireAt) {
              localStorage.removeItem(key);
            }
          } catch {
            // è§£æå¤±è´¥ï¼Œåˆ é™¤
            localStorage.removeItem(key);
          }
        }
      });
    } catch {
      // å¿½ç•¥
    }
  }
}

export const cache = CacheManager.getInstance();
```

#### ä½¿ç”¨ç¤ºä¾‹

```tsx
// services/userService.ts

import { cache } from './CacheManager';

/**
 * è·å–ç”¨æˆ·ä¿¡æ¯ï¼ˆå¸¦ç¼“å­˜ï¼‰
 */
export const getUserInfo = async (userId: string) => {
  // ä½¿ç”¨ getOrSetï¼Œæœ‰ç¼“å­˜ç›´æ¥è¿”å›ï¼Œæ²¡æœ‰åˆ™è¯·æ±‚
  return cache.getOrSet(
    `user_${userId}`,
    async () => {
      const response = await fetch(`/api/users/${userId}`);
      return response.json();
    },
    300,  // ç¼“å­˜ 5 åˆ†é’Ÿ
    false // ä¸æŒä¹…åŒ–
  );
};

/**
 * è·å–ç³»ç»Ÿé…ç½®ï¼ˆæŒä¹…åŒ–ç¼“å­˜ï¼‰
 */
export const getSystemConfig = async () => {
  return cache.getOrSet(
    'system_config',
    async () => {
      const response = await fetch('/api/config');
      return response.json();
    },
    3600,  // ç¼“å­˜ 1 å°æ—¶
    true   // æŒä¹…åŒ–åˆ° localStorage
  );
};
```

---

### ğŸ“Š æ¨¡å¼æ€»ç»“

#### âœ… ä¼˜ç‚¹

| ä¼˜ç‚¹ | è¯´æ˜ |
|------|------|
| **èµ„æºèŠ‚çœ** | é¿å…åˆ›å»ºå¤šä¸ªç›¸åŒçš„å®ä¾‹ï¼ŒèŠ‚çœå†…å­˜ |
| **çŠ¶æ€ä¸€è‡´** | å…¨å±€åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼ŒçŠ¶æ€ç»Ÿä¸€ç®¡ç† |
| **æ˜“äºè®¿é—®** | æä¾›å…¨å±€è®¿é—®ç‚¹ï¼Œéšå¤„å¯ç”¨ |
| **å»¶è¿Ÿåˆå§‹åŒ–** | å¯ä»¥åœ¨é¦–æ¬¡ä½¿ç”¨æ—¶æ‰åˆ›å»ºå®ä¾‹ |
| **ç”Ÿå‘½å‘¨æœŸå¯æ§** | å®ä¾‹åœ¨æ•´ä¸ªåº”ç”¨ç”Ÿå‘½å‘¨æœŸå†…å­˜åœ¨ |

#### âŒ ç¼ºç‚¹

| ç¼ºç‚¹ | è¯´æ˜ |
|------|------|
| **å…¨å±€çŠ¶æ€** | æœ¬è´¨æ˜¯å…¨å±€å˜é‡ï¼Œå¯èƒ½å¯¼è‡´éš¾ä»¥è¿½è¸ªçš„ bug |
| **æµ‹è¯•å›°éš¾** | å•ä¾‹çŠ¶æ€åœ¨æµ‹è¯•é—´å…±äº«ï¼Œéœ€è¦æ‰‹åŠ¨é‡ç½® |
| **éšè—ä¾èµ–** | ç»„ä»¶ä¾èµ–å•ä¾‹ï¼Œä½†ä»æ¥å£ä¸Šçœ‹ä¸å‡ºæ¥ |
| **å¹¶å‘é—®é¢˜** | åœ¨æŸäº›åœºæ™¯ä¸‹å¯èƒ½æœ‰ç«æ€æ¡ä»¶ |
| **è¿åå•ä¸€èŒè´£** | æ—¢è´Ÿè´£åˆ›å»ºå®ä¾‹ï¼Œåˆè´Ÿè´£ç®¡ç†ç”Ÿå‘½å‘¨æœŸ |

#### ğŸ¯ é€‚ç”¨åœºæ™¯

| åœºæ™¯ | ç¤ºä¾‹ |
|------|------|
| **èµ„æºç®¡ç†** | WebSocket è¿æ¥ã€æ•°æ®åº“è¿æ¥ |
| **çŠ¶æ€å…±äº«** | å…¨å±€é…ç½®ã€ç”¨æˆ·ä¿¡æ¯ |
| **åŠŸèƒ½åè°ƒ** | Loading ç®¡ç†ã€æ¶ˆæ¯ç®¡ç† |
| **ç¼“å­˜æœåŠ¡** | æ•°æ®ç¼“å­˜ã€è¯·æ±‚ç¼“å­˜ |
| **æ—¥å¿—æœåŠ¡** | ç»Ÿä¸€çš„æ—¥å¿—è®°å½•å™¨ |

#### ğŸš« ä¸é€‚ç”¨åœºæ™¯

- éœ€è¦å¤šä¸ªç‹¬ç«‹å®ä¾‹çš„åœºæ™¯
- å®ä¾‹çŠ¶æ€éœ€è¦é¢‘ç¹é‡ç½®çš„åœºæ™¯
- éœ€è¦ä¾èµ–æ³¨å…¥ã€æ˜“äºæµ‹è¯•çš„åœºæ™¯
- ç»„ä»¶çº§åˆ«çš„çŠ¶æ€ç®¡ç†ï¼ˆåº”è¯¥ç”¨ React çŠ¶æ€ï¼‰

---

### âš ï¸ å•ä¾‹æ¨¡å¼åœ¨ React ä¸­çš„æ³¨æ„äº‹é¡¹

#### 1. é¿å…åœ¨å•ä¾‹ä¸­ç›´æ¥ä½¿ç”¨ React çŠ¶æ€

```tsx
// âŒ é”™è¯¯ï¼šå•ä¾‹ä¸­ä½¿ç”¨ React Hook
class BadSingleton {
  private static instance: BadSingleton;
  
  getData() {
    const [data] = useState([]);  // é”™è¯¯ï¼Hook åªèƒ½åœ¨ç»„ä»¶ä¸­ä½¿ç”¨
    return data;
  }
}

// âœ… æ­£ç¡®ï¼šå•ä¾‹æä¾›æ•°æ®ï¼Œç»„ä»¶ç®¡ç†çŠ¶æ€
class GoodSingleton {
  private static instance: GoodSingleton;
  private listeners: ((data: any) => void)[] = [];
  
  subscribe(listener: (data: any) => void) {
    this.listeners.push(listener);
    return () => { /* å–æ¶ˆè®¢é˜… */ };
  }
}

// ç»„ä»¶ä¸­ä½¿ç”¨
const Component = () => {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    return singleton.subscribe(setData);
  }, []);
};
```

#### 2. æµ‹è¯•æ—¶éœ€è¦é‡ç½®å•ä¾‹

```tsx
// test-utils.ts
export const resetSingletons = () => {
  // é‡ç½®å„ä¸ªå•ä¾‹çš„å†…éƒ¨çŠ¶æ€
  (WebSocketManager as any).instance = null;
  (CacheManager as any).instance = null;
};

// åœ¨æ¯ä¸ªæµ‹è¯•å‰è°ƒç”¨
beforeEach(() => {
  resetSingletons();
});
```

#### 3. è€ƒè™‘ä½¿ç”¨ React Context æ›¿ä»£

```tsx
// å¯¹äº React ç»„ä»¶çº§åˆ«çš„"å•ä¾‹"éœ€æ±‚ï¼ŒContext é€šå¸¸æ˜¯æ›´å¥½çš„é€‰æ‹©
const ThemeContext = createContext<Theme>(defaultTheme);

// è¿™æ ·å¯ä»¥ï¼š
// 1. æ”¯æŒ SSRï¼ˆæœåŠ¡ç«¯æ¸²æŸ“ï¼‰
// 2. æ”¯æŒæµ‹è¯•æ—¶æ³¨å…¥ä¸åŒçš„å€¼
// 3. æ”¯æŒç»„ä»¶æ ‘ä¸­çš„ä¸åŒå€¼ï¼ˆå¦‚éœ€è¦ï¼‰
```

---

### ğŸ¤” é€‰æ‹©å»ºè®®ï¼šä»€ä¹ˆæ—¶å€™ç”¨å•ä¾‹æ¨¡å¼ï¼Ÿ

é—®è‡ªå·±è¿™å‡ ä¸ªé—®é¢˜ï¼š

```
1. è¿™ä¸ªå®ä¾‹æ˜¯å¦å¿…é¡»å…¨å±€å”¯ä¸€ï¼Ÿå¤šä¸ªå®ä¾‹ä¼šå¯¼è‡´é—®é¢˜å—ï¼Ÿ
   â†’ æ˜¯çš„è¯ï¼Œè€ƒè™‘å•ä¾‹

2. è¿™ä¸ªå®ä¾‹æ˜¯å¦éœ€è¦åœ¨æ•´ä¸ªåº”ç”¨ç”Ÿå‘½å‘¨æœŸå†…å­˜åœ¨ï¼Ÿ
   â†’ æ˜¯çš„è¯ï¼Œè€ƒè™‘å•ä¾‹

3. è¿™ä¸ªå®ä¾‹æ˜¯å¦éœ€è¦è·¨ç»„ä»¶å…±äº«çŠ¶æ€ï¼Ÿ
   â†’ å¦‚æœæ˜¯ UI çŠ¶æ€ï¼Œä¼˜å…ˆè€ƒè™‘ Context
   â†’ å¦‚æœæ˜¯é UI çŠ¶æ€ï¼ˆå¦‚ WebSocketï¼‰ï¼Œè€ƒè™‘å•ä¾‹

4. è¿™ä¸ªå®ä¾‹æ˜¯å¦æ¶‰åŠèµ„æºç®¡ç†ï¼ˆè¿æ¥ã€ç¼“å­˜ï¼‰ï¼Ÿ
   â†’ æ˜¯çš„è¯ï¼Œè€ƒè™‘å•ä¾‹

5. æµ‹è¯•æ—¶æ˜¯å¦éœ€è¦æ›¿æ¢è¿™ä¸ªå®ä¾‹ï¼Ÿ
   â†’ å¦‚æœæ˜¯ï¼Œè€ƒè™‘ä¾èµ–æ³¨å…¥ + å•ä¾‹ï¼Œæˆ–ç”¨ Context
```

---

### ğŸ“ æ–‡ä»¶ç»“æ„å‚è€ƒ

```
src/
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ WebSocketManager.ts      # WebSocket å•ä¾‹
â”‚   â”œâ”€â”€ LoadingManager.ts        # Loading å•ä¾‹
â”‚   â”œâ”€â”€ MessageManager.ts        # æ¶ˆæ¯å•ä¾‹
â”‚   â””â”€â”€ CacheManager.ts          # ç¼“å­˜å•ä¾‹
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useWebSocket.ts          # WebSocket Hook
â”‚   â””â”€â”€ useLoading.ts            # Loading Hook
â”œâ”€â”€ components/
â”‚   â””â”€â”€ GlobalLoading.tsx        # å…¨å±€ Loading ç»„ä»¶
â””â”€â”€ App.tsx
```

---

> **ä¸‹ä¸€ç« é¢„å‘Šï¼šã€Šè§‚å¯Ÿè€…æ¨¡å¼ã€‹â€”â€” åˆ« Call æˆ‘ï¼Œæœ‰äº‹æˆ‘ä¼šé€šçŸ¥ä½ **
> 
> æˆ‘ä»¬å°†è®²è§£å¦‚ä½•å®ç°äº‹ä»¶æ€»çº¿ã€çŠ¶æ€è®¢é˜…ã€è·¨ç»„ä»¶é€šä¿¡ç­‰åœºæ™¯ã€‚

---

*å¦‚æœ‰ç–‘é—®æˆ–å»ºè®®ï¼Œæ¬¢è¿äº¤æµï¼*

