# 《前端设计模式实战手册》

## 第一章：工厂方法模式（Factory Method Pattern）

---

### 🎯 一句话大白话

> **工厂方法模式就像奶茶店的点单系统：你只需要说"我要一杯珍珠奶茶"，不需要知道珍珠怎么煮、奶茶怎么调。点单台（工厂）会帮你搞定一切，最后递给你一杯成品。**

你只管"要什么"，不用关心"怎么做"。

---

### 😫 前端痛点：没有工厂时的噩梦

想象一下这个场景：你在做一个 **CRM 系统**，需要根据不同的业务类型渲染不同的表单组件：

```tsx
// ❌ 噩梦代码：到处都是 if-else
function renderFormItem(type: string, config: any) {
  if (type === 'input') {
    return <Input placeholder={config.placeholder} maxLength={config.maxLength} />;
  } else if (type === 'select') {
    return (
      <Select options={config.options} mode={config.mode}>
        {config.options.map(opt => <Select.Option key={opt.value} value={opt.value}>{opt.label}</Select.Option>)}
      </Select>
    );
  } else if (type === 'datePicker') {
    return <DatePicker format={config.format} showTime={config.showTime} />;
  } else if (type === 'upload') {
    return <Upload action={config.action} listType={config.listType} />;
  } else if (type === 'cascader') {
    return <Cascader options={config.options} />;
  }
  // ... 还有 20 多种类型等着你
  return null;
}
```

**这段代码有什么问题？**

| 问题 | 描述 |
|------|------|
| 🔴 **违反开闭原则** | 每增加一种表单类型，都要修改这个函数，改着改着就成了"屎山" |
| 🔴 **难以测试** | 一个函数承担了所有类型的创建逻辑，单元测试写到你怀疑人生 |
| 🔴 **代码膨胀** | 当类型超过 10 种，这个函数可能有 500 行 |
| 🔴 **团队协作困难** | 多人同时修改这个文件，Git 冲突到你想辞职 |

---

### 💡 模式核心概念

工厂方法模式的核心思想是：

> **定义一个创建对象的接口，但让子类（或具体的工厂函数）决定实例化哪一个类。**

用大白话说就是：
- 把 "创建组件的逻辑" 从 "使用组件的地方" 抽离出来
- 每种类型的组件都有自己的"小工厂"
- 需要新增类型？加一个新工厂就行，原有代码纹丝不动

**类比理解：**

```
普通做法：你自己买材料、自己做奶茶 → 累死
工厂模式：你去奶茶店点单，店员帮你做 → 舒服
```

---

### 🔧 前端实战案例：动态表单组件工厂

#### 场景描述

我们要实现一个 **可配置的动态表单系统**，后端返回表单配置 JSON，前端根据配置渲染对应的 Ant Design 组件。

#### Step 1: 定义组件工厂的类型契约

```tsx
// types/formFactory.ts

import { ReactNode } from 'react';

// 表单项的基础配置
export interface FormItemConfig {
  type: string;           // 组件类型
  name: string;           // 字段名
  label: string;          // 标签
  required?: boolean;     // 是否必填
  props?: Record<string, any>;  // 组件特有属性
}

// 工厂方法的统一接口 —— 这是关键！
export type FormItemFactory = (config: FormItemConfig) => ReactNode;
```

#### Step 2: 为每种类型创建独立的工厂函数

**Input 工厂**

```tsx
// factories/inputFactory.tsx

import { Input } from 'antd';
import { FormItemConfig } from '../types/formFactory';

/**
 * Input 组件工厂
 * 负责创建各种 Input 类型的组件
 */
export const createInputItem = (config: FormItemConfig) => {
  const { props = {} } = config;
  
  // 根据 inputType 决定渲染 Input 还是 TextArea
  if (props.inputType === 'textarea') {
    return (
      <Input.TextArea
        placeholder={props.placeholder}
        maxLength={props.maxLength}
        showCount={props.showCount}
        rows={props.rows || 4}
      />
    );
  }
  
  if (props.inputType === 'password') {
    return <Input.Password placeholder={props.placeholder} />;
  }
  
  return (
    <Input
      placeholder={props.placeholder}
      maxLength={props.maxLength}
      allowClear={props.allowClear}
    />
  );
};
```

**Select 工厂**

```tsx
// factories/selectFactory.tsx

import { Select } from 'antd';
import { FormItemConfig } from '../types/formFactory';

/**
 * Select 组件工厂
 * 支持单选、多选、可搜索等模式
 */
export const createSelectItem = (config: FormItemConfig) => {
  const { props = {} } = config;
  
  return (
    <Select
      mode={props.mode}
      placeholder={props.placeholder}
      allowClear={props.allowClear}
      showSearch={props.showSearch}
      options={props.options}
      optionFilterProp="label"
    />
  );
};
```

**DatePicker 工厂**

```tsx
// factories/datePickerFactory.tsx

import { DatePicker } from 'antd';
import { FormItemConfig } from '../types/formFactory';

const { RangePicker } = DatePicker;

/**
 * DatePicker 组件工厂
 * 支持单日期、日期范围、带时间等模式
 */
export const createDatePickerItem = (config: FormItemConfig) => {
  const { props = {} } = config;
  
  // 日期范围选择器
  if (props.isRange) {
    return (
      <RangePicker
        format={props.format || 'YYYY-MM-DD'}
        showTime={props.showTime}
      />
    );
  }
  
  return (
    <DatePicker
      format={props.format || 'YYYY-MM-DD'}
      showTime={props.showTime}
      style={{ width: '100%' }}
    />
  );
};
```

#### Step 3: 创建工厂注册中心（核心！）

```tsx
// factories/formItemFactoryRegistry.ts

import { FormItemFactory, FormItemConfig } from '../types/formFactory';
import { createInputItem } from './inputFactory';
import { createSelectItem } from './selectFactory';
import { createDatePickerItem } from './datePickerFactory';

/**
 * 表单组件工厂注册中心
 * 
 * 这就像是"奶茶店的菜单"：
 * - 菜单上有什么饮品（type），对应什么制作方法（factory）
 * - 新增饮品？往菜单上加一行就行
 */
class FormItemFactoryRegistry {
  // 工厂映射表：type -> factory
  private factories: Map<string, FormItemFactory> = new Map();
  
  // 注册一个新工厂
  register(type: string, factory: FormItemFactory) {
    this.factories.set(type, factory);
    return this; // 支持链式调用
  }
  
  // 根据配置创建组件
  create(config: FormItemConfig) {
    const factory = this.factories.get(config.type);
    
    if (!factory) {
      console.warn(`未找到类型为 "${config.type}" 的组件工厂`);
      return null;
    }
    
    return factory(config);
  }
  
  // 检查某个类型是否已注册
  has(type: string) {
    return this.factories.has(type);
  }
}

// 创建单例并注册默认工厂
export const formItemFactory = new FormItemFactoryRegistry()
  .register('input', createInputItem)
  .register('select', createSelectItem)
  .register('datePicker', createDatePickerItem);

// 导出注册方法，方便业务扩展
export const registerFormItemFactory = (type: string, factory: FormItemFactory) => {
  formItemFactory.register(type, factory);
};
```

#### Step 4: 在业务组件中使用

```tsx
// components/DynamicForm.tsx

import React from 'react';
import { Form, Button } from 'antd';
import { formItemFactory } from '../factories/formItemFactoryRegistry';
import { FormItemConfig } from '../types/formFactory';

interface DynamicFormProps {
  /** 表单配置，通常由后端下发 */
  formConfig: FormItemConfig[];
  /** 提交回调 */
  onSubmit: (values: any) => void;
}

/**
 * 动态表单组件
 * 
 * 核心亮点：
 * - 这个组件完全不知道有哪些表单类型
 * - 它只负责遍历配置，让工厂去创建具体组件
 * - 新增表单类型？这个组件不用改一行代码！
 */
export const DynamicForm: React.FC<DynamicFormProps> = ({ formConfig, onSubmit }) => {
  const [form] = Form.useForm();
  
  return (
    <Form form={form} layout="vertical" onFinish={onSubmit}>
      {formConfig.map((config) => (
        <Form.Item
          key={config.name}
          name={config.name}
          label={config.label}
          rules={config.required ? [{ required: true, message: `请输入${config.label}` }] : []}
        >
          {/* 🎯 关键一行：工厂帮我们创建组件 */}
          {formItemFactory.create(config)}
        </Form.Item>
      ))}
      
      <Form.Item>
        <Button type="primary" htmlType="submit">
          提交
        </Button>
      </Form.Item>
    </Form>
  );
};
```

#### Step 5: 实际使用示例

```tsx
// pages/UserForm.tsx

import React from 'react';
import { message } from 'antd';
import { DynamicForm } from '../components/DynamicForm';
import { FormItemConfig } from '../types/formFactory';

// 模拟后端返回的表单配置
const userFormConfig: FormItemConfig[] = [
  {
    type: 'input',
    name: 'username',
    label: '用户名',
    required: true,
    props: { placeholder: '请输入用户名', maxLength: 20 }
  },
  {
    type: 'input',
    name: 'password',
    label: '密码',
    required: true,
    props: { inputType: 'password', placeholder: '请输入密码' }
  },
  {
    type: 'select',
    name: 'role',
    label: '角色',
    required: true,
    props: {
      placeholder: '请选择角色',
      options: [
        { label: '管理员', value: 'admin' },
        { label: '普通用户', value: 'user' },
        { label: '访客', value: 'guest' }
      ]
    }
  },
  {
    type: 'datePicker',
    name: 'expireDate',
    label: '过期时间',
    props: { showTime: true }
  },
  {
    type: 'input',
    name: 'remark',
    label: '备注',
    props: { inputType: 'textarea', rows: 3, placeholder: '请输入备注信息' }
  }
];

export const UserFormPage: React.FC = () => {
  const handleSubmit = (values: any) => {
    console.log('表单数据:', values);
    message.success('提交成功！');
  };
  
  return (
    <div style={{ maxWidth: 600, margin: '0 auto', padding: 24 }}>
      <h2>用户信息表单</h2>
      <DynamicForm formConfig={userFormConfig} onSubmit={handleSubmit} />
    </div>
  );
};
```

#### 扩展：如何新增一个组件类型？

假设现在要新增一个 **上传组件**，你只需要：

```tsx
// factories/uploadFactory.tsx

import { Upload, Button } from 'antd';
import { UploadOutlined } from '@ant-design/icons';
import { FormItemConfig } from '../types/formFactory';

export const createUploadItem = (config: FormItemConfig) => {
  const { props = {} } = config;
  
  return (
    <Upload
      action={props.action || '/api/upload'}
      listType={props.listType || 'text'}
      maxCount={props.maxCount}
    >
      <Button icon={<UploadOutlined />}>点击上传</Button>
    </Upload>
  );
};

// 然后在入口处注册
import { registerFormItemFactory } from '../factories/formItemFactoryRegistry';
registerFormItemFactory('upload', createUploadItem);
```

**搞定！原有代码一行不改。** 🎉

---

### 📊 模式总结

#### ✅ 优点

| 优点 | 说明 |
|------|------|
| **遵循开闭原则** | 对扩展开放，对修改关闭。新增类型不影响现有代码 |
| **单一职责** | 每个工厂只负责创建一种类型的组件 |
| **易于测试** | 每个工厂函数可以独立测试 |
| **支持团队协作** | 不同人可以并行开发不同的工厂，互不干扰 |
| **解耦** | 使用方不需要知道组件的具体创建细节 |

#### ❌ 缺点

| 缺点 | 说明 |
|------|------|
| **代码量增加** | 简单场景下可能显得"杀鸡用牛刀" |
| **理解成本** | 新人需要理解工厂的注册和调用机制 |
| **调试链路变长** | 出问题时需要跟踪到具体的工厂函数 |

#### 🎯 适用场景

| 场景 | 示例 |
|------|------|
| **动态表单系统** | 根据后端配置渲染不同的表单组件 |
| **图表渲染引擎** | 根据类型渲染折线图、柱状图、饼图等 |
| **弹窗管理系统** | 根据业务类型创建不同内容的弹窗 |
| **消息通知系统** | 根据消息类型渲染不同样式的通知 |
| **组件库封装** | 提供统一的组件创建入口 |

#### 🚫 不适用场景

- 组件类型固定且很少（< 3 种）
- 创建逻辑非常简单，一行代码就能搞定
- 团队对设计模式不熟悉，维护成本 > 收益

---

### 🤔 选择建议：什么时候用工厂方法模式？

问自己这几个问题：

```
1. 你的代码里是否有超过 5 个 if-else 或 switch-case 来判断创建哪个组件？
   → 是的话，考虑用工厂模式

2. 你是否经常需要新增"类型"，而每次都要改同一个文件？
   → 是的话，考虑用工厂模式

3. 你的组件创建逻辑是否复杂，涉及多个参数的组合？
   → 是的话，考虑用工厂模式

4. 你是否需要在运行时动态决定创建哪种组件？
   → 是的话，考虑用工厂模式
```

---

### 📁 文件结构参考

```
src/
├── types/
│   └── formFactory.ts          # 类型定义
├── factories/
│   ├── formItemFactoryRegistry.ts  # 工厂注册中心
│   ├── inputFactory.tsx        # Input 工厂
│   ├── selectFactory.tsx       # Select 工厂
│   ├── datePickerFactory.tsx   # DatePicker 工厂
│   └── uploadFactory.tsx       # Upload 工厂（扩展）
├── components/
│   └── DynamicForm.tsx         # 动态表单组件
└── pages/
    └── UserForm.tsx            # 业务页面
```

---

> **下一章预告：《单例模式》—— 全局只有一个"老婆"的正确打开方式**
> 
> 我们将讲解如何优雅地管理全局状态、弹窗实例、API 客户端等"全局唯一"的场景。

---

*如有疑问或建议，欢迎交流！*

