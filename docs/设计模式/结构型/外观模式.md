# ã€Šå‰ç«¯è®¾è®¡æ¨¡å¼å®æˆ˜æ‰‹å†Œã€‹

## ç¬¬åç« ï¼šå¤–è§‚æ¨¡å¼ï¼ˆFacade Patternï¼‰

---

### ğŸ¯ ä¸€å¥è¯å¤§ç™½è¯

> **å¤–è§‚æ¨¡å¼å°±åƒæ™ºèƒ½å®¶å±…çš„æ§åˆ¶ä¸­å¿ƒï¼šä½ ä¸éœ€è¦çŸ¥é“ç©ºè°ƒæ€ä¹ˆè°ƒæ¸©åº¦ã€ç¯å…‰æ€ä¹ˆå¼€å…³ã€çª—å¸˜æ€ä¹ˆæ‹‰ï¼Œä½ åªéœ€è¦å¯¹ç€æ§åˆ¶ä¸­å¿ƒè¯´"æˆ‘è¦ç¡è§‰æ¨¡å¼"ï¼Œå®ƒå°±ä¼šè‡ªåŠ¨å¸®ä½ å…³ç¯ã€æ‹‰çª—å¸˜ã€è°ƒç©ºè°ƒæ¸©åº¦ã€‚æ§åˆ¶ä¸­å¿ƒå°±æ˜¯"å¤–è§‚"ï¼Œå®ƒéšè—äº†æ‰€æœ‰è®¾å¤‡çš„å¤æ‚æ“ä½œã€‚**

**æ ¸å¿ƒç†å¿µï¼šä¸ºå¤æ‚çš„å­ç³»ç»Ÿæä¾›ä¸€ä¸ªç»Ÿä¸€çš„æ¥å£ï¼Œéšè—å­ç³»ç»Ÿçš„å¤æ‚æ€§ï¼Œè®©å®¢æˆ·ç«¯æ›´å®¹æ˜“ä½¿ç”¨ã€‚**

---

### ğŸ¤” ä»€ä¹ˆæ—¶å€™éœ€è¦"å¤–è§‚"ï¼Ÿ

åœ¨å‰ç«¯å¼€å‘ä¸­ï¼Œç»å¸¸ä¼šé‡åˆ°éœ€è¦ç®€åŒ–å¤æ‚ç³»ç»Ÿä½¿ç”¨çš„åœºæ™¯ï¼š

| åœºæ™¯ | ä¸ºä»€ä¹ˆéœ€è¦å¤–è§‚æ¨¡å¼ |
|------|------------------|
| **API å°è£…** | å¤šä¸ªç›¸å…³ API è°ƒç”¨ï¼Œéœ€è¦ç»Ÿä¸€å°è£… |
| **ç»„ä»¶åº“å°è£…** | å¤æ‚ç»„ä»¶çš„ä½¿ç”¨ï¼Œéœ€è¦ç®€åŒ–æ¥å£ |
| **å·¥å…·å‡½æ•°å°è£…** | å¤šä¸ªå·¥å…·å‡½æ•°ï¼Œéœ€è¦ç»Ÿä¸€å…¥å£ |
| **çŠ¶æ€ç®¡ç†å°è£…** | Redux/Zustand ä½¿ç”¨å¤æ‚ï¼Œéœ€è¦ç®€åŒ– |
| **ç¬¬ä¸‰æ–¹åº“å°è£…** | ç¬¬ä¸‰æ–¹åº“ API å¤æ‚ï¼Œéœ€è¦ç®€åŒ– |
| **æ–‡ä»¶æ“ä½œå°è£…** | æ–‡ä»¶ä¸Šä¼ /ä¸‹è½½/é¢„è§ˆç­‰æ“ä½œï¼Œéœ€è¦ç»Ÿä¸€æ¥å£ |
| **è¡¨å•å¤„ç†å°è£…** | è¡¨å•éªŒè¯/æäº¤/é‡ç½®ç­‰æ“ä½œï¼Œéœ€è¦ç»Ÿä¸€æ¥å£ |

---

### ğŸ˜« å‰ç«¯ç—›ç‚¹ï¼šæ²¡æœ‰å¤–è§‚æ—¶çš„å™©æ¢¦

#### åœºæ™¯ä¸€ï¼šAPI è°ƒç”¨å¤æ‚

```tsx
// âŒ å™©æ¢¦ä»£ç ï¼šæ¯æ¬¡éƒ½è¦å†™å®Œæ•´çš„ API è°ƒç”¨é€»è¾‘

// åˆ›å»ºç”¨æˆ·
const createUser = async (userData: { name: string; email: string }) => {
  const token = localStorage.getItem('token');
  const response = await fetch('/api/users', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`,
      'X-Request-Id': generateRequestId(),
      'X-Timestamp': String(Date.now()),
    },
    body: JSON.stringify(userData),
  });
  
  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message || 'åˆ›å»ºç”¨æˆ·å¤±è´¥');
  }
  
  return response.json();
};

// æ›´æ–°ç”¨æˆ· - åˆè¦å†™ä¸€éå‡ ä¹ä¸€æ ·çš„ä»£ç 
const updateUser = async (id: string, userData: Partial<User>) => {
  const token = localStorage.getItem('token');
  const response = await fetch(`/api/users/${id}`, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`,
      'X-Request-Id': generateRequestId(),
      'X-Timestamp': String(Date.now()),
    },
    body: JSON.stringify(userData),
  });
  
  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message || 'æ›´æ–°ç”¨æˆ·å¤±è´¥');
  }
  
  return response.json();
};

// é—®é¢˜ï¼š
// 1. ä»£ç é‡å¤ï¼Œæ¯ä¸ª API éƒ½è¦å†™ä¸€éè¯·æ±‚å¤´ã€é”™è¯¯å¤„ç†
// 2. ä½¿ç”¨å¤æ‚ï¼Œéœ€è¦çŸ¥é“å¾ˆå¤šç»†èŠ‚
// 3. éš¾ä»¥ç»´æŠ¤ï¼Œæ”¹ä¸€ä¸ªåœ°æ–¹è¦æ”¹å¾ˆå¤šåœ°æ–¹
```

#### åœºæ™¯äºŒï¼šæ–‡ä»¶æ“ä½œå¤æ‚

```tsx
// âŒ å™©æ¢¦ä»£ç ï¼šæ–‡ä»¶æ“ä½œéœ€è¦çŸ¥é“å¾ˆå¤šç»†èŠ‚

// ä¸Šä¼ æ–‡ä»¶
const uploadFile = async (file: File) => {
  // 1. æ£€æŸ¥æ–‡ä»¶å¤§å°
  if (file.size > 10 * 1024 * 1024) {
    throw new Error('æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡ 10MB');
  }
  
  // 2. æ£€æŸ¥æ–‡ä»¶ç±»å‹
  const allowedTypes = ['image/jpeg', 'image/png', 'application/pdf'];
  if (!allowedTypes.includes(file.type)) {
    throw new Error('ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹');
  }
  
  // 3. å‹ç¼©å›¾ç‰‡ï¼ˆå¦‚æœæ˜¯å›¾ç‰‡ï¼‰
  let processedFile = file;
  if (file.type.startsWith('image/')) {
    processedFile = await compressImage(file);
  }
  
  // 4. åˆ›å»º FormData
  const formData = new FormData();
  formData.append('file', processedFile);
  formData.append('filename', file.name);
  
  // 5. ä¸Šä¼ 
  const token = localStorage.getItem('token');
  const response = await fetch('/api/upload', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${token}`,
    },
    body: formData,
  });
  
  if (!response.ok) {
    throw new Error('ä¸Šä¼ å¤±è´¥');
  }
  
  const result = await response.json();
  
  // 6. ä¿å­˜æ–‡ä»¶ä¿¡æ¯åˆ°æ•°æ®åº“
  await saveFileInfo(result);
  
  return result;
};

// é—®é¢˜ï¼š
// 1. ä½¿ç”¨æ–¹éœ€è¦çŸ¥é“æ‰€æœ‰ç»†èŠ‚ï¼ˆå‹ç¼©ã€éªŒè¯ã€ä¸Šä¼ ã€ä¿å­˜ï¼‰
// 2. ä»£ç å¤æ‚ï¼Œå®¹æ˜“å‡ºé”™
// 3. æ— æ³•å¤ç”¨
```

#### åœºæ™¯ä¸‰ï¼šè¡¨å•å¤„ç†å¤æ‚

```tsx
// âŒ å™©æ¢¦ä»£ç ï¼šè¡¨å•å¤„ç†éœ€è¦å†™å¾ˆå¤šä»£ç 

const handleSubmit = async () => {
  // 1. éªŒè¯è¡¨å•
  const errors = validateForm(formData);
  if (errors.length > 0) {
    setFormErrors(errors);
    return;
  }
  
  // 2. æ˜¾ç¤º Loading
  setLoading(true);
  
  try {
    // 3. æäº¤æ•°æ®
    const response = await fetch('/api/users', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${localStorage.getItem('token')}`,
      },
      body: JSON.stringify(formData),
    });
    
    if (!response.ok) {
      throw new Error('æäº¤å¤±è´¥');
    }
    
    const result = await response.json();
    
    // 4. æ˜¾ç¤ºæˆåŠŸæç¤º
    message.success('æäº¤æˆåŠŸ');
    
    // 5. é‡ç½®è¡¨å•
    setFormData(initialData);
    form.resetFields();
    
    // 6. åˆ·æ–°åˆ—è¡¨
    refetch();
    
  } catch (error) {
    // 7. æ˜¾ç¤ºé”™è¯¯æç¤º
    message.error(error.message);
  } finally {
    // 8. éšè— Loading
    setLoading(false);
  }
};

// é—®é¢˜ï¼š
// 1. æ¯ä¸ªè¡¨å•éƒ½è¦å†™ä¸€éè¿™äº›é€»è¾‘
// 2. ä»£ç é‡å¤ï¼Œéš¾ä»¥ç»´æŠ¤
// 3. å®¹æ˜“é—æ¼æŸä¸ªæ­¥éª¤
```

**è¿™äº›ä»£ç æœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿ**

| é—®é¢˜ | æè¿° |
|------|------|
| ğŸ”´ **ä½¿ç”¨å¤æ‚** | éœ€è¦çŸ¥é“å¾ˆå¤šå®ç°ç»†èŠ‚ |
| ğŸ”´ **ä»£ç é‡å¤** | ç›¸åŒçš„é€»è¾‘é‡å¤å†™ |
| ğŸ”´ **éš¾ä»¥ç»´æŠ¤** | æ”¹ä¸€ä¸ªåœ°æ–¹è¦æ”¹å¾ˆå¤šåœ°æ–¹ |
| ğŸ”´ **å®¹æ˜“å‡ºé”™** | å®¹æ˜“é—æ¼æŸä¸ªæ­¥éª¤ |

---

### ğŸ’¡ æ¨¡å¼æ ¸å¿ƒæ¦‚å¿µ

å¤–è§‚æ¨¡å¼çš„æ ¸å¿ƒæ€æƒ³æ˜¯ï¼š

> **ä¸ºå¤æ‚çš„å­ç³»ç»Ÿæä¾›ä¸€ä¸ªç»Ÿä¸€çš„æ¥å£ï¼Œéšè—å­ç³»ç»Ÿçš„å¤æ‚æ€§ï¼Œè®©å®¢æˆ·ç«¯æ›´å®¹æ˜“ä½¿ç”¨ã€‚**

ç”¨å¤§ç™½è¯è¯´å°±æ˜¯ï¼š
- **å­ç³»ç»Ÿï¼ˆSubsystemï¼‰**ï¼šå¤æ‚çš„åº•å±‚å®ç°ï¼ˆå¤šä¸ªç±»/æ¨¡å—ï¼‰
- **å¤–è§‚ï¼ˆFacadeï¼‰**ï¼šç»Ÿä¸€çš„æ¥å£ï¼Œå°è£…å­ç³»ç»Ÿçš„å¤æ‚æ€§
- **å®¢æˆ·ç«¯ï¼ˆClientï¼‰**ï¼šé€šè¿‡å¤–è§‚ä½¿ç”¨ç³»ç»Ÿï¼Œä¸éœ€è¦çŸ¥é“å­ç³»ç»Ÿç»†èŠ‚

**å¤–è§‚æ¨¡å¼çš„ç»“æ„ï¼š**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Client    â”‚  â† å®¢æˆ·ç«¯
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ ç®€å•æ¥å£
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Facade    â”‚  â† å¤–è§‚ï¼ˆç»Ÿä¸€æ¥å£ï¼‰
â”‚  (å¤–è§‚)      â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ è°ƒç”¨å­ç³»ç»Ÿ
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Subsystem          â”‚
â”‚  (å­ç³»ç»Ÿ - å¤æ‚å®ç°)      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ClassA  ClassB  ClassC  â”‚
â”‚  â”€â”€â”€â”€    â”€â”€â”€â”€    â”€â”€â”€â”€   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ç±»æ¯”ç†è§£ï¼š**

```
æ²¡æœ‰å¤–è§‚ï¼šä½ è¦è‡ªå·±è°ƒç©ºè°ƒã€å…³ç¯ã€æ‹‰çª—å¸˜ â†’ å¤æ‚ã€å®¹æ˜“å‡ºé”™
æœ‰å¤–è§‚ï¼šä½ åªéœ€è¦è¯´"ç¡è§‰æ¨¡å¼" â†’ ç®€å•ã€ä¸å®¹æ˜“å‡ºé”™
```

---

### ğŸ”§ å‰ç«¯å®æˆ˜æ¡ˆä¾‹ä¸€ï¼šAPI å¤–è§‚å°è£…

#### åœºæ™¯æè¿°

å°è£…å¤æ‚çš„ API è°ƒç”¨é€»è¾‘ï¼Œæä¾›ç®€å•æ˜“ç”¨çš„æ¥å£ã€‚

```tsx
// facade/ApiFacade.ts

/**
 * API å¤–è§‚
 * 
 * å°è£…æ‰€æœ‰ API è°ƒç”¨çš„å¤æ‚é€»è¾‘ï¼Œæä¾›ç®€å•æ˜“ç”¨çš„æ¥å£
 */
export class ApiFacade {
  private baseURL: string;
  private defaultHeaders: Record<string, string>;
  
  constructor(baseURL: string = '/api') {
    this.baseURL = baseURL;
    this.defaultHeaders = {
      'Content-Type': 'application/json',
    };
  }
  
  /**
   * è·å–è¯·æ±‚å¤´
   */
  private getHeaders(customHeaders?: Record<string, string>): Record<string, string> {
    const token = localStorage.getItem('token');
    const headers = {
      ...this.defaultHeaders,
      ...customHeaders,
    };
    
    if (token) {
      headers['Authorization'] = `Bearer ${token}`;
    }
    
    // æ·»åŠ è¯·æ±‚è¿½è¸ªä¿¡æ¯
    headers['X-Request-Id'] = this.generateRequestId();
    headers['X-Timestamp'] = String(Date.now());
    
    return headers;
  }
  
  /**
   * ç”Ÿæˆè¯·æ±‚ ID
   */
  private generateRequestId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  
  /**
   * ç»Ÿä¸€é”™è¯¯å¤„ç†
   */
  private async handleResponse<T>(response: Response): Promise<T> {
    if (!response.ok) {
      let errorMessage = 'è¯·æ±‚å¤±è´¥';
      
      try {
        const error = await response.json();
        errorMessage = error.message || errorMessage;
      } catch {
        errorMessage = `HTTP ${response.status}: ${response.statusText}`;
      }
      
      throw new Error(errorMessage);
    }
    
    // å¤„ç†ç©ºå“åº”
    const contentType = response.headers.get('content-type');
    if (contentType && contentType.includes('application/json')) {
      return response.json();
    }
    
    return response.text() as unknown as T;
  }
  
  /**
   * GET è¯·æ±‚
   */
  async get<T>(url: string, params?: Record<string, any>): Promise<T> {
    const queryString = params
      ? '?' + new URLSearchParams(params).toString()
      : '';
    
    const response = await fetch(`${this.baseURL}${url}${queryString}`, {
      method: 'GET',
      headers: this.getHeaders(),
    });
    
    return this.handleResponse<T>(response);
  }
  
  /**
   * POST è¯·æ±‚
   */
  async post<T>(url: string, data?: any): Promise<T> {
    const response = await fetch(`${this.baseURL}${url}`, {
      method: 'POST',
      headers: this.getHeaders(),
      body: data ? JSON.stringify(data) : undefined,
    });
    
    return this.handleResponse<T>(response);
  }
  
  /**
   * PUT è¯·æ±‚
   */
  async put<T>(url: string, data?: any): Promise<T> {
    const response = await fetch(`${this.baseURL}${url}`, {
      method: 'PUT',
      headers: this.getHeaders(),
      body: data ? JSON.stringify(data) : undefined,
    });
    
    return this.handleResponse<T>(response);
  }
  
  /**
   * DELETE è¯·æ±‚
   */
  async delete<T>(url: string): Promise<T> {
    const response = await fetch(`${this.baseURL}${url}`, {
      method: 'DELETE',
      headers: this.getHeaders(),
    });
    
    return this.handleResponse<T>(response);
  }
  
  /**
   * æ–‡ä»¶ä¸Šä¼ 
   */
  async upload<T>(url: string, file: File, onProgress?: (progress: number) => void): Promise<T> {
    const formData = new FormData();
    formData.append('file', file);
    
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      
      // ä¸Šä¼ è¿›åº¦
      if (onProgress) {
        xhr.upload.addEventListener('progress', (e) => {
          if (e.lengthComputable) {
            const progress = (e.loaded / e.total) * 100;
            onProgress(progress);
          }
        });
      }
      
      xhr.addEventListener('load', () => {
        if (xhr.status >= 200 && xhr.status < 300) {
          try {
            resolve(JSON.parse(xhr.responseText));
          } catch {
            resolve(xhr.responseText as unknown as T);
          }
        } else {
          reject(new Error(`ä¸Šä¼ å¤±è´¥: ${xhr.statusText}`));
        }
      });
      
      xhr.addEventListener('error', () => {
        reject(new Error('ä¸Šä¼ å¤±è´¥'));
      });
      
      xhr.open('POST', `${this.baseURL}${url}`);
      
      // è®¾ç½®è¯·æ±‚å¤´
      const headers = this.getHeaders();
      Object.keys(headers).forEach(key => {
        if (key !== 'Content-Type') {  // FormData ä¼šè‡ªåŠ¨è®¾ç½® Content-Type
          xhr.setRequestHeader(key, headers[key]);
        }
      });
      
      xhr.send(formData);
    });
  }
}

// åˆ›å»ºå•ä¾‹
export const api = new ApiFacade();
```

#### ä¸šåŠ¡ä¸­ä½¿ç”¨

```tsx
// services/userService.ts

import { api } from '../facade/ApiFacade';

interface User {
  id: string;
  name: string;
  email: string;
}

/**
 * ç”¨æˆ·æœåŠ¡
 * 
 * âœ… ä½¿ç”¨ API å¤–è§‚ï¼Œä»£ç ç®€æ´æ¸…æ™°
 */
export const userService = {
  /**
   * è·å–ç”¨æˆ·åˆ—è¡¨
   */
  async getUsers(params?: { page: number; size: number }): Promise<User[]> {
    return api.get<User[]>('/users', params);
  },
  
  /**
   * è·å–ç”¨æˆ·è¯¦æƒ…
   */
  async getUserById(id: string): Promise<User> {
    return api.get<User>(`/users/${id}`);
  },
  
  /**
   * åˆ›å»ºç”¨æˆ·
   */
  async createUser(userData: Omit<User, 'id'>): Promise<User> {
    return api.post<User>('/users', userData);
  },
  
  /**
   * æ›´æ–°ç”¨æˆ·
   */
  async updateUser(id: string, userData: Partial<User>): Promise<User> {
    return api.put<User>(`/users/${id}`, userData);
  },
  
  /**
   * åˆ é™¤ç”¨æˆ·
   */
  async deleteUser(id: string): Promise<void> {
    return api.delete<void>(`/users/${id}`);
  },
};

// ç»„ä»¶ä¸­ä½¿ç”¨
const UserList: React.FC = () => {
  const [users, setUsers] = useState<User[]>([]);
  
  useEffect(() => {
    // âœ… ä½¿ç”¨ç®€å•ï¼Œä¸éœ€è¦çŸ¥é“å†…éƒ¨å®ç°
    userService.getUsers({ page: 1, size: 10 }).then(setUsers);
  }, []);
  
  return (
    <div>
      {users.map(user => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  );
};
```

---

### ğŸ”§ å‰ç«¯å®æˆ˜æ¡ˆä¾‹äºŒï¼šæ–‡ä»¶æ“ä½œå¤–è§‚

#### åœºæ™¯æè¿°

å°è£…æ–‡ä»¶ä¸Šä¼ ã€ä¸‹è½½ã€é¢„è§ˆç­‰å¤æ‚æ“ä½œï¼Œæä¾›ç»Ÿä¸€æ¥å£ã€‚

```tsx
// facade/FileFacade.ts

import { api } from './ApiFacade';

/**
 * æ–‡ä»¶æ“ä½œå¤–è§‚
 * 
 * å°è£…æ–‡ä»¶ä¸Šä¼ ã€ä¸‹è½½ã€é¢„è§ˆç­‰å¤æ‚æ“ä½œ
 */
export class FileFacade {
  private maxSize: number = 10 * 1024 * 1024; // 10MB
  private allowedTypes: string[] = [
    'image/jpeg',
    'image/png',
    'image/gif',
    'application/pdf',
    'application/msword',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  ];
  
  /**
   * éªŒè¯æ–‡ä»¶
   */
  private validateFile(file: File): void {
    // æ£€æŸ¥æ–‡ä»¶å¤§å°
    if (file.size > this.maxSize) {
      throw new Error(`æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡ ${this.maxSize / 1024 / 1024}MB`);
    }
    
    // æ£€æŸ¥æ–‡ä»¶ç±»å‹
    if (!this.allowedTypes.includes(file.type)) {
      throw new Error('ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹');
    }
  }
  
  /**
   * å‹ç¼©å›¾ç‰‡
   */
  private async compressImage(file: File, maxWidth: number = 1920, quality: number = 0.8): Promise<File> {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      
      reader.onload = (e) => {
        const img = new Image();
        
        img.onload = () => {
          const canvas = document.createElement('canvas');
          let width = img.width;
          let height = img.height;
          
          // è®¡ç®—æ–°å°ºå¯¸
          if (width > maxWidth) {
            height = (height * maxWidth) / width;
            width = maxWidth;
          }
          
          canvas.width = width;
          canvas.height = height;
          
          const ctx = canvas.getContext('2d');
          ctx?.drawImage(img, 0, 0, width, height);
          
          canvas.toBlob(
            (blob) => {
              if (blob) {
                const compressedFile = new File([blob], file.name, {
                  type: file.type,
                  lastModified: Date.now(),
                });
                resolve(compressedFile);
              } else {
                reject(new Error('å›¾ç‰‡å‹ç¼©å¤±è´¥'));
              }
            },
            file.type,
            quality
          );
        };
        
        img.onerror = () => reject(new Error('å›¾ç‰‡åŠ è½½å¤±è´¥'));
        img.src = e.target?.result as string;
      };
      
      reader.onerror = () => reject(new Error('æ–‡ä»¶è¯»å–å¤±è´¥'));
      reader.readAsDataURL(file);
    });
  }
  
  /**
   * ä¸Šä¼ æ–‡ä»¶
   * 
   * âœ… ç»Ÿä¸€æ¥å£ï¼Œéšè—æ‰€æœ‰å¤æ‚é€»è¾‘
   */
  async upload(
    file: File,
    options?: {
      compress?: boolean;
      onProgress?: (progress: number) => void;
      folder?: string;
    }
  ): Promise<{ url: string; id: string; filename: string }> {
    // 1. éªŒè¯æ–‡ä»¶
    this.validateFile(file);
    
    // 2. å¤„ç†æ–‡ä»¶ï¼ˆå‹ç¼©ç­‰ï¼‰
    let processedFile = file;
    if (options?.compress && file.type.startsWith('image/')) {
      processedFile = await this.compressImage(file);
    }
    
    // 3. ä¸Šä¼ æ–‡ä»¶
    const uploadUrl = options?.folder ? `/upload?folder=${options.folder}` : '/upload';
    const result = await api.upload<{ url: string; id: string; filename: string }>(
      uploadUrl,
      processedFile,
      options?.onProgress
    );
    
    // 4. ä¿å­˜æ–‡ä»¶ä¿¡æ¯ï¼ˆå¦‚æœéœ€è¦ï¼‰
    if (result.id) {
      await this.saveFileInfo(result);
    }
    
    return result;
  }
  
  /**
   * æ‰¹é‡ä¸Šä¼ 
   */
  async uploadMultiple(
    files: File[],
    options?: {
      compress?: boolean;
      onProgress?: (progress: number) => void;
    }
  ): Promise<Array<{ url: string; id: string; filename: string } | { error: string }>> {
    const results = await Promise.allSettled(
      files.map(file =>
        this.upload(file, options).catch(error => ({ error: error.message }))
      )
    );
    
    return results.map(result =>
      result.status === 'fulfilled' ? result.value : { error: 'ä¸Šä¼ å¤±è´¥' }
    );
  }
  
  /**
   * ä¸‹è½½æ–‡ä»¶
   */
  async download(url: string, filename?: string): Promise<void> {
    const response = await fetch(url);
    const blob = await response.blob();
    
    const downloadUrl = window.URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = downloadUrl;
    link.download = filename || 'download';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    window.URL.revokeObjectURL(downloadUrl);
  }
  
  /**
   * é¢„è§ˆæ–‡ä»¶
   */
  preview(url: string, type: 'image' | 'pdf'): void {
    if (type === 'image') {
      // å›¾ç‰‡é¢„è§ˆï¼šæ‰“å¼€æ–°çª—å£
      window.open(url, '_blank');
    } else if (type === 'pdf') {
      // PDF é¢„è§ˆï¼šä½¿ç”¨ iframe
      const iframe = document.createElement('iframe');
      iframe.src = url;
      iframe.style.width = '100%';
      iframe.style.height = '100vh';
      document.body.appendChild(iframe);
      
      // å¯ä»¥æ·»åŠ å…³é—­æŒ‰é’®ç­‰ UI
    }
  }
  
  /**
   * ä¿å­˜æ–‡ä»¶ä¿¡æ¯åˆ°æ•°æ®åº“
   */
  private async saveFileInfo(fileInfo: { url: string; id: string; filename: string }): Promise<void> {
    try {
      await api.post('/files', fileInfo);
    } catch (error) {
      console.warn('ä¿å­˜æ–‡ä»¶ä¿¡æ¯å¤±è´¥:', error);
    }
  }
}

// åˆ›å»ºå•ä¾‹
export const fileFacade = new FileFacade();
```

#### ä¸šåŠ¡ä¸­ä½¿ç”¨

```tsx
// components/FileUpload.tsx

import React, { useState } from 'react';
import { Upload, Button, Progress, message } from 'antd';
import { fileFacade } from '../facade/FileFacade';

export const FileUpload: React.FC = () => {
  const [uploading, setUploading] = useState(false);
  const [progress, setProgress] = useState(0);
  
  const handleUpload = async (file: File) => {
    setUploading(true);
    setProgress(0);
    
    try {
      // âœ… ä½¿ç”¨ç®€å•ï¼Œä¸éœ€è¦çŸ¥é“å†…éƒ¨å®ç°ï¼ˆéªŒè¯ã€å‹ç¼©ã€ä¸Šä¼ ã€ä¿å­˜ï¼‰
      const result = await fileFacade.upload(file, {
        compress: true,
        onProgress: setProgress,
        folder: 'avatars',
      });
      
      message.success('ä¸Šä¼ æˆåŠŸ');
      console.log('æ–‡ä»¶ URL:', result.url);
    } catch (error) {
      message.error(error.message || 'ä¸Šä¼ å¤±è´¥');
    } finally {
      setUploading(false);
    }
  };
  
  return (
    <div>
      <Upload
        beforeUpload={(file) => {
          handleUpload(file);
          return false; // é˜»æ­¢é»˜è®¤ä¸Šä¼ 
        }}
      >
        <Button loading={uploading}>ä¸Šä¼ æ–‡ä»¶</Button>
      </Upload>
      
      {uploading && <Progress percent={progress} />}
    </div>
  );
};
```

---

### ğŸ”§ å‰ç«¯å®æˆ˜æ¡ˆä¾‹ä¸‰ï¼šè¡¨å•å¤„ç†å¤–è§‚

#### åœºæ™¯æè¿°

å°è£…è¡¨å•éªŒè¯ã€æäº¤ã€é‡ç½®ç­‰å¤æ‚æ“ä½œï¼Œæä¾›ç»Ÿä¸€æ¥å£ã€‚

```tsx
// facade/FormFacade.ts

import { FormInstance } from 'antd/es/form';
import { message } from 'antd';
import { api } from './ApiFacade';

/**
 * è¡¨å•å¤„ç†å¤–è§‚
 * 
 * å°è£…è¡¨å•éªŒè¯ã€æäº¤ã€é‡ç½®ç­‰å¤æ‚æ“ä½œ
 */
export class FormFacade<T extends Record<string, any>> {
  constructor(
    private form: FormInstance,
    private submitUrl: string,
    private initialData?: T
  ) {}
  
  /**
   * éªŒè¯è¡¨å•
   */
  async validate(): Promise<boolean> {
    try {
      await this.form.validateFields();
      return true;
    } catch (error) {
      return false;
    }
  }
  
  /**
   * æäº¤è¡¨å•
   * 
   * âœ… ç»Ÿä¸€æ¥å£ï¼Œéšè—æ‰€æœ‰å¤æ‚é€»è¾‘
   */
  async submit(
    options?: {
      onSuccess?: (data: any) => void;
      onError?: (error: Error) => void;
      showLoading?: boolean;
      showSuccessMessage?: boolean;
      showErrorMessage?: boolean;
      resetAfterSubmit?: boolean;
      refetch?: () => void;
    }
  ): Promise<any> {
    const {
      onSuccess,
      onError,
      showLoading = true,
      showSuccessMessage = true,
      showErrorMessage = true,
      resetAfterSubmit = true,
      refetch,
    } = options || {};
    
    // 1. éªŒè¯è¡¨å•
    const isValid = await this.validate();
    if (!isValid) {
      return;
    }
    
    // 2. è·å–è¡¨å•æ•°æ®
    const formData = this.form.getFieldsValue();
    
    // 3. æ˜¾ç¤º Loadingï¼ˆå¦‚æœéœ€è¦ï¼‰
    let loadingMessage: any = null;
    if (showLoading) {
      loadingMessage = message.loading('æäº¤ä¸­...', 0);
    }
    
    try {
      // 4. æäº¤æ•°æ®
      const result = await api.post(this.submitUrl, formData);
      
      // 5. æ˜¾ç¤ºæˆåŠŸæç¤º
      if (showSuccessMessage) {
        message.success('æäº¤æˆåŠŸ');
      }
      
      // 6. é‡ç½®è¡¨å•ï¼ˆå¦‚æœéœ€è¦ï¼‰
      if (resetAfterSubmit) {
        this.reset();
      }
      
      // 7. åˆ·æ–°æ•°æ®ï¼ˆå¦‚æœéœ€è¦ï¼‰
      if (refetch) {
        refetch();
      }
      
      // 8. è°ƒç”¨æˆåŠŸå›è°ƒ
      if (onSuccess) {
        onSuccess(result);
      }
      
      return result;
    } catch (error) {
      // 9. æ˜¾ç¤ºé”™è¯¯æç¤º
      if (showErrorMessage) {
        message.error((error as Error).message || 'æäº¤å¤±è´¥');
      }
      
      // 10. è°ƒç”¨é”™è¯¯å›è°ƒ
      if (onError) {
        onError(error as Error);
      }
      
      throw error;
    } finally {
      // 11. éšè— Loading
      if (loadingMessage) {
        loadingMessage();
      }
    }
  }
  
  /**
   * é‡ç½®è¡¨å•
   */
  reset(): void {
    this.form.resetFields();
    if (this.initialData) {
      this.form.setFieldsValue(this.initialData);
    }
  }
  
  /**
   * è®¾ç½®è¡¨å•å€¼
   */
  setValues(values: Partial<T>): void {
    this.form.setFieldsValue(values);
  }
  
  /**
   * è·å–è¡¨å•å€¼
   */
  getValues(): T {
    return this.form.getFieldsValue() as T;
  }
  
  /**
   * è®¾ç½®å­—æ®µé”™è¯¯
   */
  setFieldError(field: string, error: string): void {
    this.form.setFields([
      {
        name: field,
        errors: [error],
      },
    ]);
  }
  
  /**
   * æ¸…é™¤å­—æ®µé”™è¯¯
   */
  clearFieldError(field: string): void {
    this.form.setFields([
      {
        name: field,
        errors: [],
      },
    ]);
  }
}
```

#### ä¸šåŠ¡ä¸­ä½¿ç”¨

```tsx
// components/UserForm.tsx

import React from 'react';
import { Form, Input, Button } from 'antd';
import { FormFacade } from '../facade/FormFacade';

interface UserFormData {
  name: string;
  email: string;
}

export const UserForm: React.FC<{ onSuccess?: () => void }> = ({ onSuccess }) => {
  const [form] = Form.useForm();
  
  // âœ… åˆ›å»ºè¡¨å•å¤–è§‚
  const formFacade = new FormFacade<UserFormData>(
    form,
    '/users',
    { name: '', email: '' }
  );
  
  const handleSubmit = async () => {
    // âœ… ä½¿ç”¨ç®€å•ï¼Œä¸éœ€è¦çŸ¥é“å†…éƒ¨å®ç°
    await formFacade.submit({
      onSuccess: (data) => {
        console.log('æäº¤æˆåŠŸ:', data);
        onSuccess?.();
      },
      refetch: () => {
        // åˆ·æ–°ç”¨æˆ·åˆ—è¡¨
        console.log('åˆ·æ–°åˆ—è¡¨');
      },
    });
  };
  
  return (
    <Form form={form}>
      <Form.Item name="name" label="å§“å" rules={[{ required: true }]}>
        <Input />
      </Form.Item>
      
      <Form.Item name="email" label="é‚®ç®±" rules={[{ required: true, type: 'email' }]}>
        <Input />
      </Form.Item>
      
      <Form.Item>
        <Button type="primary" onClick={handleSubmit}>
          æäº¤
        </Button>
        <Button onClick={() => formFacade.reset()}>
          é‡ç½®
        </Button>
      </Form.Item>
    </Form>
  );
};
```

---

### ğŸ”§ å‰ç«¯å®æˆ˜æ¡ˆä¾‹å››ï¼šçŠ¶æ€ç®¡ç†å¤–è§‚

#### åœºæ™¯æè¿°

å°è£… Redux/Zustand ç­‰çŠ¶æ€ç®¡ç†çš„å¤æ‚æ“ä½œï¼Œæä¾›ç®€å•æ¥å£ã€‚

```tsx
// facade/StoreFacade.ts

import { create } from 'zustand';

/**
 * çŠ¶æ€ç®¡ç†å¤–è§‚
 * 
 * å°è£…çŠ¶æ€ç®¡ç†çš„å¤æ‚æ“ä½œï¼Œæä¾›ç®€å•æ¥å£
 */
export class StoreFacade<T extends Record<string, any>> {
  private store: any;
  
  constructor(initialState: T) {
    // ä½¿ç”¨ Zustand åˆ›å»º storeï¼ˆä¹Ÿå¯ä»¥ä½¿ç”¨ Reduxï¼‰
    this.store = create<T & {
      setState: (partial: Partial<T>) => void;
      reset: () => void;
      getState: () => T;
    }>((set, get) => ({
      ...initialState,
      setState: (partial: Partial<T>) => set(partial as any),
      reset: () => set(initialState as any),
      getState: () => {
        const state = get();
        const { setState, reset, getState, ...rest } = state as any;
        return rest as T;
      },
    }));
  }
  
  /**
   * è·å–çŠ¶æ€
   */
  useStore(): T {
    return this.store();
  }
  
  /**
   * è·å–çŠ¶æ€å€¼ï¼ˆHookï¼‰
   */
  useValue<K extends keyof T>(key: K): T[K] {
    return this.store((state: T) => state[key]);
  }
  
  /**
   * è®¾ç½®çŠ¶æ€
   */
  setState(partial: Partial<T>): void {
    this.store.getState().setState(partial);
  }
  
  /**
   * é‡ç½®çŠ¶æ€
   */
  reset(): void {
    this.store.getState().reset();
  }
  
  /**
   * è·å–å½“å‰çŠ¶æ€ï¼ˆé Hookï¼‰
   */
  getState(): T {
    return this.store.getState().getState();
  }
  
  /**
   * è®¢é˜…çŠ¶æ€å˜åŒ–
   */
  subscribe(listener: (state: T) => void): () => void {
    return this.store.subscribe(listener);
  }
}

// ä½¿ç”¨ç¤ºä¾‹ï¼šç”¨æˆ·çŠ¶æ€ç®¡ç†
interface UserState {
  user: { id: string; name: string } | null;
  loading: boolean;
  error: string | null;
}

export const userStore = new StoreFacade<UserState>({
  user: null,
  loading: false,
  error: null,
});

// ç”¨æˆ·æ“ä½œå°è£…
export const userActions = {
  setUser: (user: UserState['user']) => {
    userStore.setState({ user });
  },
  
  setLoading: (loading: boolean) => {
    userStore.setState({ loading });
  },
  
  setError: (error: string | null) => {
    userStore.setState({ error });
  },
  
  fetchUser: async (id: string) => {
    userActions.setLoading(true);
    userActions.setError(null);
    
    try {
      const user = await api.get(`/users/${id}`);
      userActions.setUser(user);
    } catch (error) {
      userActions.setError((error as Error).message);
    } finally {
      userActions.setLoading(false);
    }
  },
  
  reset: () => {
    userStore.reset();
  },
};
```

#### ä¸šåŠ¡ä¸­ä½¿ç”¨

```tsx
// components/UserProfile.tsx

import React, { useEffect } from 'react';
import { Spin, Alert } from 'antd';
import { userStore, userActions } from '../facade/StoreFacade';

export const UserProfile: React.FC<{ userId: string }> = ({ userId }) => {
  // âœ… ä½¿ç”¨ç®€å•ï¼Œä¸éœ€è¦çŸ¥é“ Zustand çš„ç»†èŠ‚
  const user = userStore.useValue('user');
  const loading = userStore.useValue('loading');
  const error = userStore.useValue('error');
  
  useEffect(() => {
    // âœ… ä½¿ç”¨å°è£…çš„ action
    userActions.fetchUser(userId);
  }, [userId]);
  
  if (loading) {
    return <Spin />;
  }
  
  if (error) {
    return <Alert message={error} type="error" />;
  }
  
  if (!user) {
    return <div>ç”¨æˆ·ä¸å­˜åœ¨</div>;
  }
  
  return <div>ç”¨æˆ·ï¼š{user.name}</div>;
};
```

---

### ğŸ“Š æ¨¡å¼æ€»ç»“

#### âœ… ä¼˜ç‚¹

| ä¼˜ç‚¹ | è¯´æ˜ |
|------|------|
| **ç®€åŒ–ä½¿ç”¨** | éšè—å¤æ‚å®ç°ï¼Œæä¾›ç®€å•æ¥å£ |
| **é™ä½è€¦åˆ** | å®¢æˆ·ç«¯ä¸ä¾èµ–å­ç³»ç»Ÿå®ç° |
| **æ˜“äºç»´æŠ¤** | ä¿®æ”¹å­ç³»ç»Ÿä¸å½±å“å®¢æˆ·ç«¯ |
| **ç»Ÿä¸€æ¥å£** | å¤šä¸ªå­ç³»ç»Ÿæä¾›ç»Ÿä¸€æ¥å£ |
| **æ˜“äºæµ‹è¯•** | å¯ä»¥ Mock å¤–è§‚è¿›è¡Œæµ‹è¯• |

#### âŒ ç¼ºç‚¹

| ç¼ºç‚¹ | è¯´æ˜ |
|------|------|
| **å¯èƒ½è¿‡åº¦å°è£…** | ç®€å•åœºæ™¯ä¸‹å¯èƒ½æ˜¾å¾—å¤šä½™ |
| **æ€§èƒ½è€ƒè™‘** | å¤šä¸€å±‚å°è£…å¯èƒ½æœ‰æ€§èƒ½å¼€é”€ |
| **çµæ´»æ€§é™ä½** | å¤–è§‚å¯èƒ½æ— æ³•è¦†ç›–æ‰€æœ‰åœºæ™¯ |

#### ğŸ¯ é€‚ç”¨åœºæ™¯

| åœºæ™¯ | ç¤ºä¾‹ |
|------|------|
| **API å°è£…** | ç»Ÿä¸€å¤šä¸ª API è°ƒç”¨çš„å¤æ‚é€»è¾‘ |
| **æ–‡ä»¶æ“ä½œ** | å°è£…æ–‡ä»¶ä¸Šä¼ /ä¸‹è½½/é¢„è§ˆ |
| **è¡¨å•å¤„ç†** | å°è£…è¡¨å•éªŒè¯/æäº¤/é‡ç½® |
| **çŠ¶æ€ç®¡ç†** | å°è£… Redux/Zustand çš„å¤æ‚æ“ä½œ |
| **ç¬¬ä¸‰æ–¹åº“å°è£…** | ç®€åŒ–ç¬¬ä¸‰æ–¹åº“çš„ä½¿ç”¨ |

#### ğŸš« ä¸é€‚ç”¨åœºæ™¯

- å­ç³»ç»Ÿå¾ˆç®€å•ï¼Œä¸éœ€è¦å°è£…
- éœ€è¦ç›´æ¥è®¿é—®å­ç³»ç»Ÿçš„æ‰€æœ‰åŠŸèƒ½
- æ€§èƒ½è¦æ±‚æé«˜ï¼Œå°è£…å¼€é”€ä¸å¯æ¥å—

---

### ğŸ”„ ä¸å…¶ä»–æ¨¡å¼çš„åŒºåˆ«

| æ¨¡å¼ | å…³æ³¨ç‚¹ | åŒºåˆ« |
|------|--------|------|
| **å¤–è§‚æ¨¡å¼** | ç®€åŒ–æ¥å£ | ä¸ºå¤æ‚ç³»ç»Ÿæä¾›ç®€å•æ¥å£ |
| **é€‚é…å™¨æ¨¡å¼** | æ¥å£è½¬æ¢ | è®©ä¸å…¼å®¹çš„æ¥å£å¯ä»¥ä¸€èµ·å·¥ä½œ |
| **ä»£ç†æ¨¡å¼** | è®¿é—®æ§åˆ¶ | æ§åˆ¶å¯¹å¯¹è±¡çš„è®¿é—® |
| **é—¨é¢æ¨¡å¼** | ç»Ÿä¸€å…¥å£ | å¤–è§‚æ¨¡å¼çš„å¦ä¸€ç§å«æ³• |

---

### ğŸ¤” é€‰æ‹©å»ºè®®ï¼šä»€ä¹ˆæ—¶å€™ç”¨å¤–è§‚æ¨¡å¼ï¼Ÿ

é—®è‡ªå·±è¿™å‡ ä¸ªé—®é¢˜ï¼š

```
1. ä½ çš„ç³»ç»Ÿæ˜¯å¦å¾ˆå¤æ‚ï¼Œä½¿ç”¨èµ·æ¥å›°éš¾ï¼Ÿ
   â†’ æ˜¯çš„è¯ï¼Œè€ƒè™‘å¤–è§‚æ¨¡å¼

2. ä½ æ˜¯å¦éœ€è¦éšè—ç³»ç»Ÿçš„å¤æ‚æ€§ï¼Ÿ
   â†’ æ˜¯çš„è¯ï¼Œè€ƒè™‘å¤–è§‚æ¨¡å¼

3. ä½ çš„å®¢æˆ·ç«¯æ˜¯å¦éœ€è¦çŸ¥é“ç³»ç»Ÿçš„å®ç°ç»†èŠ‚ï¼Ÿ
   â†’ å¦‚æœä¸éœ€è¦ï¼Œè€ƒè™‘å¤–è§‚æ¨¡å¼

4. ä½ æ˜¯å¦éœ€è¦ä¸ºå¤šä¸ªå­ç³»ç»Ÿæä¾›ç»Ÿä¸€æ¥å£ï¼Ÿ
   â†’ æ˜¯çš„è¯ï¼Œè€ƒè™‘å¤–è§‚æ¨¡å¼

5. ä½ çš„ç³»ç»Ÿæ˜¯å¦ä¼šé¢‘ç¹å˜åŒ–ï¼Ÿ
   â†’ å¦‚æœæ˜¯ï¼Œè€ƒè™‘å¤–è§‚æ¨¡å¼ï¼ˆéš”ç¦»å˜åŒ–ï¼‰
```

---

### ğŸ“ æ–‡ä»¶ç»“æ„å‚è€ƒ

```
src/
â”œâ”€â”€ facade/
â”‚   â”œâ”€â”€ ApiFacade.ts                # API å¤–è§‚
â”‚   â”œâ”€â”€ FileFacade.ts               # æ–‡ä»¶æ“ä½œå¤–è§‚
â”‚   â”œâ”€â”€ FormFacade.ts               # è¡¨å•å¤„ç†å¤–è§‚
â”‚   â””â”€â”€ StoreFacade.ts              # çŠ¶æ€ç®¡ç†å¤–è§‚
â”œâ”€â”€ services/
â”‚   â””â”€â”€ userService.ts             # ä½¿ç”¨ API å¤–è§‚çš„æœåŠ¡
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ FileUpload.tsx             # ä½¿ç”¨æ–‡ä»¶å¤–è§‚çš„ç»„ä»¶
â”‚   â”œâ”€â”€ UserForm.tsx               # ä½¿ç”¨è¡¨å•å¤–è§‚çš„ç»„ä»¶
â”‚   â””â”€â”€ UserProfile.tsx            # ä½¿ç”¨çŠ¶æ€ç®¡ç†å¤–è§‚çš„ç»„ä»¶
â””â”€â”€ stores/
    â””â”€â”€ userStore.ts               # ä½¿ç”¨çŠ¶æ€ç®¡ç†å¤–è§‚çš„ store
```

---

> **ä¸‹ä¸€ç« é¢„å‘Šï¼šã€Šä»£ç†æ¨¡å¼ã€‹â€”â€” æ§åˆ¶è®¿é—®çš„"é—¨å«"**
> 
> æˆ‘ä»¬å°†è®²è§£å¦‚ä½•é€šè¿‡ä»£ç†æ¨¡å¼æ§åˆ¶å¯¹è±¡è®¿é—®ã€å®ç°ç¼“å­˜ä»£ç†ã€è™šæ‹Ÿä»£ç†ç­‰ã€‚

---

*å¦‚æœ‰ç–‘é—®æˆ–å»ºè®®ï¼Œæ¬¢è¿äº¤æµï¼*

