# ã€Šå‰ç«¯è®¾è®¡æ¨¡å¼å®æˆ˜æ‰‹å†Œã€‹

## ç¬¬ä¸ƒç« ï¼šæ¡¥æ¥æ¨¡å¼ï¼ˆBridge Patternï¼‰

---

### ğŸ¯ ä¸€å¥è¯å¤§ç™½è¯

> **æ¡¥æ¥æ¨¡å¼å°±åƒé¥æ§å™¨å’Œç”µè§†çš„å…³ç³»ï¼šé¥æ§å™¨ï¼ˆæŠ½è±¡ï¼‰è´Ÿè´£"æŒ‰ä»€ä¹ˆæŒ‰é’®"ï¼Œç”µè§†ï¼ˆå®ç°ï¼‰è´Ÿè´£"æ€ä¹ˆæ˜¾ç¤ºç”»é¢"ã€‚ä½ å¯ä»¥ç”¨åŒä¸€ä¸ªé¥æ§å™¨æ§åˆ¶ä¸åŒå“ç‰Œçš„ç”µè§†ï¼Œä¹Ÿå¯ä»¥ç»™åŒä¸€å°ç”µè§†é…ä¸åŒçš„é¥æ§å™¨ã€‚å®ƒä»¬å„è‡ªç‹¬ç«‹å˜åŒ–ï¼Œäº’ä¸å½±å“ã€‚**

**æ ¸å¿ƒç†å¿µï¼šå°†æŠ½è±¡ä¸å®ç°åˆ†ç¦»ï¼Œä½¿å®ƒä»¬å¯ä»¥ç‹¬ç«‹å˜åŒ–ã€‚**

---

### ğŸ¤” ä»€ä¹ˆæ—¶å€™éœ€è¦"æ¡¥æ¥"ï¼Ÿ

åœ¨å‰ç«¯å¼€å‘ä¸­ï¼Œç»å¸¸ä¼šé‡åˆ°"æŠ½è±¡"å’Œ"å®ç°"éœ€è¦ç‹¬ç«‹å˜åŒ–çš„åœºæ™¯ï¼š

| åœºæ™¯ | ä¸ºä»€ä¹ˆéœ€è¦æ¡¥æ¥ |
|------|----------------|
| **UI ç»„ä»¶ä¸æ¸²æŸ“å¼•æ“** | ç»„ä»¶é€»è¾‘ï¼ˆæŠ½è±¡ï¼‰å’Œæ¸²æŸ“æ–¹å¼ï¼ˆå®ç°ï¼‰åˆ†ç¦» |
| **å¤šå¹³å°é€‚é…** | åŒä¸€å¥—ä¸šåŠ¡é€»è¾‘é€‚é…ä¸åŒå¹³å°ï¼ˆWeb/iOS/Androidï¼‰ |
| **ä¸»é¢˜ç³»ç»Ÿ** | ç»„ä»¶åŠŸèƒ½ï¼ˆæŠ½è±¡ï¼‰å’Œæ ·å¼ä¸»é¢˜ï¼ˆå®ç°ï¼‰åˆ†ç¦» |
| **æ•°æ®æºåˆ‡æ¢** | ä¸šåŠ¡é€»è¾‘ï¼ˆæŠ½è±¡ï¼‰å’Œæ•°æ®æºï¼ˆå®ç°ï¼‰åˆ†ç¦» |
| **é€šçŸ¥ç³»ç»Ÿ** | é€šçŸ¥ç±»å‹ï¼ˆæŠ½è±¡ï¼‰å’Œå‘é€æ–¹å¼ï¼ˆå®ç°ï¼‰åˆ†ç¦» |
| **å­˜å‚¨ç³»ç»Ÿ** | æ•°æ®æ“ä½œï¼ˆæŠ½è±¡ï¼‰å’Œå­˜å‚¨æ–¹å¼ï¼ˆå®ç°ï¼‰åˆ†ç¦» |

---

### ğŸ˜« å‰ç«¯ç—›ç‚¹ï¼šæ²¡æœ‰æ¡¥æ¥æ—¶çš„å™©æ¢¦

#### åœºæ™¯ä¸€ï¼šç»„ä»¶ä¸æ ·å¼è€¦åˆ

```tsx
// âŒ å™©æ¢¦ä»£ç ï¼šç»„ä»¶å’Œæ ·å¼å¼ºè€¦åˆ

// Button ç»„ä»¶
const Button: React.FC<{ variant: 'primary' | 'secondary' }> = ({ variant, children }) => {
  // æ ·å¼ç›´æ¥å†™åœ¨ç»„ä»¶é‡Œ
  const styles = variant === 'primary' 
    ? { backgroundColor: '#1890ff', color: '#fff' }
    : { backgroundColor: '#f0f0f0', color: '#333' };
  
  return <button style={styles}>{children}</button>;
};

// é—®é¢˜ï¼š
// 1. è¦æ¢ä¸»é¢˜ï¼Ÿæ”¹ç»„ä»¶ä»£ç 
// 2. è¦æ”¯æŒæ–°æ ·å¼ï¼Ÿæ”¹ç»„ä»¶ä»£ç 
// 3. ç»„ä»¶å’Œæ ·å¼æ— æ³•ç‹¬ç«‹å˜åŒ–
```

#### åœºæ™¯äºŒï¼šå¤šå¹³å°ä»£ç é‡å¤

```tsx
// âŒ å™©æ¢¦ä»£ç ï¼šæ¯ä¸ªå¹³å°éƒ½è¦å†™ä¸€éé€»è¾‘

// Web ç‰ˆæœ¬
const WebUserList: React.FC = () => {
  const [users, setUsers] = useState([]);
  
  useEffect(() => {
    fetch('/api/users').then(res => res.json()).then(setUsers);
  }, []);
  
  return (
    <div>
      {users.map(user => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  );
};

// ç§»åŠ¨ç«¯ç‰ˆæœ¬ - é€»è¾‘å‡ ä¹ä¸€æ ·ï¼Œåªæ˜¯æ¸²æŸ“ä¸åŒ
const MobileUserList: React.FC = () => {
  const [users, setUsers] = useState([]);
  
  useEffect(() => {
    fetch('/api/users').then(res => res.json()).then(setUsers);
  }, []);
  
  return (
    <FlatList
      data={users}
      renderItem={({ item }) => <Text>{item.name}</Text>}
    />
  );
};

// é—®é¢˜ï¼š
// 1. ä¸šåŠ¡é€»è¾‘é‡å¤
// 2. æ”¹é€»è¾‘è¦æ”¹ä¸¤ä¸ªåœ°æ–¹
// 3. æ— æ³•å¤ç”¨
```

#### åœºæ™¯ä¸‰ï¼šæ•°æ®æºåˆ‡æ¢å›°éš¾

```tsx
// âŒ å™©æ¢¦ä»£ç ï¼šæ•°æ®æºåˆ‡æ¢è¦æ”¹å¾ˆå¤šåœ°æ–¹

// ä½¿ç”¨ REST API
const UserService = {
  async getUsers() {
    const res = await fetch('/api/users');
    return res.json();
  },
};

// ç»„ä»¶ä¸­ä½¿ç”¨
const UserList: React.FC = () => {
  const [users, setUsers] = useState([]);
  
  useEffect(() => {
    UserService.getUsers().then(setUsers);
  }, []);
  
  // ...
};

// å¦‚æœè¦åˆ‡æ¢åˆ° GraphQLï¼Ÿ
// 1. æ”¹ UserService
// 2. æ”¹æ‰€æœ‰è°ƒç”¨ UserService çš„åœ°æ–¹
// 3. ä¸šåŠ¡é€»è¾‘å’Œæ•°æ®è·å–è€¦åˆåœ¨ä¸€èµ·
```

**è¿™äº›ä»£ç æœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿ**

| é—®é¢˜ | æè¿° |
|------|------|
| ğŸ”´ **å¼ºè€¦åˆ** | æŠ½è±¡å’Œå®ç°è€¦åˆåœ¨ä¸€èµ·ï¼Œæ— æ³•ç‹¬ç«‹å˜åŒ– |
| ğŸ”´ **ä»£ç é‡å¤** | ä¸åŒå®ç°éœ€è¦é‡å¤å†™ä¸šåŠ¡é€»è¾‘ |
| ğŸ”´ **éš¾ä»¥æ‰©å±•** | æ·»åŠ æ–°å®ç°éœ€è¦ä¿®æ”¹ç°æœ‰ä»£ç  |
| ğŸ”´ **è¿åå¼€é—­åŸåˆ™** | å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­ |

---

### ğŸ’¡ æ¨¡å¼æ ¸å¿ƒæ¦‚å¿µ

æ¡¥æ¥æ¨¡å¼çš„æ ¸å¿ƒæ€æƒ³æ˜¯ï¼š

> **å°†æŠ½è±¡ä¸å®ç°åˆ†ç¦»ï¼Œä½¿å®ƒä»¬å¯ä»¥ç‹¬ç«‹å˜åŒ–ã€‚**

ç”¨å¤§ç™½è¯è¯´å°±æ˜¯ï¼š
- **æŠ½è±¡ï¼ˆAbstractionï¼‰**ï¼šå®šä¹‰"åšä»€ä¹ˆ"ï¼ˆä¸šåŠ¡é€»è¾‘ã€æ¥å£ï¼‰
- **å®ç°ï¼ˆImplementorï¼‰**ï¼šå®šä¹‰"æ€ä¹ˆåš"ï¼ˆå…·ä½“å®ç°ã€å¹³å°ç›¸å…³ï¼‰
- **æ¡¥æ¥ï¼ˆBridgeï¼‰**ï¼šè¿æ¥æŠ½è±¡å’Œå®ç°ï¼Œè®©å®ƒä»¬å¯ä»¥ç‹¬ç«‹å˜åŒ–

**æ¡¥æ¥æ¨¡å¼çš„ç»“æ„ï¼š**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Abstraction   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚  Implementor    â”‚
â”‚   (æŠ½è±¡)         â”‚         â”‚  (å®ç°æ¥å£)      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ + operation()   â”‚         â”‚ + implement()   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                           â–²
         â”‚                           â”‚
         â”‚                           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚RefinedAbstractionâ”‚         â”‚ConcreteImplementâ”‚
â”‚  (å…·ä½“æŠ½è±¡)      â”‚         â”‚  (å…·ä½“å®ç°)      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ + operation()   â”‚         â”‚ + implement()   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ç±»æ¯”ç†è§£ï¼š**

```
æ²¡æœ‰æ¡¥æ¥ï¼šé¥æ§å™¨å’Œç”µè§†ç„Šåœ¨ä¸€èµ· â†’ æ¢ç”µè§†è¦æ¢é¥æ§å™¨
æœ‰æ¡¥æ¥ï¼šé¥æ§å™¨é€šè¿‡ä¿¡å·è¿æ¥ç”µè§† â†’ å¯ä»¥éšæ„ç»„åˆ
```

---

### ğŸ”§ å‰ç«¯å®æˆ˜æ¡ˆä¾‹ä¸€ï¼šä¸»é¢˜ç³»ç»Ÿæ¡¥æ¥

#### åœºæ™¯æè¿°

å°†ç»„ä»¶çš„åŠŸèƒ½é€»è¾‘ï¼ˆæŠ½è±¡ï¼‰å’Œæ ·å¼ä¸»é¢˜ï¼ˆå®ç°ï¼‰åˆ†ç¦»ï¼Œæ”¯æŒåŠ¨æ€åˆ‡æ¢ä¸»é¢˜ã€‚

```tsx
// bridge/ThemeImplementor.ts

/**
 * ä¸»é¢˜å®ç°æ¥å£ï¼ˆImplementorï¼‰
 * 
 * å®šä¹‰"å¦‚ä½•æ¸²æŸ“æ ·å¼"
 */
export interface ThemeImplementor {
  getButtonStyles(variant: 'primary' | 'secondary'): React.CSSProperties;
  getInputStyles(): React.CSSProperties;
  getCardStyles(): React.CSSProperties;
  getTextColor(): string;
  getBackgroundColor(): string;
}

/**
 * é»˜è®¤ä¸»é¢˜å®ç°ï¼ˆConcrete Implementorï¼‰
 */
export class LightTheme implements ThemeImplementor {
  getButtonStyles(variant: 'primary' | 'secondary'): React.CSSProperties {
    return variant === 'primary'
      ? {
          backgroundColor: '#1890ff',
          color: '#fff',
          border: 'none',
          borderRadius: '6px',
          padding: '8px 16px',
          cursor: 'pointer',
        }
      : {
          backgroundColor: '#f0f0f0',
          color: '#333',
          border: '1px solid #d9d9d9',
          borderRadius: '6px',
          padding: '8px 16px',
          cursor: 'pointer',
        };
  }
  
  getInputStyles(): React.CSSProperties {
    return {
      backgroundColor: '#fff',
      color: '#333',
      border: '1px solid #d9d9d9',
      borderRadius: '6px',
      padding: '8px 12px',
    };
  }
  
  getCardStyles(): React.CSSProperties {
    return {
      backgroundColor: '#fff',
      borderRadius: '8px',
      boxShadow: '0 2px 8px rgba(0, 0, 0, 0.1)',
      padding: '24px',
    };
  }
  
  getTextColor(): string {
    return '#333';
  }
  
  getBackgroundColor(): string {
    return '#f5f5f5';
  }
}

/**
 * æš—é»‘ä¸»é¢˜å®ç°ï¼ˆConcrete Implementorï¼‰
 */
export class DarkTheme implements ThemeImplementor {
  getButtonStyles(variant: 'primary' | 'secondary'): React.CSSProperties {
    return variant === 'primary'
      ? {
          backgroundColor: '#177ddc',
          color: '#fff',
          border: 'none',
          borderRadius: '6px',
          padding: '8px 16px',
          cursor: 'pointer',
        }
      : {
          backgroundColor: '#303030',
          color: '#fff',
          border: '1px solid #434343',
          borderRadius: '6px',
          padding: '8px 16px',
          cursor: 'pointer',
        };
  }
  
  getInputStyles(): React.CSSProperties {
    return {
      backgroundColor: '#1f1f1f',
      color: '#fff',
      border: '1px solid #434343',
      borderRadius: '6px',
      padding: '8px 12px',
    };
  }
  
  getCardStyles(): React.CSSProperties {
    return {
      backgroundColor: '#1f1f1f',
      borderRadius: '8px',
      border: '1px solid #303030',
      padding: '24px',
    };
  }
  
  getTextColor(): string {
    return '#d9d9d9';
  }
  
  getBackgroundColor(): string {
    return '#141414';
  }
}
```

```tsx
// bridge/ThemedComponent.tsx

import React, { createContext, useContext } from 'react';
import { ThemeImplementor, LightTheme } from './ThemeImplementor';

/**
 * ä¸»é¢˜ä¸Šä¸‹æ–‡
 */
const ThemeContext = createContext<ThemeImplementor>(new LightTheme());

export const ThemeProvider: React.FC<{
  theme: ThemeImplementor;
  children: React.ReactNode;
}> = ({ theme, children }) => {
  return (
    <ThemeContext.Provider value={theme}>
      {children}
    </ThemeContext.Provider>
  );
};

export const useTheme = () => useContext(ThemeContext);

/**
 * ä¸»é¢˜åŒ–æŒ‰é’®ï¼ˆAbstractionï¼‰
 * 
 * å®šä¹‰"åšä»€ä¹ˆ"ï¼ˆæŒ‰é’®çš„åŠŸèƒ½ï¼‰ï¼Œä¸å…³å¿ƒ"æ€ä¹ˆåš"ï¼ˆæ ·å¼ï¼‰
 */
export const ThemedButton: React.FC<{
  variant?: 'primary' | 'secondary';
  onClick?: () => void;
  children: React.ReactNode;
}> = ({ variant = 'primary', onClick, children }) => {
  const theme = useTheme();
  
  // âœ… é€šè¿‡æ¡¥æ¥è·å–æ ·å¼ï¼Œç»„ä»¶ä¸å…³å¿ƒå…·ä½“ä¸»é¢˜
  const styles = theme.getButtonStyles(variant);
  
  return (
    <button style={styles} onClick={onClick}>
      {children}
    </button>
  );
};

/**
 * ä¸»é¢˜åŒ–è¾“å…¥æ¡†ï¼ˆAbstractionï¼‰
 */
export const ThemedInput: React.FC<{
  value?: string;
  onChange?: (value: string) => void;
  placeholder?: string;
}> = ({ value, onChange, placeholder }) => {
  const theme = useTheme();
  const styles = theme.getInputStyles();
  
  return (
    <input
      style={styles}
      value={value}
      onChange={(e) => onChange?.(e.target.value)}
      placeholder={placeholder}
    />
  );
};

/**
 * ä¸»é¢˜åŒ–å¡ç‰‡ï¼ˆAbstractionï¼‰
 */
export const ThemedCard: React.FC<{
  children: React.ReactNode;
}> = ({ children }) => {
  const theme = useTheme();
  const styles = theme.getCardStyles();
  
  return <div style={styles}>{children}</div>;
};
```

#### ä¸šåŠ¡ä¸­ä½¿ç”¨

```tsx
// pages/UserForm.tsx

import React, { useState } from 'react';
import { ThemeProvider } from '../bridge/ThemedComponent';
import { LightTheme, DarkTheme } from '../bridge/ThemeImplementor';
import { ThemedButton, ThemedInput, ThemedCard } from '../bridge/ThemedComponent';

export const UserFormPage: React.FC = () => {
  const [theme, setTheme] = useState<LightTheme | DarkTheme>(new LightTheme());
  const [formData, setFormData] = useState({ name: '', email: '' });
  
  const toggleTheme = () => {
    setTheme(theme instanceof LightTheme ? new DarkTheme() : new LightTheme());
  };
  
  return (
    <ThemeProvider theme={theme}>
      <div style={{
        backgroundColor: theme.getBackgroundColor(),
        minHeight: '100vh',
        padding: '24px',
      }}>
        <ThemedButton onClick={toggleTheme}>
          åˆ‡æ¢ä¸»é¢˜
        </ThemedButton>
        
        <ThemedCard>
          <ThemedInput
            value={formData.name}
            onChange={(value) => setFormData({ ...formData, name: value })}
            placeholder="å§“å"
          />
          <ThemedInput
            value={formData.email}
            onChange={(value) => setFormData({ ...formData, email: value })}
            placeholder="é‚®ç®±"
          />
          <ThemedButton variant="primary" onClick={() => console.log(formData)}>
            æäº¤
          </ThemedButton>
        </ThemedCard>
      </div>
    </ThemeProvider>
  );
};
```

---

### ğŸ”§ å‰ç«¯å®æˆ˜æ¡ˆä¾‹äºŒï¼šæ•°æ®æºæ¡¥æ¥

#### åœºæ™¯æè¿°

å°†ä¸šåŠ¡é€»è¾‘ï¼ˆæŠ½è±¡ï¼‰å’Œæ•°æ®è·å–æ–¹å¼ï¼ˆå®ç°ï¼‰åˆ†ç¦»ï¼Œæ”¯æŒåˆ‡æ¢ä¸åŒçš„æ•°æ®æºã€‚

```tsx
// bridge/DataSourceImplementor.ts

/**
 * æ•°æ®æºå®ç°æ¥å£ï¼ˆImplementorï¼‰
 * 
 * å®šä¹‰"å¦‚ä½•è·å–æ•°æ®"
 */
export interface DataSourceImplementor {
  getUsers(): Promise<User[]>;
  getUserById(id: string): Promise<User | null>;
  createUser(user: Omit<User, 'id'>): Promise<User>;
  updateUser(id: string, user: Partial<User>): Promise<User>;
  deleteUser(id: string): Promise<void>;
}

interface User {
  id: string;
  name: string;
  email: string;
}

/**
 * REST API æ•°æ®æºå®ç°ï¼ˆConcrete Implementorï¼‰
 */
export class RestApiDataSource implements DataSourceImplementor {
  private baseURL: string;
  
  constructor(baseURL: string = '/api') {
    this.baseURL = baseURL;
  }
  
  async getUsers(): Promise<User[]> {
    const response = await fetch(`${this.baseURL}/users`);
    const data = await response.json();
    return data.items || data;
  }
  
  async getUserById(id: string): Promise<User | null> {
    const response = await fetch(`${this.baseURL}/users/${id}`);
    if (!response.ok) return null;
    return response.json();
  }
  
  async createUser(user: Omit<User, 'id'>): Promise<User> {
    const response = await fetch(`${this.baseURL}/users`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(user),
    });
    return response.json();
  }
  
  async updateUser(id: string, user: Partial<User>): Promise<User> {
    const response = await fetch(`${this.baseURL}/users/${id}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(user),
    });
    return response.json();
  }
  
  async deleteUser(id: string): Promise<void> {
    await fetch(`${this.baseURL}/users/${id}`, {
      method: 'DELETE',
    });
  }
}

/**
 * GraphQL æ•°æ®æºå®ç°ï¼ˆConcrete Implementorï¼‰
 */
export class GraphQLDataSource implements DataSourceImplementor {
  private endpoint: string;
  
  constructor(endpoint: string = '/graphql') {
    this.endpoint = endpoint;
  }
  
  private async query(query: string, variables?: any): Promise<any> {
    const response = await fetch(this.endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query, variables }),
    });
    const { data } = await response.json();
    return data;
  }
  
  async getUsers(): Promise<User[]> {
    const data = await this.query(`
      query {
        users {
          id
          name
          email
        }
      }
    `);
    return data.users;
  }
  
  async getUserById(id: string): Promise<User | null> {
    const data = await this.query(`
      query($id: ID!) {
        user(id: $id) {
          id
          name
          email
        }
      }
    `, { id });
    return data.user;
  }
  
  async createUser(user: Omit<User, 'id'>): Promise<User> {
    const data = await this.query(`
      mutation($name: String!, $email: String!) {
        createUser(name: $name, email: $email) {
          id
          name
          email
        }
      }
    `, user);
    return data.createUser;
  }
  
  async updateUser(id: string, user: Partial<User>): Promise<User> {
    const data = await this.query(`
      mutation($id: ID!, $name: String, $email: String) {
        updateUser(id: $id, name: $name, email: $email) {
          id
          name
          email
        }
      }
    `, { id, ...user });
    return data.updateUser;
  }
  
  async deleteUser(id: string): Promise<void> {
    await this.query(`
      mutation($id: ID!) {
        deleteUser(id: $id)
      }
    `, { id });
  }
}

/**
 * æœ¬åœ°å­˜å‚¨æ•°æ®æºå®ç°ï¼ˆConcrete Implementorï¼‰
 */
export class LocalStorageDataSource implements DataSourceImplementor {
  private storageKey = 'users';
  
  private getUsersFromStorage(): User[] {
    const data = localStorage.getItem(this.storageKey);
    return data ? JSON.parse(data) : [];
  }
  
  private saveUsersToStorage(users: User[]): void {
    localStorage.setItem(this.storageKey, JSON.stringify(users));
  }
  
  async getUsers(): Promise<User[]> {
    return this.getUsersFromStorage();
  }
  
  async getUserById(id: string): Promise<User | null> {
    const users = this.getUsersFromStorage();
    return users.find(u => u.id === id) || null;
  }
  
  async createUser(user: Omit<User, 'id'>): Promise<User> {
    const users = this.getUsersFromStorage();
    const newUser: User = {
      id: `user_${Date.now()}`,
      ...user,
    };
    users.push(newUser);
    this.saveUsersToStorage(users);
    return newUser;
  }
  
  async updateUser(id: string, user: Partial<User>): Promise<User> {
    const users = this.getUsersFromStorage();
    const index = users.findIndex(u => u.id === id);
    if (index === -1) throw new Error('User not found');
    
    users[index] = { ...users[index], ...user };
    this.saveUsersToStorage(users);
    return users[index];
  }
  
  async deleteUser(id: string): Promise<void> {
    const users = this.getUsersFromStorage();
    const filtered = users.filter(u => u.id !== id);
    this.saveUsersToStorage(filtered);
  }
}
```

```tsx
// bridge/UserService.ts

import { DataSourceImplementor } from './DataSourceImplementor';

/**
 * ç”¨æˆ·æœåŠ¡ï¼ˆAbstractionï¼‰
 * 
 * å®šä¹‰"åšä»€ä¹ˆ"ï¼ˆä¸šåŠ¡é€»è¾‘ï¼‰ï¼Œä¸å…³å¿ƒ"æ€ä¹ˆåš"ï¼ˆæ•°æ®è·å–ï¼‰
 */
export class UserService {
  constructor(private dataSource: DataSourceImplementor) {}
  
  /**
   * è·å–æ‰€æœ‰ç”¨æˆ·
   */
  async getAllUsers(): Promise<User[]> {
    return this.dataSource.getUsers();
  }
  
  /**
   * æ ¹æ® ID è·å–ç”¨æˆ·
   */
  async getUserById(id: string): Promise<User | null> {
    return this.dataSource.getUserById(id);
  }
  
  /**
   * åˆ›å»ºç”¨æˆ·
   */
  async createUser(name: string, email: string): Promise<User> {
    return this.dataSource.createUser({ name, email });
  }
  
  /**
   * æ›´æ–°ç”¨æˆ·
   */
  async updateUser(id: string, updates: { name?: string; email?: string }): Promise<User> {
    return this.dataSource.updateUser(id, updates);
  }
  
  /**
   * åˆ é™¤ç”¨æˆ·
   */
  async deleteUser(id: string): Promise<void> {
    return this.dataSource.deleteUser(id);
  }
  
  /**
   * æœç´¢ç”¨æˆ·ï¼ˆä¸šåŠ¡é€»è¾‘ï¼Œä¸ä¾èµ–å…·ä½“æ•°æ®æºï¼‰
   */
  async searchUsers(keyword: string): Promise<User[]> {
    const allUsers = await this.getAllUsers();
    return allUsers.filter(user =>
      user.name.toLowerCase().includes(keyword.toLowerCase()) ||
      user.email.toLowerCase().includes(keyword.toLowerCase())
    );
  }
}

interface User {
  id: string;
  name: string;
  email: string;
}
```

#### ä¸šåŠ¡ä¸­ä½¿ç”¨

```tsx
// components/UserList.tsx

import React, { useState, useEffect } from 'react';
import { Table, Button, message } from 'antd';
import { UserService } from '../bridge/UserService';
import { RestApiDataSource, GraphQLDataSource, LocalStorageDataSource } from '../bridge/DataSourceImplementor';

export const UserList: React.FC = () => {
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(false);
  
  // âœ… å¯ä»¥è½»æ¾åˆ‡æ¢æ•°æ®æºï¼Œä¸šåŠ¡é€»è¾‘ä¸å˜
  const [dataSourceType, setDataSourceType] = useState<'rest' | 'graphql' | 'local'>('rest');
  
  // æ ¹æ®ç±»å‹åˆ›å»ºå¯¹åº”çš„æ•°æ®æº
  const getDataSource = () => {
    switch (dataSourceType) {
      case 'rest':
        return new RestApiDataSource();
      case 'graphql':
        return new GraphQLDataSource();
      case 'local':
        return new LocalStorageDataSource();
    }
  };
  
  // åˆ›å»ºç”¨æˆ·æœåŠ¡ï¼ˆæ¡¥æ¥ï¼‰
  const userService = new UserService(getDataSource());
  
  const fetchUsers = async () => {
    setLoading(true);
    try {
      const data = await userService.getAllUsers();
      setUsers(data);
    } catch (error) {
      message.error('åŠ è½½å¤±è´¥');
    } finally {
      setLoading(false);
    }
  };
  
  useEffect(() => {
    fetchUsers();
  }, [dataSourceType]);  // åˆ‡æ¢æ•°æ®æºæ—¶é‡æ–°åŠ è½½
  
  const handleDelete = async (id: string) => {
    try {
      await userService.deleteUser(id);
      message.success('åˆ é™¤æˆåŠŸ');
      fetchUsers();
    } catch (error) {
      message.error('åˆ é™¤å¤±è´¥');
    }
  };
  
  return (
    <div>
      <div style={{ marginBottom: 16 }}>
        <Button onClick={() => setDataSourceType('rest')}>REST API</Button>
        <Button onClick={() => setDataSourceType('graphql')}>GraphQL</Button>
        <Button onClick={() => setDataSourceType('local')}>LocalStorage</Button>
      </div>
      
      <Table
        dataSource={users}
        loading={loading}
        columns={[
          { title: 'ID', dataIndex: 'id' },
          { title: 'å§“å', dataIndex: 'name' },
          { title: 'é‚®ç®±', dataIndex: 'email' },
          {
            title: 'æ“ä½œ',
            render: (_, record) => (
              <Button onClick={() => handleDelete(record.id)}>åˆ é™¤</Button>
            ),
          },
        ]}
      />
    </div>
  );
};
```

---

### ğŸ”§ å‰ç«¯å®æˆ˜æ¡ˆä¾‹ä¸‰ï¼šé€šçŸ¥ç³»ç»Ÿæ¡¥æ¥

#### åœºæ™¯æè¿°

å°†é€šçŸ¥ç±»å‹ï¼ˆæŠ½è±¡ï¼‰å’Œå‘é€æ–¹å¼ï¼ˆå®ç°ï¼‰åˆ†ç¦»ï¼Œæ”¯æŒå¤šç§é€šçŸ¥æ¸ é“ã€‚

```tsx
// bridge/NotificationImplementor.ts

/**
 * é€šçŸ¥å®ç°æ¥å£ï¼ˆImplementorï¼‰
 * 
 * å®šä¹‰"å¦‚ä½•å‘é€é€šçŸ¥"
 */
export interface NotificationImplementor {
  send(title: string, message: string, options?: any): Promise<void>;
}

/**
 * é‚®ä»¶é€šçŸ¥å®ç°ï¼ˆConcrete Implementorï¼‰
 */
export class EmailNotification implements NotificationImplementor {
  async send(title: string, message: string, options?: { to: string }): Promise<void> {
    // è°ƒç”¨é‚®ä»¶æœåŠ¡ API
    await fetch('/api/notifications/email', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        to: options?.to,
        subject: title,
        body: message,
      }),
    });
    console.log(`é‚®ä»¶å·²å‘é€: ${title}`);
  }
}

/**
 * çŸ­ä¿¡é€šçŸ¥å®ç°ï¼ˆConcrete Implementorï¼‰
 */
export class SmsNotification implements NotificationImplementor {
  async send(title: string, message: string, options?: { phone: string }): Promise<void> {
    // è°ƒç”¨çŸ­ä¿¡æœåŠ¡ API
    await fetch('/api/notifications/sms', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        phone: options?.phone,
        message: `${title}: ${message}`,
      }),
    });
    console.log(`çŸ­ä¿¡å·²å‘é€: ${title}`);
  }
}

/**
 * æ¨é€é€šçŸ¥å®ç°ï¼ˆConcrete Implementorï¼‰
 */
export class PushNotification implements NotificationImplementor {
  async send(title: string, message: string, options?: { userId: string }): Promise<void> {
    // è°ƒç”¨æ¨é€æœåŠ¡ API
    await fetch('/api/notifications/push', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        userId: options?.userId,
        title,
        body: message,
      }),
    });
    console.log(`æ¨é€å·²å‘é€: ${title}`);
  }
}

/**
 * ç«™å†…ä¿¡é€šçŸ¥å®ç°ï¼ˆConcrete Implementorï¼‰
 */
export class InAppNotification implements NotificationImplementor {
  async send(title: string, message: string, options?: { userId: string }): Promise<void> {
    // ä¿å­˜åˆ°æ•°æ®åº“
    await fetch('/api/notifications/in-app', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        userId: options?.userId,
        title,
        message,
        read: false,
      }),
    });
    console.log(`ç«™å†…ä¿¡å·²å‘é€: ${title}`);
  }
}
```

```tsx
// bridge/Notification.ts

import { NotificationImplementor } from './NotificationImplementor';

/**
 * é€šçŸ¥æŠ½è±¡ç±»ï¼ˆAbstractionï¼‰
 * 
 * å®šä¹‰"åšä»€ä¹ˆ"ï¼ˆé€šçŸ¥ç±»å‹å’Œä¸šåŠ¡é€»è¾‘ï¼‰ï¼Œä¸å…³å¿ƒ"æ€ä¹ˆåš"ï¼ˆå‘é€æ–¹å¼ï¼‰
 */
export abstract class Notification {
  constructor(protected implementor: NotificationImplementor) {}
  
  /**
   * å‘é€é€šçŸ¥ï¼ˆæ¨¡æ¿æ–¹æ³•ï¼‰
   */
  abstract send(options?: any): Promise<void>;
  
  /**
   * æ ¼å¼åŒ–æ ‡é¢˜
   */
  protected abstract getTitle(): string;
  
  /**
   * æ ¼å¼åŒ–æ¶ˆæ¯
   */
  protected abstract getMessage(): string;
}

/**
 * è®¢å•é€šçŸ¥ï¼ˆRefined Abstractionï¼‰
 */
export class OrderNotification extends Notification {
  constructor(
    implementor: NotificationImplementor,
    private orderId: string,
    private status: 'created' | 'paid' | 'shipped' | 'completed'
  ) {
    super(implementor);
  }
  
  protected getTitle(): string {
    return `è®¢å• ${this.orderId}`;
  }
  
  protected getMessage(): string {
    const statusMap = {
      created: 'æ‚¨çš„è®¢å•å·²åˆ›å»º',
      paid: 'æ‚¨çš„è®¢å•å·²æ”¯ä»˜',
      shipped: 'æ‚¨çš„è®¢å•å·²å‘è´§',
      completed: 'æ‚¨çš„è®¢å•å·²å®Œæˆ',
    };
    return statusMap[this.status];
  }
  
  async send(options?: any): Promise<void> {
    await this.implementor.send(this.getTitle(), this.getMessage(), options);
  }
}

/**
 * ç³»ç»Ÿé€šçŸ¥ï¼ˆRefined Abstractionï¼‰
 */
export class SystemNotification extends Notification {
  constructor(
    implementor: NotificationImplementor,
    private type: 'warning' | 'error' | 'info',
    private content: string
  ) {
    super(implementor);
  }
  
  protected getTitle(): string {
    const titleMap = {
      warning: 'âš ï¸ è­¦å‘Š',
      error: 'âŒ é”™è¯¯',
      info: 'â„¹ï¸ æç¤º',
    };
    return titleMap[this.type];
  }
  
  protected getMessage(): string {
    return this.content;
  }
  
  async send(options?: any): Promise<void> {
    await this.implementor.send(this.getTitle(), this.getMessage(), options);
  }
}
```

#### ä¸šåŠ¡ä¸­ä½¿ç”¨

```tsx
// services/notificationService.ts

import {
  OrderNotification,
  SystemNotification,
} from '../bridge/Notification';
import {
  EmailNotification,
  SmsNotification,
  PushNotification,
  InAppNotification,
} from '../bridge/NotificationImplementor';

/**
 * é€šçŸ¥æœåŠ¡
 * 
 * å¯ä»¥çµæ´»ç»„åˆé€šçŸ¥ç±»å‹å’Œå‘é€æ–¹å¼
 */
export class NotificationService {
  /**
   * å‘é€è®¢å•é€šçŸ¥ï¼ˆå¯ä»¥é€šè¿‡ä¸åŒæ¸ é“ï¼‰
   */
  static async notifyOrderStatus(
    orderId: string,
    status: 'created' | 'paid' | 'shipped' | 'completed',
    channels: ('email' | 'sms' | 'push' | 'in-app')[],
    options?: { email?: string; phone?: string; userId?: string }
  ) {
    const notification = new OrderNotification(
      new EmailNotification(),  // é»˜è®¤å®ç°ï¼Œä¼šè¢«æ›¿æ¢
      orderId,
      status
    );
    
    // âœ… å¯ä»¥åŒæ—¶é€šè¿‡å¤šä¸ªæ¸ é“å‘é€
    const promises = channels.map(channel => {
      let implementor: NotificationImplementor;
      
      switch (channel) {
        case 'email':
          implementor = new EmailNotification();
          break;
        case 'sms':
          implementor = new SmsNotification();
          break;
        case 'push':
          implementor = new PushNotification();
          break;
        case 'in-app':
          implementor = new InAppNotification();
          break;
      }
      
      const notif = new OrderNotification(implementor, orderId, status);
      return notif.send(options);
    });
    
    await Promise.all(promises);
  }
  
  /**
   * å‘é€ç³»ç»Ÿé€šçŸ¥
   */
  static async notifySystem(
    type: 'warning' | 'error' | 'info',
    content: string,
    implementor: NotificationImplementor,
    options?: any
  ) {
    const notification = new SystemNotification(implementor, type, content);
    await notification.send(options);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
// è®¢å•åˆ›å»ºæ—¶ï¼Œé€šè¿‡é‚®ä»¶å’Œç«™å†…ä¿¡é€šçŸ¥
await NotificationService.notifyOrderStatus(
  'ORDER_123',
  'created',
  ['email', 'in-app'],
  { email: 'user@example.com', userId: 'user_123' }
);

// ç³»ç»Ÿé”™è¯¯æ—¶ï¼Œé€šè¿‡æ¨é€é€šçŸ¥
await NotificationService.notifySystem(
  'error',
  'æœåŠ¡å™¨å¼‚å¸¸ï¼Œè¯·ç¨åé‡è¯•',
  new PushNotification(),
  { userId: 'user_123' }
);
```

---

### ğŸ”§ å‰ç«¯å®æˆ˜æ¡ˆä¾‹å››ï¼šå­˜å‚¨ç³»ç»Ÿæ¡¥æ¥

#### åœºæ™¯æè¿°

å°†æ•°æ®æ“ä½œï¼ˆæŠ½è±¡ï¼‰å’Œå­˜å‚¨æ–¹å¼ï¼ˆå®ç°ï¼‰åˆ†ç¦»ï¼Œæ”¯æŒåˆ‡æ¢ä¸åŒçš„å­˜å‚¨åç«¯ã€‚

```tsx
// bridge/StorageImplementor.ts

/**
 * å­˜å‚¨å®ç°æ¥å£ï¼ˆImplementorï¼‰
 * 
 * å®šä¹‰"å¦‚ä½•å­˜å‚¨æ•°æ®"
 */
export interface StorageImplementor {
  get<T>(key: string): Promise<T | null>;
  set<T>(key: string, value: T): Promise<void>;
  remove(key: string): Promise<void>;
  clear(): Promise<void>;
  keys(): Promise<string[]>;
}

/**
 * LocalStorage å®ç°ï¼ˆConcrete Implementorï¼‰
 */
export class LocalStorageImpl implements StorageImplementor {
  async get<T>(key: string): Promise<T | null> {
    const item = localStorage.getItem(key);
    return item ? JSON.parse(item) : null;
  }
  
  async set<T>(key: string, value: T): Promise<void> {
    localStorage.setItem(key, JSON.stringify(value));
  }
  
  async remove(key: string): Promise<void> {
    localStorage.removeItem(key);
  }
  
  async clear(): Promise<void> {
    localStorage.clear();
  }
  
  async keys(): Promise<string[]> {
    return Object.keys(localStorage);
  }
}

/**
 * IndexedDB å®ç°ï¼ˆConcrete Implementorï¼‰
 */
export class IndexedDBImpl implements StorageImplementor {
  private dbName: string;
  private storeName: string;
  private db: IDBDatabase | null = null;
  
  constructor(dbName: string = 'app-db', storeName: string = 'data') {
    this.dbName = dbName;
    this.storeName = storeName;
    this.init();
  }
  
  private async init(): Promise<void> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, 1);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };
      
      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;
        if (!db.objectStoreNames.contains(this.storeName)) {
          db.createObjectStore(this.storeName);
        }
      };
    });
  }
  
  async get<T>(key: string): Promise<T | null> {
    if (!this.db) await this.init();
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction([this.storeName], 'readonly');
      const store = transaction.objectStore(this.storeName);
      const request = store.get(key);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        resolve(request.result || null);
      };
    });
  }
  
  async set<T>(key: string, value: T): Promise<void> {
    if (!this.db) await this.init();
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction([this.storeName], 'readwrite');
      const store = transaction.objectStore(this.storeName);
      const request = store.put(value, key);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve();
    });
  }
  
  async remove(key: string): Promise<void> {
    if (!this.db) await this.init();
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction([this.storeName], 'readwrite');
      const store = transaction.objectStore(this.storeName);
      const request = store.delete(key);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve();
    });
  }
  
  async clear(): Promise<void> {
    if (!this.db) await this.init();
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction([this.storeName], 'readwrite');
      const store = transaction.objectStore(this.storeName);
      const request = store.clear();
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve();
    });
  }
  
  async keys(): Promise<string[]> {
    if (!this.db) await this.init();
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction([this.storeName], 'readonly');
      const store = transaction.objectStore(this.storeName);
      const request = store.getAllKeys();
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        resolve(request.result as string[]);
      };
    });
  }
}

/**
 * è¿œç¨‹å­˜å‚¨å®ç°ï¼ˆConcrete Implementorï¼‰
 */
export class RemoteStorageImpl implements StorageImplementor {
  private baseURL: string;
  
  constructor(baseURL: string = '/api/storage') {
    this.baseURL = baseURL;
  }
  
  async get<T>(key: string): Promise<T | null> {
    const response = await fetch(`${this.baseURL}/${key}`);
    if (!response.ok) return null;
    return response.json();
  }
  
  async set<T>(key: string, value: T): Promise<void> {
    await fetch(`${this.baseURL}/${key}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(value),
    });
  }
  
  async remove(key: string): Promise<void> {
    await fetch(`${this.baseURL}/${key}`, {
      method: 'DELETE',
    });
  }
  
  async clear(): Promise<void> {
    await fetch(`${this.baseURL}`, {
      method: 'DELETE',
    });
  }
  
  async keys(): Promise<string[]> {
    const response = await fetch(this.baseURL);
    const data = await response.json();
    return data.keys || [];
  }
}
```

```tsx
// bridge/StorageService.ts

import { StorageImplementor } from './StorageImplementor';

/**
 * å­˜å‚¨æœåŠ¡ï¼ˆAbstractionï¼‰
 * 
 * å®šä¹‰"åšä»€ä¹ˆ"ï¼ˆæ•°æ®æ“ä½œï¼‰ï¼Œä¸å…³å¿ƒ"æ€ä¹ˆåš"ï¼ˆå­˜å‚¨æ–¹å¼ï¼‰
 */
export class StorageService {
  constructor(private implementor: StorageImplementor) {}
  
  /**
   * è·å–æ•°æ®
   */
  async get<T>(key: string): Promise<T | null> {
    return this.implementor.get<T>(key);
  }
  
  /**
   * è®¾ç½®æ•°æ®
   */
  async set<T>(key: string, value: T): Promise<void> {
    return this.implementor.set(key, value);
  }
  
  /**
   * åˆ é™¤æ•°æ®
   */
  async remove(key: string): Promise<void> {
    return this.implementor.remove(key);
  }
  
  /**
   * æ¸…ç©ºæ‰€æœ‰æ•°æ®
   */
  async clear(): Promise<void> {
    return this.implementor.clear();
  }
  
  /**
   * è·å–æ‰€æœ‰é”®
   */
  async keys(): Promise<string[]> {
    return this.implementor.keys();
  }
  
  /**
   * æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨
   */
  async has(key: string): Promise<boolean> {
    const keys = await this.keys();
    return keys.includes(key);
  }
  
  /**
   * æ‰¹é‡è·å–
   */
  async getMany<T>(keys: string[]): Promise<Map<string, T>> {
    const results = new Map<string, T>();
    await Promise.all(
      keys.map(async (key) => {
        const value = await this.get<T>(key);
        if (value !== null) {
          results.set(key, value);
        }
      })
    );
    return results;
  }
  
  /**
   * æ‰¹é‡è®¾ç½®
   */
  async setMany<T>(data: Map<string, T>): Promise<void> {
    await Promise.all(
      Array.from(data.entries()).map(([key, value]) =>
        this.set(key, value)
      )
    );
  }
}
```

#### ä¸šåŠ¡ä¸­ä½¿ç”¨

```tsx
// components/Settings.tsx

import React, { useState, useEffect } from 'react';
import { Select, Button } from 'antd';
import { StorageService } from '../bridge/StorageService';
import {
  LocalStorageImpl,
  IndexedDBImpl,
  RemoteStorageImpl,
} from '../bridge/StorageImplementor';

export const Settings: React.FC = () => {
  const [storageType, setStorageType] = useState<'local' | 'indexeddb' | 'remote'>('local');
  const [storageService, setStorageService] = useState<StorageService>(
    new StorageService(new LocalStorageImpl())
  );
  
  useEffect(() => {
    // âœ… åˆ‡æ¢å­˜å‚¨æ–¹å¼ï¼Œä¸šåŠ¡é€»è¾‘ä¸å˜
    let implementor: StorageImplementor;
    
    switch (storageType) {
      case 'local':
        implementor = new LocalStorageImpl();
        break;
      case 'indexeddb':
        implementor = new IndexedDBImpl();
        break;
      case 'remote':
        implementor = new RemoteStorageImpl();
        break;
    }
    
    setStorageService(new StorageService(implementor));
  }, [storageType]);
  
  const handleSave = async () => {
    const settings = {
      theme: 'dark',
      language: 'zh-CN',
    };
    
    // âœ… ä½¿ç”¨ç»Ÿä¸€çš„æ¥å£ï¼Œä¸å…³å¿ƒåº•å±‚å­˜å‚¨æ–¹å¼
    await storageService.set('settings', settings);
    console.log('è®¾ç½®å·²ä¿å­˜');
  };
  
  const handleLoad = async () => {
    // âœ… ä½¿ç”¨ç»Ÿä¸€çš„æ¥å£è¯»å–
    const settings = await storageService.get('settings');
    console.log('è®¾ç½®:', settings);
  };
  
  return (
    <div>
      <Select
        value={storageType}
        onChange={setStorageType}
        style={{ width: 200, marginBottom: 16 }}
      >
        <Select.Option value="local">LocalStorage</Select.Option>
        <Select.Option value="indexeddb">IndexedDB</Select.Option>
        <Select.Option value="remote">è¿œç¨‹å­˜å‚¨</Select.Option>
      </Select>
      
      <div>
        <Button onClick={handleSave}>ä¿å­˜è®¾ç½®</Button>
        <Button onClick={handleLoad}>åŠ è½½è®¾ç½®</Button>
      </div>
    </div>
  );
};
```

---

### ğŸ“Š æ¨¡å¼æ€»ç»“

#### âœ… ä¼˜ç‚¹

| ä¼˜ç‚¹ | è¯´æ˜ |
|------|------|
| **è§£è€¦** | æŠ½è±¡å’Œå®ç°åˆ†ç¦»ï¼Œå¯ä»¥ç‹¬ç«‹å˜åŒ– |
| **çµæ´»ç»„åˆ** | å¯ä»¥åŠ¨æ€ç»„åˆä¸åŒçš„æŠ½è±¡å’Œå®ç° |
| **æ˜“äºæ‰©å±•** | æ·»åŠ æ–°çš„å®ç°æˆ–æŠ½è±¡éƒ½å¾ˆå®¹æ˜“ |
| **ç¬¦åˆå¼€é—­åŸåˆ™** | å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­ |
| **éšè—å®ç°ç»†èŠ‚** | å®¢æˆ·ç«¯ä¸éœ€è¦çŸ¥é“å…·ä½“å®ç° |

#### âŒ ç¼ºç‚¹

| ç¼ºç‚¹ | è¯´æ˜ |
|------|------|
| **å¢åŠ å¤æ‚åº¦** | å¤šäº†ä¸€å±‚æŠ½è±¡ï¼Œä»£ç é‡å¢åŠ  |
| **ç†è§£æˆæœ¬** | éœ€è¦ç†è§£æŠ½è±¡å’Œå®ç°çš„å…³ç³» |
| **æ€§èƒ½å¼€é”€** | å¤šä¸€å±‚è°ƒç”¨ï¼Œæœ‰è½»å¾®æ€§èƒ½å¼€é”€ |

#### ğŸ¯ é€‚ç”¨åœºæ™¯

| åœºæ™¯ | ç¤ºä¾‹ |
|------|------|
| **ä¸»é¢˜ç³»ç»Ÿ** | ç»„ä»¶åŠŸèƒ½å’Œæ ·å¼åˆ†ç¦» |
| **å¤šå¹³å°é€‚é…** | ä¸šåŠ¡é€»è¾‘å’Œå¹³å°å®ç°åˆ†ç¦» |
| **æ•°æ®æºåˆ‡æ¢** | ä¸šåŠ¡é€»è¾‘å’Œæ•°æ®è·å–åˆ†ç¦» |
| **é€šçŸ¥ç³»ç»Ÿ** | é€šçŸ¥ç±»å‹å’Œå‘é€æ–¹å¼åˆ†ç¦» |
| **å­˜å‚¨ç³»ç»Ÿ** | æ•°æ®æ“ä½œå’Œå­˜å‚¨æ–¹å¼åˆ†ç¦» |

#### ğŸš« ä¸é€‚ç”¨åœºæ™¯

- æŠ½è±¡å’Œå®ç°ä¸ä¼šç‹¬ç«‹å˜åŒ–
- ç®€å•çš„åœºæ™¯ï¼Œä¸éœ€è¦è¿™ä¹ˆå¤æ‚çš„ç»“æ„
- æ€§èƒ½è¦æ±‚æé«˜çš„åœºæ™¯

---

### ğŸ”„ ä¸å…¶ä»–æ¨¡å¼çš„åŒºåˆ«

| æ¨¡å¼ | å…³æ³¨ç‚¹ | åŒºåˆ« |
|------|--------|------|
| **æ¡¥æ¥æ¨¡å¼** | æŠ½è±¡ä¸å®ç°åˆ†ç¦» | è®©æŠ½è±¡å’Œå®ç°å¯ä»¥ç‹¬ç«‹å˜åŒ– |
| **é€‚é…å™¨æ¨¡å¼** | æ¥å£è½¬æ¢ | è®©ä¸å…¼å®¹çš„æ¥å£å¯ä»¥ä¸€èµ·å·¥ä½œ |
| **ç­–ç•¥æ¨¡å¼** | ç®—æ³•é€‰æ‹© | å°è£…ç®—æ³•ï¼Œå¯ä»¥åŠ¨æ€åˆ‡æ¢ |
| **è£…é¥°å™¨æ¨¡å¼** | åŠŸèƒ½å¢å¼º | åŠ¨æ€æ·»åŠ åŠŸèƒ½ |

---

### ğŸ¤” é€‰æ‹©å»ºè®®ï¼šä»€ä¹ˆæ—¶å€™ç”¨æ¡¥æ¥æ¨¡å¼ï¼Ÿ

é—®è‡ªå·±è¿™å‡ ä¸ªé—®é¢˜ï¼š

```
1. ä½ çš„ä»£ç æ˜¯å¦æœ‰ä¸¤ä¸ªç»´åº¦éœ€è¦ç‹¬ç«‹å˜åŒ–ï¼Ÿ
   â†’ æ˜¯çš„è¯ï¼Œè€ƒè™‘æ¡¥æ¥æ¨¡å¼

2. æŠ½è±¡å’Œå®ç°æ˜¯å¦ä¼šç‹¬ç«‹å˜åŒ–ï¼Ÿ
   â†’ æ˜¯çš„è¯ï¼Œè€ƒè™‘æ¡¥æ¥æ¨¡å¼

3. ä½ æ˜¯å¦éœ€è¦åœ¨è¿è¡Œæ—¶åˆ‡æ¢å®ç°ï¼Ÿ
   â†’ æ˜¯çš„è¯ï¼Œè€ƒè™‘æ¡¥æ¥æ¨¡å¼

4. ä½ æ˜¯å¦éœ€è¦æ”¯æŒå¤šç§ç»„åˆï¼Ÿ
   â†’ æ˜¯çš„è¯ï¼Œè€ƒè™‘æ¡¥æ¥æ¨¡å¼

5. æŠ½è±¡å’Œå®ç°æ˜¯å¦è€¦åˆåœ¨ä¸€èµ·ï¼Ÿ
   â†’ å¦‚æœæ˜¯ï¼Œè€ƒè™‘ç”¨æ¡¥æ¥æ¨¡å¼è§£è€¦
```

---

### ğŸ“ æ–‡ä»¶ç»“æ„å‚è€ƒ

```
src/
â”œâ”€â”€ bridge/
â”‚   â”œâ”€â”€ ThemeImplementor.ts         # ä¸»é¢˜å®ç°æ¥å£
â”‚   â”œâ”€â”€ ThemedComponent.tsx         # ä¸»é¢˜åŒ–ç»„ä»¶
â”‚   â”œâ”€â”€ DataSourceImplementor.ts    # æ•°æ®æºå®ç°æ¥å£
â”‚   â”œâ”€â”€ UserService.ts              # ç”¨æˆ·æœåŠ¡ï¼ˆæŠ½è±¡ï¼‰
â”‚   â”œâ”€â”€ NotificationImplementor.ts  # é€šçŸ¥å®ç°æ¥å£
â”‚   â”œâ”€â”€ Notification.ts             # é€šçŸ¥æŠ½è±¡ç±»
â”‚   â”œâ”€â”€ StorageImplementor.ts       # å­˜å‚¨å®ç°æ¥å£
â”‚   â””â”€â”€ StorageService.ts           # å­˜å‚¨æœåŠ¡ï¼ˆæŠ½è±¡ï¼‰
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ UserList.tsx                # ä½¿ç”¨æ•°æ®æºæ¡¥æ¥
â”‚   â””â”€â”€ Settings.tsx                # ä½¿ç”¨å­˜å‚¨æ¡¥æ¥
â””â”€â”€ services/
    â””â”€â”€ notificationService.ts      # ä½¿ç”¨é€šçŸ¥æ¡¥æ¥
```

---

> **ä¸‹ä¸€ç« é¢„å‘Šï¼šã€Šè£…é¥°å™¨æ¨¡å¼ã€‹â€”â€” ç»™åŠŸèƒ½"åŠ æ–™"çš„æ­£ç¡®å§¿åŠ¿**
> 
> æˆ‘ä»¬å°†è®²è§£å¦‚ä½•é€šè¿‡è£…é¥°å™¨æ¨¡å¼å¢å¼ºç»„ä»¶åŠŸèƒ½ã€æ·»åŠ æƒé™æ§åˆ¶ã€æ—¥å¿—è®°å½•ç­‰ã€‚

---

*å¦‚æœ‰ç–‘é—®æˆ–å»ºè®®ï¼Œæ¬¢è¿äº¤æµï¼*

