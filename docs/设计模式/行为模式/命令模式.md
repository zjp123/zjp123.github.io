# å‘½ä»¤æ¨¡å¼ï¼ˆCommand Patternï¼‰

> ã€Šå‰ç«¯è®¾è®¡æ¨¡å¼å®æˆ˜æ‰‹å†Œã€‹ç³»åˆ— - ç¬¬ä¸ƒç« 

---

## ä¸€å¥è¯å¤§ç™½è¯

**å°±åƒé¤å…ç‚¹é¤**ï¼šä½ ä¸ç›´æ¥è·‘åˆ°å¨æˆ¿è·Ÿå¨å¸ˆè¯´"ç»™æˆ‘åšä¸ªå®«ä¿é¸¡ä¸"ï¼Œè€Œæ˜¯æŠŠéœ€æ±‚å†™åœ¨ç‚¹èœå•ä¸Šï¼ŒæœåŠ¡å‘˜æŠŠç‚¹èœå•äº¤ç»™å¨æˆ¿ã€‚ç‚¹èœå•å°±æ˜¯å‘½ä»¤å¯¹è±¡ï¼Œä¸Šé¢è®°å½•äº†"åšä»€ä¹ˆèœ"ã€"å‡ ä»½"ã€"ä»€ä¹ˆæ—¶å€™åš"ï¼Œè¿˜èƒ½æ’¤å•ã€ä¿®æ”¹ã€‚

## å‰ç«¯ç—›ç‚¹

æƒ³è±¡ä¸€ä¸‹ï¼Œä½ åœ¨åšä¸€ä¸ªå›¾å½¢ç¼–è¾‘å™¨ï¼Œç”¨æˆ·å¯ä»¥æ‰§è¡Œå„ç§æ“ä½œï¼ˆç§»åŠ¨ã€ç¼©æ”¾ã€æ—‹è½¬ï¼‰ï¼Œéœ€è¦æ”¯æŒæ’¤é”€/é‡åšï¼š

```typescript
// âŒ æ²¡æœ‰ä½¿ç”¨å‘½ä»¤æ¨¡å¼çš„ä»£ç ï¼šæ“ä½œå’Œæ’¤é”€é€»è¾‘è€¦åˆ
class GraphicEditor {
  private shape: Shape;
  private history: Array<{ action: string; oldValue: any }> = [];
  
  moveShape(x: number, y: number) {
    const oldPosition = this.shape.getPosition();
    this.shape.setPosition(x, y);
    this.history.push({ action: 'move', oldValue: oldPosition });
  }
  
  scaleShape(scale: number) {
    const oldScale = this.shape.getScale();
    this.shape.setScale(scale);
    this.history.push({ action: 'scale', oldValue: oldScale });
  }
  
  rotateShape(angle: number) {
    const oldAngle = this.shape.getAngle();
    this.shape.setAngle(angle);
    this.history.push({ action: 'rotate', oldValue: oldAngle });
  }
  
  // æ’¤é”€ï¼šéœ€è¦æ ¹æ® action ç±»å‹åˆ†åˆ«å¤„ç†
  undo() {
    const lastAction = this.history.pop();
    if (!lastAction) return;
    
    if (lastAction.action === 'move') {
      this.shape.setPosition(lastAction.oldValue.x, lastAction.oldValue.y);
    } else if (lastAction.action === 'scale') {
      this.shape.setScale(lastAction.oldValue);
    } else if (lastAction.action === 'rotate') {
      this.shape.setAngle(lastAction.oldValue);
    }
    // æ¯å¢åŠ ä¸€ç§æ“ä½œï¼Œéƒ½è¦åœ¨è¿™é‡ŒåŠ  else ifï¼
  }
}
```

**è¿™æ®µä»£ç çš„é—®é¢˜ï¼š**
1. ğŸ”— **æ“ä½œå’Œæ’¤é”€è€¦åˆ**ï¼šæ’¤é”€é€»è¾‘å’Œæ“ä½œé€»è¾‘æ··åœ¨ä¸€èµ·
2. ğŸ”„ **éš¾ä»¥æ‰©å±•**ï¼šæ–°å¢æ“ä½œæ—¶ï¼Œè¦ä¿®æ”¹å¤šå¤„ä»£ç 
3. ğŸ“¦ **æ— æ³•å¤ç”¨**ï¼šæ“ä½œæ— æ³•è¢«åºåˆ—åŒ–ã€å­˜å‚¨ã€ä¼ é€’
4. ğŸš« **ä¸æ”¯æŒå®å‘½ä»¤**ï¼šæ— æ³•ç»„åˆå¤šä¸ªæ“ä½œæˆæ‰¹æ‰§è¡Œ

## æ¨¡å¼æ ¸å¿ƒæ¦‚å¿µ

**å‘½ä»¤æ¨¡å¼çš„æœ¬è´¨**ï¼šå°†è¯·æ±‚å°è£…æˆå¯¹è±¡ï¼Œä½¿å¾—å¯ä»¥ç”¨ä¸åŒçš„è¯·æ±‚å¯¹å®¢æˆ·è¿›è¡Œå‚æ•°åŒ–ï¼Œå¯¹è¯·æ±‚æ’é˜Ÿæˆ–è®°å½•è¯·æ±‚æ—¥å¿—ï¼Œä»¥åŠæ”¯æŒå¯æ’¤é”€çš„æ“ä½œã€‚

**å››ä¸ªæ ¸å¿ƒè§’è‰²ï¼š**
- **å‘½ä»¤ï¼ˆCommandï¼‰**ï¼šå®šä¹‰æ‰§è¡Œæ“ä½œçš„æ¥å£ï¼ˆexecuteã€undoï¼‰
- **å…·ä½“å‘½ä»¤ï¼ˆConcreteCommandï¼‰**ï¼šå®ç°å‘½ä»¤æ¥å£ï¼Œç»‘å®šæ¥æ”¶è€…å’ŒåŠ¨ä½œ
- **æ¥æ”¶è€…ï¼ˆReceiverï¼‰**ï¼šçœŸæ­£æ‰§è¡Œæ“ä½œçš„å¯¹è±¡
- **è°ƒç”¨è€…ï¼ˆInvokerï¼‰**ï¼šå‘èµ·å‘½ä»¤çš„å¯¹è±¡ï¼Œè´Ÿè´£è°ƒç”¨å‘½ä»¤

**ç±»æ¯”**ï¼š
- ğŸ½ï¸ **é¤å…ç‚¹é¤**ï¼šç‚¹èœå•ï¼ˆå‘½ä»¤ï¼‰ã€æœåŠ¡å‘˜ï¼ˆè°ƒç”¨è€…ï¼‰ã€å¨å¸ˆï¼ˆæ¥æ”¶è€…ï¼‰
- ğŸ“º **ç”µè§†é¥æ§å™¨**ï¼šæŒ‰é’®ï¼ˆå‘½ä»¤ï¼‰ã€é¥æ§å™¨ï¼ˆè°ƒç”¨è€…ï¼‰ã€ç”µè§†ï¼ˆæ¥æ”¶è€…ï¼‰
- ğŸ’¼ **å·¥ä½œæŒ‡ä»¤**ï¼šä»»åŠ¡å•ï¼ˆå‘½ä»¤ï¼‰ã€é¡¹ç›®ç»ç†ï¼ˆè°ƒç”¨è€…ï¼‰ã€å¼€å‘äººå‘˜ï¼ˆæ¥æ”¶è€…ï¼‰

**æ ¸å¿ƒæ¥å£ï¼š**

```typescript
interface Command {
  execute(): void;  // æ‰§è¡Œå‘½ä»¤
  undo(): void;     // æ’¤é”€å‘½ä»¤
  redo?(): void;    // é‡åšå‘½ä»¤ï¼ˆé€šå¸¸å°±æ˜¯å†æ¬¡ executeï¼‰
}
```

## å‰ç«¯å®æˆ˜æ¡ˆä¾‹

### åœºæ™¯ä¸€ï¼šå¯Œæ–‡æœ¬ç¼–è¾‘å™¨ï¼ˆæ’¤é”€/é‡åšç³»ç»Ÿï¼‰

æˆ‘ä»¬è¦å®ç°ä¸€ä¸ªæ–‡æœ¬ç¼–è¾‘å™¨ï¼Œæ”¯æŒæ’å…¥ã€åˆ é™¤ã€æ ¼å¼åŒ–ç­‰æ“ä½œï¼Œå¹¶æ”¯æŒæ’¤é”€/é‡åšï¼š

```typescript
// âœ… ä½¿ç”¨å‘½ä»¤æ¨¡å¼é‡æ„

import React, { useState, useRef } from 'react';
import { Card, Button, Space, Input, Tag, message, Select } from 'antd';
import {
  UndoOutlined,
  RedoOutlined,
  BoldOutlined,
  ItalicOutlined,
  FontColorsOutlined,
  HistoryOutlined,
} from '@ant-design/icons';

const { TextArea } = Input;

// 1ï¸âƒ£ å‘½ä»¤æ¥å£
interface Command {
  execute(): void;
  undo(): void;
  getDescription(): string;
}

// 2ï¸âƒ£ æ¥æ”¶è€…ï¼šæ–‡æœ¬ç¼–è¾‘å™¨
class TextEditor {
  private content: string = '';
  private cursorPosition: number = 0;
  private selectionStart: number = 0;
  private selectionEnd: number = 0;
  private onChangeCallback?: (content: string) => void;
  
  setOnChange(callback: (content: string) => void): void {
    this.onChangeCallback = callback;
  }
  
  getContent(): string {
    return this.content;
  }
  
  setContent(content: string): void {
    this.content = content;
    this.onChangeCallback?.(content);
  }
  
  getCursorPosition(): number {
    return this.cursorPosition;
  }
  
  setCursorPosition(position: number): void {
    this.cursorPosition = position;
  }
  
  setSelection(start: number, end: number): void {
    this.selectionStart = start;
    this.selectionEnd = end;
  }
  
  getSelection(): { start: number; end: number } {
    return { start: this.selectionStart, end: this.selectionEnd };
  }
  
  // åœ¨æŒ‡å®šä½ç½®æ’å…¥æ–‡æœ¬
  insertText(position: number, text: string): void {
    this.content = 
      this.content.slice(0, position) + 
      text + 
      this.content.slice(position);
    this.cursorPosition = position + text.length;
    this.onChangeCallback?.(this.content);
  }
  
  // åˆ é™¤æŒ‡å®šèŒƒå›´çš„æ–‡æœ¬
  deleteText(start: number, end: number): string {
    const deleted = this.content.slice(start, end);
    this.content = this.content.slice(0, start) + this.content.slice(end);
    this.cursorPosition = start;
    this.onChangeCallback?.(this.content);
    return deleted;
  }
  
  // æ›¿æ¢æŒ‡å®šèŒƒå›´çš„æ–‡æœ¬
  replaceText(start: number, end: number, newText: string): string {
    const oldText = this.content.slice(start, end);
    this.content = 
      this.content.slice(0, start) + 
      newText + 
      this.content.slice(end);
    this.cursorPosition = start + newText.length;
    this.onChangeCallback?.(this.content);
    return oldText;
  }
}

// 3ï¸âƒ£ å…·ä½“å‘½ä»¤ï¼šæ’å…¥æ–‡æœ¬å‘½ä»¤
class InsertTextCommand implements Command {
  private editor: TextEditor;
  private text: string;
  private position: number;
  
  constructor(editor: TextEditor, text: string, position: number) {
    this.editor = editor;
    this.text = text;
    this.position = position;
  }
  
  execute(): void {
    this.editor.insertText(this.position, this.text);
    console.log(`[å‘½ä»¤æ‰§è¡Œ] æ’å…¥æ–‡æœ¬: "${this.text}"`);
  }
  
  undo(): void {
    this.editor.deleteText(this.position, this.position + this.text.length);
    console.log(`[å‘½ä»¤æ’¤é”€] åˆ é™¤æ–‡æœ¬: "${this.text}"`);
  }
  
  getDescription(): string {
    return `æ’å…¥: "${this.text.length > 10 ? this.text.slice(0, 10) + '...' : this.text}"`;
  }
}

// 4ï¸âƒ£ å…·ä½“å‘½ä»¤ï¼šåˆ é™¤æ–‡æœ¬å‘½ä»¤
class DeleteTextCommand implements Command {
  private editor: TextEditor;
  private start: number;
  private end: number;
  private deletedText: string = '';
  
  constructor(editor: TextEditor, start: number, end: number) {
    this.editor = editor;
    this.start = start;
    this.end = end;
  }
  
  execute(): void {
    this.deletedText = this.editor.deleteText(this.start, this.end);
    console.log(`[å‘½ä»¤æ‰§è¡Œ] åˆ é™¤æ–‡æœ¬: "${this.deletedText}"`);
  }
  
  undo(): void {
    this.editor.insertText(this.start, this.deletedText);
    console.log(`[å‘½ä»¤æ’¤é”€] æ¢å¤æ–‡æœ¬: "${this.deletedText}"`);
  }
  
  getDescription(): string {
    return `åˆ é™¤: "${this.deletedText.slice(0, 10)}${this.deletedText.length > 10 ? '...' : ''}"`;
  }
}

// 5ï¸âƒ£ å…·ä½“å‘½ä»¤ï¼šæ ¼å¼åŒ–æ–‡æœ¬å‘½ä»¤ï¼ˆåŠ ç²—ã€æ–œä½“ç­‰ï¼‰
class FormatTextCommand implements Command {
  private editor: TextEditor;
  private start: number;
  private end: number;
  private formatType: 'bold' | 'italic' | 'underline';
  private oldText: string = '';
  
  constructor(
    editor: TextEditor, 
    start: number, 
    end: number, 
    formatType: 'bold' | 'italic' | 'underline'
  ) {
    this.editor = editor;
    this.start = start;
    this.end = end;
    this.formatType = formatType;
  }
  
  execute(): void {
    const content = this.editor.getContent();
    const selectedText = content.slice(this.start, this.end);
    
    let formattedText = '';
    switch (this.formatType) {
      case 'bold':
        formattedText = `**${selectedText}**`;
        break;
      case 'italic':
        formattedText = `*${selectedText}*`;
        break;
      case 'underline':
        formattedText = `__${selectedText}__`;
        break;
    }
    
    this.oldText = this.editor.replaceText(this.start, this.end, formattedText);
    console.log(`[å‘½ä»¤æ‰§è¡Œ] ${this.formatType} æ ¼å¼åŒ–`);
  }
  
  undo(): void {
    const formattedLength = this.oldText.length + (this.formatType === 'underline' ? 4 : 2);
    this.editor.replaceText(this.start, this.start + formattedLength, this.oldText);
    console.log(`[å‘½ä»¤æ’¤é”€] å–æ¶ˆ ${this.formatType} æ ¼å¼åŒ–`);
  }
  
  getDescription(): string {
    const typeMap = { bold: 'åŠ ç²—', italic: 'æ–œä½“', underline: 'ä¸‹åˆ’çº¿' };
    return `${typeMap[this.formatType]}: "${this.oldText.slice(0, 10)}..."`;
  }
}

// 6ï¸âƒ£ å®å‘½ä»¤ï¼šç»„åˆå¤šä¸ªå‘½ä»¤
class MacroCommand implements Command {
  private commands: Command[] = [];
  private description: string;
  
  constructor(commands: Command[], description: string) {
    this.commands = commands;
    this.description = description;
  }
  
  execute(): void {
    console.log(`[å®å‘½ä»¤æ‰§è¡Œ] ${this.description}`);
    this.commands.forEach(cmd => cmd.execute());
  }
  
  undo(): void {
    console.log(`[å®å‘½ä»¤æ’¤é”€] ${this.description}`);
    // é€†åºæ’¤é”€
    for (let i = this.commands.length - 1; i >= 0; i--) {
      this.commands[i].undo();
    }
  }
  
  getDescription(): string {
    return `å®: ${this.description}`;
  }
}

// 7ï¸âƒ£ è°ƒç”¨è€…ï¼šå‘½ä»¤ç®¡ç†å™¨ï¼ˆæ”¯æŒæ’¤é”€/é‡åšï¼‰
class CommandManager {
  private history: Command[] = [];
  private currentIndex: number = -1;
  
  // æ‰§è¡Œå‘½ä»¤
  executeCommand(command: Command): void {
    // å¦‚æœå½“å‰ä¸åœ¨æœ€æ–°ä½ç½®ï¼Œåˆ é™¤åé¢çš„å†å²
    if (this.currentIndex < this.history.length - 1) {
      this.history = this.history.slice(0, this.currentIndex + 1);
    }
    
    command.execute();
    this.history.push(command);
    this.currentIndex++;
    
    console.log(`[å‘½ä»¤ç®¡ç†å™¨] æ‰§è¡Œå‘½ä»¤ï¼Œå†å²é•¿åº¦: ${this.history.length}`);
  }
  
  // æ’¤é”€
  undo(): boolean {
    if (this.currentIndex < 0) {
      console.log('[å‘½ä»¤ç®¡ç†å™¨] æ— æ³•æ’¤é”€');
      return false;
    }
    
    const command = this.history[this.currentIndex];
    command.undo();
    this.currentIndex--;
    
    console.log(`[å‘½ä»¤ç®¡ç†å™¨] æ’¤é”€å‘½ä»¤ï¼Œå½“å‰ä½ç½®: ${this.currentIndex}`);
    return true;
  }
  
  // é‡åš
  redo(): boolean {
    if (this.currentIndex >= this.history.length - 1) {
      console.log('[å‘½ä»¤ç®¡ç†å™¨] æ— æ³•é‡åš');
      return false;
    }
    
    this.currentIndex++;
    const command = this.history[this.currentIndex];
    command.execute();
    
    console.log(`[å‘½ä»¤ç®¡ç†å™¨] é‡åšå‘½ä»¤ï¼Œå½“å‰ä½ç½®: ${this.currentIndex}`);
    return true;
  }
  
  canUndo(): boolean {
    return this.currentIndex >= 0;
  }
  
  canRedo(): boolean {
    return this.currentIndex < this.history.length - 1;
  }
  
  getHistory(): Command[] {
    return this.history.slice(0, this.currentIndex + 1);
  }
  
  clear(): void {
    this.history = [];
    this.currentIndex = -1;
  }
}

// 8ï¸âƒ£ React ç»„ä»¶
const CommandTextEditor: React.FC = () => {
  const editorRef = useRef(new TextEditor());
  const commandManagerRef = useRef(new CommandManager());
  
  const [content, setContent] = useState('');
  const [canUndo, setCanUndo] = useState(false);
  const [canRedo, setCanRedo] = useState(false);
  const [history, setHistory] = useState<Command[]>([]);
  const [selectionStart, setSelectionStart] = useState(0);
  const [selectionEnd, setSelectionEnd] = useState(0);
  
  const textAreaRef = useRef<any>(null);
  
  // åˆå§‹åŒ–ç¼–è¾‘å™¨å›è°ƒ
  React.useEffect(() => {
    editorRef.current.setOnChange((newContent) => {
      setContent(newContent);
      updateButtons();
    });
  }, []);
  
  // æ›´æ–°æŒ‰é’®çŠ¶æ€
  const updateButtons = () => {
    setCanUndo(commandManagerRef.current.canUndo());
    setCanRedo(commandManagerRef.current.canRedo());
    setHistory(commandManagerRef.current.getHistory());
  };
  
  // æ‰§è¡Œå‘½ä»¤
  const executeCommand = (command: Command) => {
    commandManagerRef.current.executeCommand(command);
    updateButtons();
  };
  
  // æ‰‹åŠ¨è¾“å…¥æ–‡æœ¬
  const handleTextChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const newContent = e.target.value;
    const oldContent = content;
    const cursorPos = e.target.selectionStart || 0;
    
    // åˆ¤æ–­æ˜¯æ’å…¥è¿˜æ˜¯åˆ é™¤
    if (newContent.length > oldContent.length) {
      // æ’å…¥
      const insertedText = newContent.slice(
        cursorPos - (newContent.length - oldContent.length),
        cursorPos
      );
      const insertPos = cursorPos - insertedText.length;
      
      const command = new InsertTextCommand(editorRef.current, insertedText, insertPos);
      executeCommand(command);
    } else if (newContent.length < oldContent.length) {
      // åˆ é™¤
      const deleteStart = cursorPos;
      const deleteEnd = deleteStart + (oldContent.length - newContent.length);
      
      const command = new DeleteTextCommand(editorRef.current, deleteStart, deleteEnd);
      executeCommand(command);
    }
  };
  
  // é€‰ä¸­æ–‡æœ¬å˜åŒ–
  const handleSelectionChange = () => {
    if (textAreaRef.current) {
      const textarea = textAreaRef.current.resizableTextArea.textArea;
      setSelectionStart(textarea.selectionStart);
      setSelectionEnd(textarea.selectionEnd);
      editorRef.current.setSelection(textarea.selectionStart, textarea.selectionEnd);
    }
  };
  
  // æ ¼å¼åŒ–å‘½ä»¤
  const handleFormat = (type: 'bold' | 'italic' | 'underline') => {
    if (selectionStart === selectionEnd) {
      message.warning('è¯·å…ˆé€‰ä¸­æ–‡æœ¬');
      return;
    }
    
    const command = new FormatTextCommand(
      editorRef.current,
      selectionStart,
      selectionEnd,
      type
    );
    executeCommand(command);
  };
  
  // å®å‘½ä»¤ï¼šä¸€é”®æ’ç‰ˆ
  const handleAutoFormat = () => {
    if (content.length === 0) {
      message.warning('è¯·å…ˆè¾“å…¥å†…å®¹');
      return;
    }
    
    const commands: Command[] = [];
    
    // åœ¨å¼€å¤´æ’å…¥æ ‡é¢˜
    commands.push(new InsertTextCommand(editorRef.current, '# æ ‡é¢˜\n\n', 0));
    
    // åœ¨ç»“å°¾æ’å…¥ç­¾å
    const endPos = editorRef.current.getContent().length;
    commands.push(new InsertTextCommand(editorRef.current, '\n\n---\nä½œè€…ï¼šå‘½ä»¤æ¨¡å¼ç¤ºä¾‹', endPos));
    
    const macroCommand = new MacroCommand(commands, 'ä¸€é”®æ’ç‰ˆ');
    executeCommand(macroCommand);
    
    message.success('ä¸€é”®æ’ç‰ˆå®Œæˆ');
  };
  
  // æ’¤é”€
  const handleUndo = () => {
    if (commandManagerRef.current.undo()) {
      updateButtons();
      message.success('å·²æ’¤é”€');
    }
  };
  
  // é‡åš
  const handleRedo = () => {
    if (commandManagerRef.current.redo()) {
      updateButtons();
      message.success('å·²é‡åš');
    }
  };
  
  return (
    <div style={{ padding: 24, backgroundColor: '#f0f2f5', minHeight: '100vh' }}>
      <Card title="âœï¸ æ–‡æœ¬ç¼–è¾‘å™¨ï¼ˆå‘½ä»¤æ¨¡å¼ï¼‰" style={{ maxWidth: 1200, margin: '0 auto' }}>
        {/* å·¥å…·æ  */}
        <Card type="inner" title="å·¥å…·æ " style={{ marginBottom: 16 }}>
          <Space wrap>
            <Button
              icon={<UndoOutlined />}
              onClick={handleUndo}
              disabled={!canUndo}
            >
              æ’¤é”€ (Ctrl+Z)
            </Button>
            <Button
              icon={<RedoOutlined />}
              onClick={handleRedo}
              disabled={!canRedo}
            >
              é‡åš (Ctrl+Y)
            </Button>
            
            <div style={{ width: 1, height: 30, backgroundColor: '#d9d9d9' }} />
            
            <Button
              icon={<BoldOutlined />}
              onClick={() => handleFormat('bold')}
              disabled={selectionStart === selectionEnd}
            >
              åŠ ç²—
            </Button>
            <Button
              icon={<ItalicOutlined />}
              onClick={() => handleFormat('italic')}
              disabled={selectionStart === selectionEnd}
            >
              æ–œä½“
            </Button>
            <Button
              icon={<FontColorsOutlined />}
              onClick={() => handleFormat('underline')}
              disabled={selectionStart === selectionEnd}
            >
              ä¸‹åˆ’çº¿
            </Button>
            
            <div style={{ width: 1, height: 30, backgroundColor: '#d9d9d9' }} />
            
            <Button
              type="primary"
              onClick={handleAutoFormat}
            >
              ä¸€é”®æ’ç‰ˆï¼ˆå®å‘½ä»¤ï¼‰
            </Button>
          </Space>
          
          <div style={{ marginTop: 12 }}>
            <Tag color="blue">å‘½ä»¤å†å²: {history.length}</Tag>
            {selectionStart !== selectionEnd && (
              <Tag color="green">
                å·²é€‰ä¸­ {selectionEnd - selectionStart} ä¸ªå­—ç¬¦
              </Tag>
            )}
          </div>
        </Card>
        
        <div style={{ display: 'grid', gridTemplateColumns: '2fr 1fr', gap: 16 }}>
          {/* ç¼–è¾‘åŒº */}
          <Card type="inner" title="ç¼–è¾‘åŒº">
            <TextArea
              ref={textAreaRef}
              value={content}
              onChange={handleTextChange}
              onSelect={handleSelectionChange}
              placeholder="è¯·è¾“å…¥æ–‡æœ¬ï¼Œæ”¯æŒæ’¤é”€/é‡åš..."
              rows={15}
              style={{ fontSize: 14, lineHeight: 1.8 }}
            />
          </Card>
          
          {/* å‘½ä»¤å†å² */}
          <Card type="inner" title={<Space><HistoryOutlined /> å‘½ä»¤å†å²</Space>}>
            <div style={{ maxHeight: 400, overflow: 'auto' }}>
              {history.length === 0 ? (
                <div style={{ textAlign: 'center', color: '#999', padding: 40 }}>
                  æš‚æ— å‘½ä»¤å†å²
                </div>
              ) : (
                history.map((cmd, index) => (
                  <div
                    key={index}
                    style={{
                      padding: '8px 12px',
                      marginBottom: 8,
                      backgroundColor: '#fafafa',
                      border: '1px solid #d9d9d9',
                      borderRadius: 4,
                    }}
                  >
                    <Space>
                      <Tag color="blue">{index + 1}</Tag>
                      <span style={{ fontSize: 12 }}>
                        {cmd.getDescription()}
                      </span>
                    </Space>
                  </div>
                ))
              )}
            </div>
          </Card>
        </div>
        
        {/* è¯´æ˜ */}
        <Card type="inner" title="ğŸ“‹ å‘½ä»¤æ¨¡å¼è¯´æ˜" style={{ marginTop: 16 }}>
          <ul style={{ margin: 0, paddingLeft: 20 }}>
            <li>âœ… <strong>Command</strong> æ˜¯å‘½ä»¤æ¥å£ï¼Œå®šä¹‰ execute å’Œ undo æ–¹æ³•</li>
            <li>âœ… <strong>InsertTextCommandã€DeleteTextCommand ç­‰</strong> æ˜¯å…·ä½“å‘½ä»¤</li>
            <li>âœ… <strong>TextEditor</strong> æ˜¯æ¥æ”¶è€…ï¼ŒçœŸæ­£æ‰§è¡Œæ–‡æœ¬æ“ä½œ</li>
            <li>âœ… <strong>CommandManager</strong> æ˜¯è°ƒç”¨è€…ï¼Œç®¡ç†å‘½ä»¤å†å²</li>
            <li>âœ… <strong>MacroCommand</strong> æ˜¯å®å‘½ä»¤ï¼Œç»„åˆå¤šä¸ªå‘½ä»¤ä¸€èµ·æ‰§è¡Œ</li>
            <li>âœ… æ¯ä¸ªå‘½ä»¤éƒ½æ˜¯ç‹¬ç«‹çš„å¯¹è±¡ï¼Œå¯ä»¥è¢«å­˜å‚¨ã€ä¼ é€’ã€æ’¤é”€</li>
          </ul>
        </Card>
      </Card>
    </div>
  );
};

export default CommandTextEditor;
```

#### ğŸ¯ ä½¿ç”¨å‘½ä»¤æ¨¡å¼åçš„å¥½å¤„

1. **æ’¤é”€/é‡åšç®€å•**ï¼šæ¯ä¸ªå‘½ä»¤è‡ªå·±çŸ¥é“æ€ä¹ˆæ’¤é”€ï¼Œä¸éœ€è¦åœ¨å¤–éƒ¨åˆ¤æ–­
2. **æ˜“äºæ‰©å±•**ï¼šæ–°å¢å‘½ä»¤åªéœ€å®ç° Command æ¥å£
3. **æ”¯æŒå®å‘½ä»¤**ï¼šå¯ä»¥ç»„åˆå¤šä¸ªå‘½ä»¤æ‰¹é‡æ‰§è¡Œ
4. **å‘½ä»¤å¯åºåˆ—åŒ–**ï¼šå¯ä»¥ä¿å­˜ã€ä¼ è¾“ã€é‡æ”¾å‘½ä»¤

---

### åœºæ™¯äºŒï¼šå¿«æ·é”®ç³»ç»Ÿï¼ˆé”®ç›˜å‘½ä»¤æ˜ å°„ï¼‰

å®ç°ä¸€ä¸ªå¯é…ç½®çš„å¿«æ·é”®ç³»ç»Ÿï¼š

```typescript
import React, { useState, useEffect } from 'react';
import { Card, Table, Button, Modal, Input, Select, Space, message, Tag } from 'antd';
import { SettingOutlined, PlusOutlined, DeleteOutlined } from '@ant-design/icons';

const { Option } = Select;

// å‘½ä»¤æ¥å£
interface KeyboardCommand {
  execute(): void;
  getDescription(): string;
  getName(): string;
}

// å…·ä½“å‘½ä»¤ï¼šä¿å­˜æ–‡æ¡£
class SaveCommand implements KeyboardCommand {
  private callback: () => void;
  
  constructor(callback: () => void) {
    this.callback = callback;
  }
  
  execute(): void {
    console.log('[å‘½ä»¤æ‰§è¡Œ] ä¿å­˜æ–‡æ¡£');
    this.callback();
  }
  
  getDescription(): string {
    return 'ä¿å­˜å½“å‰æ–‡æ¡£';
  }
  
  getName(): string {
    return 'save';
  }
}

// å…·ä½“å‘½ä»¤ï¼šæ–°å»ºæ–‡æ¡£
class NewDocumentCommand implements KeyboardCommand {
  private callback: () => void;
  
  constructor(callback: () => void) {
    this.callback = callback;
  }
  
  execute(): void {
    console.log('[å‘½ä»¤æ‰§è¡Œ] æ–°å»ºæ–‡æ¡£');
    this.callback();
  }
  
  getDescription(): string {
    return 'æ–°å»ºæ–‡æ¡£';
  }
  
  getName(): string {
    return 'new';
  }
}

// å…·ä½“å‘½ä»¤ï¼šæ‰“å¼€æ–‡ä»¶
class OpenCommand implements KeyboardCommand {
  private callback: () => void;
  
  constructor(callback: () => void) {
    this.callback = callback;
  }
  
  execute(): void {
    console.log('[å‘½ä»¤æ‰§è¡Œ] æ‰“å¼€æ–‡ä»¶');
    this.callback();
  }
  
  getDescription(): string {
    return 'æ‰“å¼€æ–‡ä»¶';
  }
  
  getName(): string {
    return 'open';
  }
}

// å…·ä½“å‘½ä»¤ï¼šæŸ¥æ‰¾
class FindCommand implements KeyboardCommand {
  private callback: () => void;
  
  constructor(callback: () => void) {
    this.callback = callback;
  }
  
  execute(): void {
    console.log('[å‘½ä»¤æ‰§è¡Œ] æŸ¥æ‰¾');
    this.callback();
  }
  
  getDescription(): string {
    return 'æŸ¥æ‰¾æ–‡æœ¬';
  }
  
  getName(): string {
    return 'find';
  }
}

// å¿«æ·é”®ç®¡ç†å™¨
class ShortcutManager {
  private keyMap: Map<string, KeyboardCommand> = new Map();
  
  // æ³¨å†Œå¿«æ·é”®
  register(keys: string, command: KeyboardCommand): void {
    this.keyMap.set(keys, command);
    console.log(`[å¿«æ·é”®æ³¨å†Œ] ${keys} -> ${command.getName()}`);
  }
  
  // å–æ¶ˆæ³¨å†Œ
  unregister(keys: string): void {
    this.keyMap.delete(keys);
    console.log(`[å¿«æ·é”®å–æ¶ˆ] ${keys}`);
  }
  
  // æ‰§è¡Œå¿«æ·é”®å¯¹åº”çš„å‘½ä»¤
  execute(keys: string): boolean {
    const command = this.keyMap.get(keys);
    if (command) {
      command.execute();
      return true;
    }
    return false;
  }
  
  // è·å–æ‰€æœ‰å¿«æ·é”®
  getAll(): Array<{ keys: string; command: KeyboardCommand }> {
    return Array.from(this.keyMap.entries()).map(([keys, command]) => ({
      keys,
      command,
    }));
  }
  
  // æ£€æŸ¥å¿«æ·é”®æ˜¯å¦å·²è¢«å ç”¨
  isRegistered(keys: string): boolean {
    return this.keyMap.has(keys);
  }
}

// React ç»„ä»¶
const ShortcutSystem: React.FC = () => {
  const [manager] = useState(() => new ShortcutManager());
  const [shortcuts, setShortcuts] = useState<Array<{ keys: string; command: KeyboardCommand }>>([]);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [logs, setLogs] = useState<string[]>([]);
  
  // å‘½ä»¤å›è°ƒ
  const commandCallbacks = {
    save: () => {
      addLog('âœ… æ–‡æ¡£å·²ä¿å­˜');
      message.success('æ–‡æ¡£å·²ä¿å­˜');
    },
    new: () => {
      addLog('ğŸ“„ æ–°å»ºæ–‡æ¡£');
      message.info('æ–°å»ºæ–‡æ¡£');
    },
    open: () => {
      addLog('ğŸ“‚ æ‰“å¼€æ–‡ä»¶å¯¹è¯æ¡†');
      message.info('æ‰“å¼€æ–‡ä»¶');
    },
    find: () => {
      addLog('ğŸ” æ‰“å¼€æŸ¥æ‰¾å¯¹è¯æ¡†');
      message.info('æŸ¥æ‰¾æ–‡æœ¬');
    },
  };
  
  // æ·»åŠ æ—¥å¿—
  const addLog = (log: string) => {
    setLogs(prev => [`${new Date().toLocaleTimeString()} - ${log}`, ...prev].slice(0, 10));
  };
  
  // åˆå§‹åŒ–é»˜è®¤å¿«æ·é”®
  useEffect(() => {
    manager.register('Ctrl+S', new SaveCommand(commandCallbacks.save));
    manager.register('Ctrl+N', new NewDocumentCommand(commandCallbacks.new));
    manager.register('Ctrl+O', new OpenCommand(commandCallbacks.open));
    manager.register('Ctrl+F', new FindCommand(commandCallbacks.find));
    
    setShortcuts(manager.getAll());
  }, []);
  
  // ç›‘å¬é”®ç›˜äº‹ä»¶
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      const keys: string[] = [];
      
      if (e.ctrlKey || e.metaKey) keys.push('Ctrl');
      if (e.shiftKey) keys.push('Shift');
      if (e.altKey) keys.push('Alt');
      
      if (e.key.length === 1) {
        keys.push(e.key.toUpperCase());
      } else if (['Enter', 'Escape', 'Tab', 'Space'].includes(e.key)) {
        keys.push(e.key);
      }
      
      const shortcut = keys.join('+');
      
      if (manager.execute(shortcut)) {
        e.preventDefault();
        addLog(`âŒ¨ï¸ å¿«æ·é”®è§¦å‘: ${shortcut}`);
      }
    };
    
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [manager]);
  
  // åˆ é™¤å¿«æ·é”®
  const handleDelete = (keys: string) => {
    manager.unregister(keys);
    setShortcuts(manager.getAll());
    message.success(`å·²åˆ é™¤å¿«æ·é”®: ${keys}`);
  };
  
  // è¡¨æ ¼åˆ—
  const columns = [
    {
      title: 'å¿«æ·é”®',
      dataIndex: 'keys',
      key: 'keys',
      render: (keys: string) => <Tag color="blue">{keys}</Tag>,
    },
    {
      title: 'å‘½ä»¤',
      key: 'command',
      render: (record: any) => record.command.getName(),
    },
    {
      title: 'è¯´æ˜',
      key: 'description',
      render: (record: any) => record.command.getDescription(),
    },
    {
      title: 'æ“ä½œ',
      key: 'action',
      render: (record: any) => (
        <Button
          danger
          size="small"
          icon={<DeleteOutlined />}
          onClick={() => handleDelete(record.keys)}
        >
          åˆ é™¤
        </Button>
      ),
    },
  ];
  
  return (
    <div style={{ padding: 24, backgroundColor: '#f0f2f5', minHeight: '100vh' }}>
      <Card
        title="âŒ¨ï¸ å¿«æ·é”®ç³»ç»Ÿï¼ˆå‘½ä»¤æ¨¡å¼ï¼‰"
        style={{ maxWidth: 1000, margin: '0 auto' }}
        extra={
          <Button
            type="primary"
            icon={<SettingOutlined />}
            onClick={() => setIsModalOpen(true)}
          >
            å¿«æ·é”®è®¾ç½®
          </Button>
        }
      >
        {/* æç¤ºä¿¡æ¯ */}
        <Card type="inner" style={{ marginBottom: 16, backgroundColor: '#e6f7ff' }}>
          <Space direction="vertical">
            <div>ğŸ’¡ æŒ‰ä¸‹å¿«æ·é”®è¯•è¯•ï¼š</div>
            <Space wrap>
              <Tag color="blue">Ctrl+S</Tag> ä¿å­˜æ–‡æ¡£
              <Tag color="blue">Ctrl+N</Tag> æ–°å»ºæ–‡æ¡£
              <Tag color="blue">Ctrl+O</Tag> æ‰“å¼€æ–‡ä»¶
              <Tag color="blue">Ctrl+F</Tag> æŸ¥æ‰¾æ–‡æœ¬
            </Space>
          </Space>
        </Card>
        
        {/* å¿«æ·é”®åˆ—è¡¨ */}
        <Card type="inner" title="å·²æ³¨å†Œçš„å¿«æ·é”®" style={{ marginBottom: 16 }}>
          <Table
            dataSource={shortcuts}
            columns={columns}
            rowKey="keys"
            pagination={false}
          />
        </Card>
        
        {/* æ“ä½œæ—¥å¿— */}
        <Card type="inner" title="æ“ä½œæ—¥å¿—">
          <div style={{ maxHeight: 200, overflow: 'auto' }}>
            {logs.length === 0 ? (
              <div style={{ textAlign: 'center', color: '#999', padding: 20 }}>
                æš‚æ— æ“ä½œæ—¥å¿—
              </div>
            ) : (
              logs.map((log, index) => (
                <div
                  key={index}
                  style={{
                    padding: '4px 8px',
                    fontSize: 12,
                    fontFamily: 'monospace',
                    borderBottom: '1px solid #f0f0f0',
                  }}
                >
                  {log}
                </div>
              ))
            )}
          </div>
        </Card>
        
        {/* è¯´æ˜ */}
        <Card type="inner" title="ğŸ“‹ å‘½ä»¤æ¨¡å¼è¯´æ˜" style={{ marginTop: 16 }}>
          <ul style={{ margin: 0, paddingLeft: 20 }}>
            <li>âœ… <strong>SaveCommandã€NewDocumentCommand ç­‰</strong> æ˜¯å…·ä½“å‘½ä»¤</li>
            <li>âœ… <strong>ShortcutManager</strong> ç®¡ç†å¿«æ·é”®ä¸å‘½ä»¤çš„æ˜ å°„å…³ç³»</li>
            <li>âœ… æŒ‰ä¸‹å¿«æ·é”®æ—¶ï¼ŒShortcutManager æ‰¾åˆ°å¯¹åº”å‘½ä»¤å¹¶æ‰§è¡Œ</li>
            <li>âœ… æ”¯æŒåŠ¨æ€æ³¨å†Œ/æ³¨é”€å¿«æ·é”®</li>
            <li>âœ… å‘½ä»¤å’Œå¿«æ·é”®è§£è€¦ï¼ŒåŒä¸€å‘½ä»¤å¯ä»¥ç»‘å®šå¤šä¸ªå¿«æ·é”®</li>
          </ul>
        </Card>
      </Card>
    </div>
  );
};

export default ShortcutSystem;
```

---

### åœºæ™¯ä¸‰ï¼šæ‰¹é‡æ“ä½œé˜Ÿåˆ—ï¼ˆäº‹åŠ¡ç®¡ç†ï¼‰

å®ç°ä¸€ä¸ªæ”¯æŒæ‰¹é‡æ“ä½œã€äº‹åŠ¡å›æ»šçš„ç³»ç»Ÿï¼š

```typescript
import React, { useState } from 'react';
import { Card, Table, Button, Space, message, Tag, Modal, Progress } from 'antd';
import { PlayCircleOutlined, DeleteOutlined, PlusOutlined, RollbackOutlined } from '@ant-design/icons';

// ç”¨æˆ·æ•°æ®
interface User {
  id: number;
  name: string;
  status: 'active' | 'inactive';
  role: 'admin' | 'user';
}

// å‘½ä»¤æ¥å£
interface UserCommand {
  execute(): Promise<void>;
  undo(): Promise<void>;
  getDescription(): string;
}

// å…·ä½“å‘½ä»¤ï¼šæ¿€æ´»ç”¨æˆ·
class ActivateUserCommand implements UserCommand {
  private user: User;
  private oldStatus: 'active' | 'inactive';
  
  constructor(user: User) {
    this.user = user;
    this.oldStatus = user.status;
  }
  
  async execute(): Promise<void> {
    await new Promise(resolve => setTimeout(resolve, 300)); // æ¨¡æ‹Ÿå¼‚æ­¥æ“ä½œ
    this.user.status = 'active';
    console.log(`[å‘½ä»¤æ‰§è¡Œ] æ¿€æ´»ç”¨æˆ·: ${this.user.name}`);
  }
  
  async undo(): Promise<void> {
    await new Promise(resolve => setTimeout(resolve, 300));
    this.user.status = this.oldStatus;
    console.log(`[å‘½ä»¤æ’¤é”€] æ¢å¤ç”¨æˆ·çŠ¶æ€: ${this.user.name}`);
  }
  
  getDescription(): string {
    return `æ¿€æ´»ç”¨æˆ·: ${this.user.name}`;
  }
}

// å…·ä½“å‘½ä»¤ï¼šåœç”¨ç”¨æˆ·
class DeactivateUserCommand implements UserCommand {
  private user: User;
  private oldStatus: 'active' | 'inactive';
  
  constructor(user: User) {
    this.user = user;
    this.oldStatus = user.status;
  }
  
  async execute(): Promise<void> {
    await new Promise(resolve => setTimeout(resolve, 300));
    this.user.status = 'inactive';
    console.log(`[å‘½ä»¤æ‰§è¡Œ] åœç”¨ç”¨æˆ·: ${this.user.name}`);
  }
  
  async undo(): Promise<void> {
    await new Promise(resolve => setTimeout(resolve, 300));
    this.user.status = this.oldStatus;
    console.log(`[å‘½ä»¤æ’¤é”€] æ¢å¤ç”¨æˆ·çŠ¶æ€: ${this.user.name}`);
  }
  
  getDescription(): string {
    return `åœç”¨ç”¨æˆ·: ${this.user.name}`;
  }
}

// å…·ä½“å‘½ä»¤ï¼šè®¾ç½®ç®¡ç†å‘˜
class SetAdminCommand implements UserCommand {
  private user: User;
  private oldRole: 'admin' | 'user';
  
  constructor(user: User) {
    this.user = user;
    this.oldRole = user.role;
  }
  
  async execute(): Promise<void> {
    await new Promise(resolve => setTimeout(resolve, 300));
    this.user.role = 'admin';
    console.log(`[å‘½ä»¤æ‰§è¡Œ] è®¾ç½®ç®¡ç†å‘˜: ${this.user.name}`);
  }
  
  async undo(): Promise<void> {
    await new Promise(resolve => setTimeout(resolve, 300));
    this.user.role = this.oldRole;
    console.log(`[å‘½ä»¤æ’¤é”€] æ¢å¤ç”¨æˆ·è§’è‰²: ${this.user.name}`);
  }
  
  getDescription(): string {
    return `è®¾ç½®ç®¡ç†å‘˜: ${this.user.name}`;
  }
}

// æ‰¹é‡å‘½ä»¤ï¼ˆäº‹åŠ¡ï¼‰
class BatchCommand implements UserCommand {
  private commands: UserCommand[];
  private executedCommands: UserCommand[] = [];
  private description: string;
  
  constructor(commands: UserCommand[], description: string) {
    this.commands = commands;
    this.description = description;
  }
  
  async execute(): Promise<void> {
    console.log(`[æ‰¹é‡å‘½ä»¤å¼€å§‹] ${this.description}`);
    this.executedCommands = [];
    
    try {
      for (const command of this.commands) {
        await command.execute();
        this.executedCommands.push(command);
      }
      console.log(`[æ‰¹é‡å‘½ä»¤å®Œæˆ] æˆåŠŸæ‰§è¡Œ ${this.executedCommands.length} æ¡å‘½ä»¤`);
    } catch (error) {
      console.error('[æ‰¹é‡å‘½ä»¤å¤±è´¥] å¼€å§‹å›æ»š');
      // å‡ºé”™æ—¶è‡ªåŠ¨å›æ»šå·²æ‰§è¡Œçš„å‘½ä»¤
      await this.undo();
      throw error;
    }
  }
  
  async undo(): Promise<void> {
    console.log(`[æ‰¹é‡å‘½ä»¤å›æ»š] ${this.description}`);
    
    // é€†åºæ’¤é”€
    for (let i = this.executedCommands.length - 1; i >= 0; i--) {
      await this.executedCommands[i].undo();
    }
    
    this.executedCommands = [];
    console.log('[æ‰¹é‡å‘½ä»¤å›æ»šå®Œæˆ]');
  }
  
  getDescription(): string {
    return `æ‰¹é‡æ“ä½œ: ${this.description} (${this.commands.length} æ¡å‘½ä»¤)`;
  }
  
  getProgress(): number {
    return (this.executedCommands.length / this.commands.length) * 100;
  }
}

// React ç»„ä»¶
const BatchOperationSystem: React.FC = () => {
  // æ¨¡æ‹Ÿç”¨æˆ·æ•°æ®
  const [users, setUsers] = useState<User[]>([
    { id: 1, name: 'å¼ ä¸‰', status: 'active', role: 'user' },
    { id: 2, name: 'æå››', status: 'active', role: 'user' },
    { id: 3, name: 'ç‹äº”', status: 'inactive', role: 'user' },
    { id: 4, name: 'èµµå…­', status: 'active', role: 'admin' },
    { id: 5, name: 'é’±ä¸ƒ', status: 'inactive', role: 'user' },
  ]);
  
  const [selectedRowKeys, setSelectedRowKeys] = useState<number[]>([]);
  const [isExecuting, setIsExecuting] = useState(false);
  const [progress, setProgress] = useState(0);
  const [lastCommand, setLastCommand] = useState<UserCommand | null>(null);
  
  // åˆ·æ–°è¡¨æ ¼
  const refreshTable = () => {
    setUsers([...users]);
  };
  
  // æ‰¹é‡æ¿€æ´»
  const handleBatchActivate = async () => {
    if (selectedRowKeys.length === 0) {
      message.warning('è¯·å…ˆé€‰æ‹©ç”¨æˆ·');
      return;
    }
    
    const commands = selectedRowKeys.map(id => {
      const user = users.find(u => u.id === id)!;
      return new ActivateUserCommand(user);
    });
    
    const batchCommand = new BatchCommand(commands, 'æ‰¹é‡æ¿€æ´»ç”¨æˆ·');
    await executeBatchCommand(batchCommand);
  };
  
  // æ‰¹é‡åœç”¨
  const handleBatchDeactivate = async () => {
    if (selectedRowKeys.length === 0) {
      message.warning('è¯·å…ˆé€‰æ‹©ç”¨æˆ·');
      return;
    }
    
    const commands = selectedRowKeys.map(id => {
      const user = users.find(u => u.id === id)!;
      return new DeactivateUserCommand(user);
    });
    
    const batchCommand = new BatchCommand(commands, 'æ‰¹é‡åœç”¨ç”¨æˆ·');
    await executeBatchCommand(batchCommand);
  };
  
  // æ‰¹é‡è®¾ç½®ç®¡ç†å‘˜
  const handleBatchSetAdmin = async () => {
    if (selectedRowKeys.length === 0) {
      message.warning('è¯·å…ˆé€‰æ‹©ç”¨æˆ·');
      return;
    }
    
    Modal.confirm({
      title: 'ç¡®è®¤æ“ä½œ',
      content: `ç¡®å®šè¦å°† ${selectedRowKeys.length} ä¸ªç”¨æˆ·è®¾ç½®ä¸ºç®¡ç†å‘˜å—ï¼Ÿ`,
      onOk: async () => {
        const commands = selectedRowKeys.map(id => {
          const user = users.find(u => u.id === id)!;
          return new SetAdminCommand(user);
        });
        
        const batchCommand = new BatchCommand(commands, 'æ‰¹é‡è®¾ç½®ç®¡ç†å‘˜');
        await executeBatchCommand(batchCommand);
      },
    });
  };
  
  // æ‰§è¡Œæ‰¹é‡å‘½ä»¤
  const executeBatchCommand = async (command: BatchCommand) => {
    setIsExecuting(true);
    setProgress(0);
    
    try {
      // æ¨¡æ‹Ÿè¿›åº¦æ›´æ–°
      const interval = setInterval(() => {
        setProgress(command.getProgress());
      }, 100);
      
      await command.execute();
      
      clearInterval(interval);
      setProgress(100);
      
      refreshTable();
      setLastCommand(command);
      setSelectedRowKeys([]);
      
      message.success(command.getDescription() + ' - æ‰§è¡ŒæˆåŠŸ');
    } catch (error) {
      message.error('æ‰¹é‡æ“ä½œå¤±è´¥ï¼Œå·²è‡ªåŠ¨å›æ»š');
      refreshTable();
    } finally {
      setIsExecuting(false);
      setTimeout(() => setProgress(0), 1000);
    }
  };
  
  // æ’¤é”€ä¸Šæ¬¡æ“ä½œ
  const handleUndo = async () => {
    if (!lastCommand) {
      message.warning('æ²¡æœ‰å¯æ’¤é”€çš„æ“ä½œ');
      return;
    }
    
    setIsExecuting(true);
    
    try {
      await lastCommand.undo();
      refreshTable();
      setLastCommand(null);
      message.success('å·²æ’¤é”€æ“ä½œ');
    } catch (error) {
      message.error('æ’¤é”€å¤±è´¥');
    } finally {
      setIsExecuting(false);
    }
  };
  
  // è¡¨æ ¼åˆ—
  const columns = [
    { title: 'ID', dataIndex: 'id', key: 'id' },
    { title: 'å§“å', dataIndex: 'name', key: 'name' },
    {
      title: 'çŠ¶æ€',
      dataIndex: 'status',
      key: 'status',
      render: (status: string) => (
        <Tag color={status === 'active' ? 'green' : 'default'}>
          {status === 'active' ? 'æ¿€æ´»' : 'åœç”¨'}
        </Tag>
      ),
    },
    {
      title: 'è§’è‰²',
      dataIndex: 'role',
      key: 'role',
      render: (role: string) => (
        <Tag color={role === 'admin' ? 'red' : 'blue'}>
          {role === 'admin' ? 'ç®¡ç†å‘˜' : 'æ™®é€šç”¨æˆ·'}
        </Tag>
      ),
    },
  ];
  
  return (
    <div style={{ padding: 24, backgroundColor: '#f0f2f5', minHeight: '100vh' }}>
      <Card
        title="ğŸ‘¥ æ‰¹é‡æ“ä½œç³»ç»Ÿï¼ˆå‘½ä»¤æ¨¡å¼ + äº‹åŠ¡ï¼‰"
        style={{ maxWidth: 1000, margin: '0 auto' }}
      >
        {/* æ“ä½œæŒ‰é’® */}
        <Card type="inner" style={{ marginBottom: 16 }}>
          <Space wrap>
            <Button
              type="primary"
              icon={<PlayCircleOutlined />}
              onClick={handleBatchActivate}
              disabled={isExecuting || selectedRowKeys.length === 0}
            >
              æ‰¹é‡æ¿€æ´»
            </Button>
            <Button
              icon={<PlayCircleOutlined />}
              onClick={handleBatchDeactivate}
              disabled={isExecuting || selectedRowKeys.length === 0}
            >
              æ‰¹é‡åœç”¨
            </Button>
            <Button
              danger
              icon={<PlusOutlined />}
              onClick={handleBatchSetAdmin}
              disabled={isExecuting || selectedRowKeys.length === 0}
            >
              æ‰¹é‡è®¾ç½®ç®¡ç†å‘˜
            </Button>
            
            <div style={{ width: 1, height: 30, backgroundColor: '#d9d9d9' }} />
            
            <Button
              icon={<RollbackOutlined />}
              onClick={handleUndo}
              disabled={isExecuting || !lastCommand}
            >
              æ’¤é”€ä¸Šæ¬¡æ“ä½œ
            </Button>
            
            {selectedRowKeys.length > 0 && (
              <Tag color="blue">å·²é€‰æ‹© {selectedRowKeys.length} ä¸ªç”¨æˆ·</Tag>
            )}
          </Space>
          
          {isExecuting && progress > 0 && (
            <div style={{ marginTop: 16 }}>
              <Progress percent={Math.round(progress)} status="active" />
            </div>
          )}
        </Card>
        
        {/* ç”¨æˆ·è¡¨æ ¼ */}
        <Table
          rowSelection={{
            selectedRowKeys,
            onChange: setSelectedRowKeys,
          }}
          dataSource={users}
          columns={columns}
          rowKey="id"
          pagination={false}
        />
        
        {/* è¯´æ˜ */}
        <Card type="inner" title="ğŸ“‹ å‘½ä»¤æ¨¡å¼è¯´æ˜" style={{ marginTop: 16 }}>
          <ul style={{ margin: 0, paddingLeft: 20 }}>
            <li>âœ… <strong>BatchCommand</strong> æ˜¯æ‰¹é‡å‘½ä»¤ï¼Œç»„åˆå¤šä¸ªå‘½ä»¤ä¸€èµ·æ‰§è¡Œ</li>
            <li>âœ… æ”¯æŒäº‹åŠ¡ç‰¹æ€§ï¼šå…¨éƒ¨æˆåŠŸæˆ–å…¨éƒ¨å›æ»š</li>
            <li>âœ… æ‰§è¡Œå¤±è´¥æ—¶è‡ªåŠ¨è°ƒç”¨ undo() å›æ»šæ‰€æœ‰å·²æ‰§è¡Œçš„å‘½ä»¤</li>
            <li>âœ… æ”¯æŒæ’¤é”€ä¸Šæ¬¡æ‰¹é‡æ“ä½œ</li>
            <li>âœ… å¼‚æ­¥å‘½ä»¤æ‰§è¡Œï¼Œå¸¦è¿›åº¦æç¤º</li>
          </ul>
        </Card>
      </Card>
    </div>
  );
};

export default BatchOperationSystem;
```

## æ¨¡å¼æ€»ç»“

### âœ… ä¼˜ç‚¹

1. **è§£è€¦è¯·æ±‚ä¸æ‰§è¡Œ**ï¼šè°ƒç”¨è€…ä¸éœ€è¦çŸ¥é“å‘½ä»¤çš„å…·ä½“å®ç°
2. **æ”¯æŒæ’¤é”€/é‡åš**ï¼šæ¯ä¸ªå‘½ä»¤å°è£…äº†æ‰§è¡Œå’Œæ’¤é”€é€»è¾‘
3. **æ˜“äºæ‰©å±•**ï¼šæ–°å¢å‘½ä»¤åªéœ€å®ç° Command æ¥å£
4. **æ”¯æŒå®å‘½ä»¤**ï¼šå¯ä»¥ç»„åˆå¤šä¸ªå‘½ä»¤æ‰¹é‡æ‰§è¡Œ
5. **å‘½ä»¤å¯å­˜å‚¨**ï¼šå‘½ä»¤å¯¹è±¡å¯ä»¥è¢«åºåˆ—åŒ–ã€å­˜å‚¨ã€ä¼ è¾“
6. **æ”¯æŒé˜Ÿåˆ—**ï¼šå‘½ä»¤å¯ä»¥æ’é˜Ÿã€å»¶è¿Ÿæ‰§è¡Œ

### âŒ ç¼ºç‚¹

1. **ç±»æ•°é‡å¢åŠ **ï¼šæ¯ä¸ªæ“ä½œéƒ½è¦åˆ›å»ºä¸€ä¸ªå‘½ä»¤ç±»
2. **å¢åŠ å¤æ‚åº¦**ï¼šç®€å•æ“ä½œä½¿ç”¨å‘½ä»¤æ¨¡å¼å¯èƒ½è¿‡åº¦è®¾è®¡
3. **å†…å­˜å¼€é”€**ï¼šå­˜å‚¨å¤§é‡å‘½ä»¤å†å²ä¼šå ç”¨å†…å­˜

### ğŸ¯ é€‚ç”¨åœºæ™¯

å‘½ä»¤æ¨¡å¼ç‰¹åˆ«é€‚åˆä»¥ä¸‹å‰ç«¯åœºæ™¯ï¼š

| åœºæ™¯ | è¯´æ˜ | å…¸å‹å®ç° |
|------|------|---------|
| **æ’¤é”€/é‡åš** | ç¼–è¾‘å™¨ã€ç”»æ¿ã€è¡¨å• | æ–‡æœ¬ç¼–è¾‘å™¨ã€å›¾å½¢ç¼–è¾‘å™¨ |
| **å¿«æ·é”®ç³»ç»Ÿ** | é”®ç›˜å‘½ä»¤æ˜ å°„ | IDEã€ä»£ç ç¼–è¾‘å™¨ |
| **æ‰¹é‡æ“ä½œ** | å¤šä¸ªæ“ä½œç»„åˆæ‰§è¡Œ | ç”¨æˆ·ç®¡ç†ã€æ•°æ®å¤„ç† |
| **äº‹åŠ¡ç®¡ç†** | å…¨éƒ¨æˆåŠŸæˆ–å…¨éƒ¨å›æ»š | æ•°æ®åŒæ­¥ã€æ‰¹é‡æäº¤ |
| **æ“ä½œå†å²** | è®°å½•å’Œé‡æ”¾æ“ä½œ | è°ƒè¯•å·¥å…·ã€æ“ä½œå®¡è®¡ |
| **å»¶è¿Ÿæ‰§è¡Œ** | å‘½ä»¤æ’é˜Ÿã€å®šæ—¶æ‰§è¡Œ | ä»»åŠ¡é˜Ÿåˆ—ã€å®šæ—¶ä»»åŠ¡ |
| **å®å‘½ä»¤** | å½•åˆ¶æ“ä½œåºåˆ— | è‡ªåŠ¨åŒ–è„šæœ¬ã€æ‰¹å¤„ç† |

### ğŸ¤” ä»€ä¹ˆæ—¶å€™è¯¥ç”¨å‘½ä»¤æ¨¡å¼ï¼Ÿ

**ä¸‰ä¸ªåˆ¤æ–­æ ‡å‡†ï¼š**

1. **éœ€è¦æ’¤é”€/é‡åšåŠŸèƒ½å—ï¼Ÿ**
   - ç”¨æˆ·æ“ä½œéœ€è¦æ”¯æŒæ’¤é”€

2. **éœ€è¦è®°å½•æ“ä½œå†å²å—ï¼Ÿ**
   - æ“ä½œæ—¥å¿—ã€å®¡è®¡ã€é‡æ”¾

3. **éœ€è¦æ‰¹é‡æ‰§è¡Œæ“ä½œå—ï¼Ÿ**
   - å®å‘½ä»¤ã€äº‹åŠ¡ã€é˜Ÿåˆ—

**å¿«é€Ÿå†³ç­–æ ‘ï¼š**

```
éœ€è¦æ’¤é”€/é‡åšåŠŸèƒ½å—ï¼Ÿ
    â”œâ”€ æ˜¯ â†’ æ“ä½œå¤æ‚ï¼ˆéš¾ä»¥ç›´æ¥æ¢å¤ï¼‰å—ï¼Ÿ
    â”‚        â”œâ”€ æ˜¯ â†’ âœ… ç”¨å‘½ä»¤æ¨¡å¼ï¼
    â”‚        â””â”€ å¦ â†’ ğŸ¤” è€ƒè™‘å¤‡å¿˜å½•æ¨¡å¼
    â””â”€ å¦ â†’ éœ€è¦è®°å½•æ“ä½œå†å²/æ‰¹é‡æ‰§è¡Œå—ï¼Ÿ
             â”œâ”€ æ˜¯ â†’ âœ… ç”¨å‘½ä»¤æ¨¡å¼ï¼
             â””â”€ å¦ â†’ âŒ ä¸éœ€è¦
```

### ğŸ†š å‘½ä»¤æ¨¡å¼ vs å¤‡å¿˜å½•æ¨¡å¼

| ç‰¹å¾ | å‘½ä»¤æ¨¡å¼ | å¤‡å¿˜å½•æ¨¡å¼ |
|------|---------|-----------|
| **ä¿å­˜å†…å®¹** | æ“ä½œå‘½ä»¤ | å¯¹è±¡çŠ¶æ€å¿«ç…§ |
| **æ’¤é”€æ–¹å¼** | æ‰§è¡Œåå‘å‘½ä»¤ï¼ˆundoï¼‰ | æ¢å¤çŠ¶æ€å¿«ç…§ |
| **å†…å­˜å ç”¨** | è¾ƒå°ï¼ˆåªè®°å½•æ“ä½œï¼‰ | è¾ƒå¤§ï¼ˆä¿å­˜å®Œæ•´çŠ¶æ€ï¼‰ |
| **é€‚ç”¨åœºæ™¯** | æ“ä½œç®€å•ã€åå‘å®¹æ˜“ | çŠ¶æ€å¤æ‚ã€åå‘å›°éš¾ |
| **å…¸å‹åº”ç”¨** | æ–‡æœ¬æ’å…¥/åˆ é™¤ | å¯Œæ–‡æœ¬ç¼–è¾‘å™¨ã€ç”»æ¿ |
| **å…¶ä»–åŠŸèƒ½** | æ”¯æŒé˜Ÿåˆ—ã€å®å‘½ä»¤ã€é‡æ”¾ | ä¸»è¦ç”¨äºçŠ¶æ€æ¢å¤ |

**ä½•æ—¶é€‰æ‹©ï¼š**
- **å‘½ä»¤æ¨¡å¼**ï¼šæ“ä½œæœ¬èº«å°±å¾ˆè½»é‡ï¼ˆå¦‚æ’å…¥å­—ç¬¦ã€ç§»åŠ¨ä½ç½®ï¼‰ï¼Œå®¹æ˜“å®ç°åå‘æ“ä½œ
- **å¤‡å¿˜å½•æ¨¡å¼**ï¼šçŠ¶æ€å¤æ‚ï¼ˆå¦‚æ•´ä¸ªæ–‡æ¡£ã€ç”»å¸ƒçŠ¶æ€ï¼‰ï¼Œç›´æ¥ä¿å­˜å¿«ç…§æ›´ç®€å•

**ä¸¤è€…ç»“åˆï¼š**

```typescript
// ç»„åˆä½¿ç”¨ï¼šå‘½ä»¤æ¨¡å¼ + å¤‡å¿˜å½•æ¨¡å¼
class ComplexCommand implements Command {
  private memento: Memento; // ä¿å­˜æ‰§è¡Œå‰çš„çŠ¶æ€å¿«ç…§
  
  execute() {
    this.memento = this.receiver.createMemento(); // ä¿å­˜çŠ¶æ€
    // æ‰§è¡Œå¤æ‚æ“ä½œ...
  }
  
  undo() {
    this.receiver.restoreMemento(this.memento); // æ¢å¤çŠ¶æ€
  }
}
```

### ğŸ’¡ å‰ç«¯æ¡†æ¶ä¸­çš„å‘½ä»¤æ¨¡å¼

#### 1. Redux çš„ Actionï¼ˆç±»å‘½ä»¤æ¨¡å¼ï¼‰

```typescript
// Action ç±»ä¼¼äºå‘½ä»¤å¯¹è±¡
const incrementAction = { type: 'INCREMENT', payload: 1 };
const decrementAction = { type: 'DECREMENT', payload: 1 };

// Dispatch ç±»ä¼¼äºå‘½ä»¤è°ƒç”¨è€…
dispatch(incrementAction);
```

#### 2. Vuex çš„ Mutation

```typescript
// Mutation ç±»ä¼¼äºå‘½ä»¤
mutations: {
  increment(state, payload) {
    state.count += payload;
  }
}

// Commit ç±»ä¼¼äºå‘½ä»¤æ‰§è¡Œ
store.commit('increment', 1);
```

#### 3. åŸç”Ÿ History API

```typescript
// pushState å°±åƒæ‰§è¡Œä¸€ä¸ªå‘½ä»¤
history.pushState({ page: 1 }, "title", "?page=1");

// back/forward å°±åƒæ’¤é”€/é‡åš
history.back();  // æ’¤é”€
history.forward();  // é‡åš
```

---

## ğŸ’¬ å°ç»“

å‘½ä»¤æ¨¡å¼å°±åƒæŠŠæ“ä½œè£…è¿›"èƒ¶å›Š"ï¼Œä½ ä¸éœ€è¦çŸ¥é“èƒ¶å›Šé‡Œè£…çš„ä»€ä¹ˆè¯ï¼Œåªéœ€è¦åƒä¸‹å»å°±è¡Œã€‚è€Œä¸”èƒ¶å›Šå¯ä»¥è¢«å­˜å‚¨ã€ä¼ é€’ã€æ’¤é”€ï¼Œç”šè‡³ç»„åˆæˆ"å¥—è£…"ã€‚

åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œå‘½ä»¤æ¨¡å¼èƒ½è®©ä½ çš„ä»£ç ï¼š
- ä»"æ“ä½œå’Œæ’¤é”€é€»è¾‘è€¦åˆ"å˜æˆ"æ¯ä¸ªå‘½ä»¤è‡ªå·±ç®¡ç†æ’¤é”€"
- ä»"éš¾ä»¥æ‰©å±•"å˜æˆ"æ–°å¢å‘½ä»¤é›¶å½±å“"
- ä»"æ— æ³•æ‰¹é‡æ‰§è¡Œ"å˜æˆ"è½»æ¾ç»„åˆå®å‘½ä»¤"

**è®°ä½ä¸€å¥è¯**ï¼šå½“ä½ éœ€è¦æ’¤é”€/é‡åšã€è®°å½•æ“ä½œå†å²ã€æˆ–è€…æ‰¹é‡æ‰§è¡Œæ“ä½œæ—¶ï¼Œå°±è¯¥è€ƒè™‘å‘½ä»¤æ¨¡å¼äº†ï¼

---

> ğŸ’¡ **æ€è€ƒé¢˜**ï¼š
> 1. å‘½ä»¤æ¨¡å¼å’Œå¤‡å¿˜å½•æ¨¡å¼åœ¨å®ç°æ’¤é”€åŠŸèƒ½æ—¶æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿå¦‚ä½•é€‰æ‹©ï¼Ÿ
> 2. Redux çš„ Action æ˜¯å‘½ä»¤æ¨¡å¼å—ï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ
> 3. å¦‚ä½•å®ç°ä¸€ä¸ªæ”¯æŒ"æ’¤é”€åˆ°ä»»æ„å†å²ç‚¹"çš„å‘½ä»¤ç³»ç»Ÿï¼Ÿ

---

> ğŸ“š **ç›¸å…³æ¨¡å¼**ï¼š
> - å¤‡å¿˜å½•æ¨¡å¼ï¼ˆMementoï¼‰ï¼šä¿å­˜çŠ¶æ€å¿«ç…§ï¼Œå¯ä¸å‘½ä»¤æ¨¡å¼ç»“åˆ
> - ç»„åˆæ¨¡å¼ï¼ˆCompositeï¼‰ï¼šç”¨äºå®ç°å®å‘½ä»¤
> - è´£ä»»é“¾æ¨¡å¼ï¼ˆChain of Responsibilityï¼‰ï¼šå‘½ä»¤å¯ä»¥åœ¨è´£ä»»é“¾ä¸­ä¼ é€’
> - åŸå‹æ¨¡å¼ï¼ˆPrototypeï¼‰ï¼šç”¨äºå¤åˆ¶å‘½ä»¤å¯¹è±¡

