# è¿­ä»£å™¨æ¨¡å¼ï¼ˆIterator Patternï¼‰

> ã€Šå‰ç«¯è®¾è®¡æ¨¡å¼å®æˆ˜æ‰‹å†Œã€‹ç³»åˆ— - ç¬¬å…­ç« 

---

## ä¸€å¥è¯å¤§ç™½è¯

**å°±åƒçœ‹ç”µè§†æ¢å°**ï¼šä½ ä¸éœ€è¦çŸ¥é“ç”µè§†ä¿¡å·æ€ä¹ˆä¼ è¾“ã€é¢‘é“åˆ—è¡¨å­˜åœ¨å“ªï¼Œåªéœ€è¦æŒ‰é¥æ§å™¨çš„"ä¸Šä¸€å°"å’Œ"ä¸‹ä¸€å°"æŒ‰é’®ï¼Œå°±èƒ½éå†æ‰€æœ‰é¢‘é“ã€‚é¥æ§å™¨å°±æ˜¯è¿­ä»£å™¨ï¼Œå®ƒéšè—äº†é¢‘é“åˆ—è¡¨çš„å¤æ‚æ€§ã€‚

## å‰ç«¯ç—›ç‚¹

æƒ³è±¡ä¸€ä¸‹ï¼Œä½ è¦éå†ä¸€ä¸ªå¤æ‚çš„æ ‘å½¢ç»“æ„ï¼ˆå¦‚ç»„ç»‡æ¶æ„ï¼‰ï¼Œä¸åŒçš„éå†æ–¹å¼éœ€è¦å†™ä¸åŒçš„ä»£ç ï¼š

```typescript
// âŒ æ²¡æœ‰ä½¿ç”¨è¿­ä»£å™¨æ¨¡å¼çš„ä»£ç ï¼šéå†é€»è¾‘æ•£è½å„å¤„
class OrgTree {
  private root: TreeNode;
  
  // æ·±åº¦ä¼˜å…ˆéå†
  traverseDFS(callback: (node: TreeNode) => void) {
    const stack = [this.root];
    while (stack.length > 0) {
      const node = stack.pop()!;
      callback(node);
      stack.push(...node.children.reverse());
    }
  }
  
  // å¹¿åº¦ä¼˜å…ˆéå†
  traverseBFS(callback: (node: TreeNode) => void) {
    const queue = [this.root];
    while (queue.length > 0) {
      const node = queue.shift()!;
      callback(node);
      queue.push(...node.children);
    }
  }
  
  // åªéå†å¶å­èŠ‚ç‚¹
  traverseLeaves(callback: (node: TreeNode) => void) {
    const stack = [this.root];
    while (stack.length > 0) {
      const node = stack.pop()!;
      if (node.children.length === 0) {
        callback(node);
      } else {
        stack.push(...node.children.reverse());
      }
    }
  }
  
  // æ¯ç§éå†æ–¹å¼éƒ½è¦é‡æ–°å®ç°ä¸€éé€»è¾‘ï¼
  // æ— æ³•æš‚åœã€æ¢å¤ã€è·³è¿‡...
}
```

**è¿™æ®µä»£ç çš„é—®é¢˜ï¼š**
1. ğŸ”„ **éå†é€»è¾‘é‡å¤**ï¼šæ¯ç§éå†æ–¹å¼éƒ½è¦é‡å†™ä¸€éï¼Œä»£ç å†—ä½™
2. ğŸ”’ **æ— æ³•æ§åˆ¶**ï¼šæ— æ³•æš‚åœã€æ¢å¤ã€è·³è¿‡éå†
3. ğŸ§© **ç´§è€¦åˆ**ï¼šéå†é€»è¾‘å’Œæ•°æ®ç»“æ„è€¦åˆï¼Œéš¾ä»¥å¤ç”¨
4. ğŸš« **æ— æ³•ç»Ÿä¸€æ¥å£**ï¼šä¸åŒæ•°æ®ç»“æ„çš„éå†æ–¹å¼ä¸åŒï¼Œæ— æ³•ç»Ÿä¸€

## æ¨¡å¼æ ¸å¿ƒæ¦‚å¿µ

**è¿­ä»£å™¨æ¨¡å¼çš„æœ¬è´¨**ï¼šæä¾›ä¸€ç§æ–¹æ³•é¡ºåºè®¿é—®é›†åˆå¯¹è±¡ä¸­çš„å…ƒç´ ï¼Œè€Œä¸æš´éœ²å…¶å†…éƒ¨è¡¨ç¤ºã€‚

**ä¸¤ä¸ªæ ¸å¿ƒè§’è‰²ï¼š**
- **è¿­ä»£å™¨ï¼ˆIteratorï¼‰**ï¼šå®šä¹‰è®¿é—®å’Œéå†å…ƒç´ çš„æ¥å£ï¼ˆnextã€hasNextã€currentï¼‰
- **é›†åˆï¼ˆAggregateï¼‰**ï¼šå®šä¹‰åˆ›å»ºè¿­ä»£å™¨çš„æ¥å£ï¼Œè¿”å›ä¸€ä¸ªè¿­ä»£å™¨å¯¹è±¡

**ç±»æ¯”**ï¼š
- ğŸ“º **ç”µè§†é¥æ§å™¨**ï¼šé¥æ§å™¨ï¼ˆè¿­ä»£å™¨ï¼‰â† é¢‘é“åˆ—è¡¨ï¼ˆé›†åˆï¼‰ï¼ŒæŒ‰é”®åˆ‡æ¢é¢‘é“
- ğŸ“– **å›¾ä¹¦ç›®å½•**ï¼šç›®å½•ï¼ˆè¿­ä»£å™¨ï¼‰â† å›¾ä¹¦é¦†ï¼ˆé›†åˆï¼‰ï¼ŒæŒ‰é¡µç æŸ¥æ‰¾ä¹¦ç±
- ğŸµ **éŸ³ä¹æ’­æ”¾å™¨**ï¼šæ’­æ”¾å™¨ï¼ˆè¿­ä»£å™¨ï¼‰â† æ’­æ”¾åˆ—è¡¨ï¼ˆé›†åˆï¼‰ï¼Œä¸Šä¸€é¦–/ä¸‹ä¸€é¦–

**æ ¸å¿ƒæ–¹æ³•ï¼š**

```typescript
interface Iterator<T> {
  next(): T;           // è¿”å›ä¸‹ä¸€ä¸ªå…ƒç´ 
  hasNext(): boolean;  // æ˜¯å¦è¿˜æœ‰ä¸‹ä¸€ä¸ªå…ƒç´ 
  current(): T;        // è¿”å›å½“å‰å…ƒç´ 
  reset(): void;       // é‡ç½®åˆ°å¼€å§‹ä½ç½®
}
```

## å‰ç«¯å®æˆ˜æ¡ˆä¾‹

### åœºæ™¯ä¸€ï¼šæ ‘å½¢æ•°æ®éå†å™¨ï¼ˆç»„ç»‡æ¶æ„æµè§ˆï¼‰

æˆ‘ä»¬è¦å®ç°ä¸€ä¸ªç»„ç»‡æ¶æ„æµè§ˆå™¨ï¼Œæ”¯æŒå¤šç§éå†æ–¹å¼ï¼š

```typescript
// âœ… ä½¿ç”¨è¿­ä»£å™¨æ¨¡å¼é‡æ„

import React, { useState } from 'react';
import { Card, Button, Space, Tree, Tag, Radio, Alert } from 'antd';
import {
  PlayCircleOutlined,
  PauseCircleOutlined,
  ReloadOutlined,
  StepForwardOutlined,
} from '@ant-design/icons';

// 1ï¸âƒ£ æ ‘èŠ‚ç‚¹å®šä¹‰
interface TreeNode {
  id: string;
  name: string;
  position: string;
  children: TreeNode[];
}

// 2ï¸âƒ£ è¿­ä»£å™¨æ¥å£
interface Iterator<T> {
  next(): T | null;
  hasNext(): boolean;
  current(): T | null;
  reset(): void;
}

// 3ï¸âƒ£ æ·±åº¦ä¼˜å…ˆè¿­ä»£å™¨
class DFSIterator implements Iterator<TreeNode> {
  private stack: TreeNode[];
  private visited: Set<string>;
  private currentNode: TreeNode | null;
  
  constructor(root: TreeNode) {
    this.stack = [root];
    this.visited = new Set();
    this.currentNode = null;
  }
  
  next(): TreeNode | null {
    if (!this.hasNext()) return null;
    
    const node = this.stack.pop()!;
    this.visited.add(node.id);
    this.currentNode = node;
    
    // å…ˆå³åå·¦å…¥æ ˆï¼Œä¿è¯å…ˆå·¦åå³å‡ºæ ˆ
    for (let i = node.children.length - 1; i >= 0; i--) {
      if (!this.visited.has(node.children[i].id)) {
        this.stack.push(node.children[i]);
      }
    }
    
    return node;
  }
  
  hasNext(): boolean {
    return this.stack.length > 0;
  }
  
  current(): TreeNode | null {
    return this.currentNode;
  }
  
  reset(): void {
    // éœ€è¦é‡æ–°åˆå§‹åŒ–ï¼Œè¿™é‡Œç®€åŒ–å¤„ç†
    this.stack = [];
    this.visited.clear();
    this.currentNode = null;
  }
}

// 4ï¸âƒ£ å¹¿åº¦ä¼˜å…ˆè¿­ä»£å™¨
class BFSIterator implements Iterator<TreeNode> {
  private queue: TreeNode[];
  private visited: Set<string>;
  private currentNode: TreeNode | null;
  
  constructor(root: TreeNode) {
    this.queue = [root];
    this.visited = new Set();
    this.currentNode = null;
  }
  
  next(): TreeNode | null {
    if (!this.hasNext()) return null;
    
    const node = this.queue.shift()!;
    this.visited.add(node.id);
    this.currentNode = node;
    
    // å°†å­èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—
    for (const child of node.children) {
      if (!this.visited.has(child.id)) {
        this.queue.push(child);
      }
    }
    
    return node;
  }
  
  hasNext(): boolean {
    return this.queue.length > 0;
  }
  
  current(): TreeNode | null {
    return this.currentNode;
  }
  
  reset(): void {
    this.queue = [];
    this.visited.clear();
    this.currentNode = null;
  }
}

// 5ï¸âƒ£ å¶å­èŠ‚ç‚¹è¿­ä»£å™¨ï¼ˆåªéå†å¶å­èŠ‚ç‚¹ï¼‰
class LeafIterator implements Iterator<TreeNode> {
  private stack: TreeNode[];
  private currentNode: TreeNode | null;
  
  constructor(root: TreeNode) {
    this.stack = [root];
    this.currentNode = null;
  }
  
  next(): TreeNode | null {
    while (this.stack.length > 0) {
      const node = this.stack.pop()!;
      
      // å¦‚æœæ˜¯å¶å­èŠ‚ç‚¹ï¼Œè¿”å›
      if (node.children.length === 0) {
        this.currentNode = node;
        return node;
      }
      
      // å¦åˆ™å°†å­èŠ‚ç‚¹å…¥æ ˆ
      for (let i = node.children.length - 1; i >= 0; i--) {
        this.stack.push(node.children[i]);
      }
    }
    
    return null;
  }
  
  hasNext(): boolean {
    // é¢„æ£€æŸ¥æ ˆä¸­æ˜¯å¦è¿˜æœ‰å¶å­èŠ‚ç‚¹
    const tempStack = [...this.stack];
    while (tempStack.length > 0) {
      const node = tempStack.pop()!;
      if (node.children.length === 0) return true;
      tempStack.push(...node.children);
    }
    return false;
  }
  
  current(): TreeNode | null {
    return this.currentNode;
  }
  
  reset(): void {
    this.stack = [];
    this.currentNode = null;
  }
}

// 6ï¸âƒ£ æŒ‰å±‚çº§è¿­ä»£å™¨ï¼ˆå…ˆéå†å½“å‰å±‚ï¼Œå†éå†ä¸‹ä¸€å±‚ï¼‰
class LevelOrderIterator implements Iterator<TreeNode> {
  private queue: TreeNode[];
  private currentNode: TreeNode | null;
  private levels: TreeNode[][];
  private currentLevel: number;
  private currentIndex: number;
  
  constructor(root: TreeNode) {
    this.queue = [root];
    this.currentNode = null;
    this.levels = [];
    this.currentLevel = 0;
    this.currentIndex = 0;
    
    // é¢„å…ˆæ„å»ºå±‚çº§ç»“æ„
    this.buildLevels(root);
  }
  
  private buildLevels(root: TreeNode): void {
    const queue: Array<{ node: TreeNode; level: number }> = [{ node: root, level: 0 }];
    
    while (queue.length > 0) {
      const { node, level } = queue.shift()!;
      
      if (!this.levels[level]) {
        this.levels[level] = [];
      }
      this.levels[level].push(node);
      
      for (const child of node.children) {
        queue.push({ node: child, level: level + 1 });
      }
    }
  }
  
  next(): TreeNode | null {
    if (!this.hasNext()) return null;
    
    const node = this.levels[this.currentLevel][this.currentIndex];
    this.currentNode = node;
    
    this.currentIndex++;
    if (this.currentIndex >= this.levels[this.currentLevel].length) {
      this.currentLevel++;
      this.currentIndex = 0;
    }
    
    return node;
  }
  
  hasNext(): boolean {
    return this.currentLevel < this.levels.length;
  }
  
  current(): TreeNode | null {
    return this.currentNode;
  }
  
  reset(): void {
    this.currentLevel = 0;
    this.currentIndex = 0;
    this.currentNode = null;
  }
}

// 7ï¸âƒ£ é›†åˆç±»ï¼šç»„ç»‡æ¶æ„
class OrganizationTree {
  private root: TreeNode;
  
  constructor(root: TreeNode) {
    this.root = root;
  }
  
  // åˆ›å»ºä¸åŒç±»å‹çš„è¿­ä»£å™¨
  createDFSIterator(): Iterator<TreeNode> {
    return new DFSIterator(this.root);
  }
  
  createBFSIterator(): Iterator<TreeNode> {
    return new BFSIterator(this.root);
  }
  
  createLeafIterator(): Iterator<TreeNode> {
    return new LeafIterator(this.root);
  }
  
  createLevelIterator(): Iterator<TreeNode> {
    return new LevelOrderIterator(this.root);
  }
  
  getRoot(): TreeNode {
    return this.root;
  }
}

// 8ï¸âƒ£ React ç»„ä»¶
const OrgTreeIterator: React.FC = () => {
  // æ¨¡æ‹Ÿç»„ç»‡æ¶æ„æ•°æ®
  const orgData: TreeNode = {
    id: '1',
    name: 'å¼ ä¸‰',
    position: 'CEO',
    children: [
      {
        id: '2',
        name: 'æå››',
        position: 'CTO',
        children: [
          { id: '5', name: 'ç‹äº”', position: 'å‰ç«¯Leader', children: [
            { id: '8', name: 'èµµå…­', position: 'å‰ç«¯å·¥ç¨‹å¸ˆ', children: [] },
            { id: '9', name: 'é’±ä¸ƒ', position: 'å‰ç«¯å·¥ç¨‹å¸ˆ', children: [] },
          ]},
          { id: '6', name: 'å­™å…«', position: 'åç«¯Leader', children: [
            { id: '10', name: 'å‘¨ä¹', position: 'åç«¯å·¥ç¨‹å¸ˆ', children: [] },
          ]},
        ],
      },
      {
        id: '3',
        name: 'å´ä¹',
        position: 'CFO',
        children: [
          { id: '7', name: 'éƒ‘å', position: 'è´¢åŠ¡ç»ç†', children: [
            { id: '11', name: 'å†¯åä¸€', position: 'ä¼šè®¡', children: [] },
            { id: '12', name: 'é™ˆåäºŒ', position: 'å‡ºçº³', children: [] },
          ]},
        ],
      },
      {
        id: '4',
        name: 'è¤šåä¸‰',
        position: 'CMO',
        children: [],
      },
    ],
  };
  
  const [orgTree] = useState(() => new OrganizationTree(orgData));
  const [iteratorType, setIteratorType] = useState<'dfs' | 'bfs' | 'leaf' | 'level'>('dfs');
  const [iterator, setIterator] = useState<Iterator<TreeNode> | null>(null);
  const [traversalPath, setTraversalPath] = useState<TreeNode[]>([]);
  const [currentNode, setCurrentNode] = useState<TreeNode | null>(null);
  const [isTraversing, setIsTraversing] = useState(false);
  const [isPaused, setIsPaused] = useState(false);
  
  // åˆ›å»ºè¿­ä»£å™¨
  const createIterator = (type: typeof iteratorType) => {
    let newIterator: Iterator<TreeNode>;
    
    switch (type) {
      case 'dfs':
        newIterator = orgTree.createDFSIterator();
        break;
      case 'bfs':
        newIterator = orgTree.createBFSIterator();
        break;
      case 'leaf':
        newIterator = orgTree.createLeafIterator();
        break;
      case 'level':
        newIterator = orgTree.createLevelIterator();
        break;
    }
    
    setIterator(newIterator);
    setTraversalPath([]);
    setCurrentNode(null);
    setIsTraversing(false);
    setIsPaused(false);
  };
  
  // åˆå§‹åŒ–è¿­ä»£å™¨
  React.useEffect(() => {
    createIterator(iteratorType);
  }, [iteratorType]);
  
  // è‡ªåŠ¨éå†
  React.useEffect(() => {
    if (!isTraversing || isPaused || !iterator) return;
    
    const timer = setTimeout(() => {
      if (iterator.hasNext()) {
        const node = iterator.next();
        if (node) {
          setCurrentNode(node);
          setTraversalPath(prev => [...prev, node]);
        }
      } else {
        setIsTraversing(false);
      }
    }, 800);
    
    return () => clearTimeout(timer);
  }, [isTraversing, isPaused, iterator, traversalPath]);
  
  // æ‰‹åŠ¨ä¸‹ä¸€æ­¥
  const handleNext = () => {
    if (!iterator || !iterator.hasNext()) return;
    
    const node = iterator.next();
    if (node) {
      setCurrentNode(node);
      setTraversalPath(prev => [...prev, node]);
    }
  };
  
  // å¼€å§‹è‡ªåŠ¨éå†
  const handleStart = () => {
    if (!iterator) return;
    setIsTraversing(true);
    setIsPaused(false);
  };
  
  // æš‚åœ
  const handlePause = () => {
    setIsPaused(!isPaused);
  };
  
  // é‡ç½®
  const handleReset = () => {
    createIterator(iteratorType);
  };
  
  // è½¬æ¢æ ‘æ•°æ®ä¸º Ant Design Tree ç»„ä»¶æ ¼å¼
  const convertToTreeData = (node: TreeNode): any => {
    const isInPath = traversalPath.some(n => n.id === node.id);
    const isCurrent = currentNode?.id === node.id;
    
    return {
      title: (
        <span>
          {node.name}
          {' '}
          <Tag color="blue" style={{ fontSize: 12 }}>
            {node.position}
          </Tag>
          {isInPath && (
            <Tag color={isCurrent ? 'green' : 'default'} style={{ fontSize: 12 }}>
              {isCurrent ? 'å½“å‰' : 'å·²è®¿é—®'}
            </Tag>
          )}
        </span>
      ),
      key: node.id,
      children: node.children.map(convertToTreeData),
    };
  };
  
  const iteratorTypes = [
    { value: 'dfs', label: 'æ·±åº¦ä¼˜å…ˆï¼ˆDFSï¼‰' },
    { value: 'bfs', label: 'å¹¿åº¦ä¼˜å…ˆï¼ˆBFSï¼‰' },
    { value: 'leaf', label: 'ä»…å¶å­èŠ‚ç‚¹' },
    { value: 'level', label: 'æŒ‰å±‚çº§éå†' },
  ];
  
  return (
    <div style={{ padding: 24, backgroundColor: '#f0f2f5', minHeight: '100vh' }}>
      <Card title="ğŸ¢ ç»„ç»‡æ¶æ„éå†å™¨ï¼ˆè¿­ä»£å™¨æ¨¡å¼ï¼‰" style={{ maxWidth: 1200, margin: '0 auto' }}>
        {/* æ§åˆ¶é¢æ¿ */}
        <Card type="inner" title="æ§åˆ¶é¢æ¿" style={{ marginBottom: 16 }}>
          <Space direction="vertical" style={{ width: '100%' }}>
            <div>
              <div style={{ marginBottom: 8 }}>é€‰æ‹©éå†æ–¹å¼ï¼š</div>
              <Radio.Group
                value={iteratorType}
                onChange={(e) => setIteratorType(e.target.value)}
                disabled={isTraversing && !isPaused}
              >
                {iteratorTypes.map(type => (
                  <Radio.Button key={type.value} value={type.value}>
                    {type.label}
                  </Radio.Button>
                ))}
              </Radio.Group>
            </div>
            
            <Space>
              <Button
                type="primary"
                icon={<PlayCircleOutlined />}
                onClick={handleStart}
                disabled={isTraversing || !iterator?.hasNext()}
              >
                è‡ªåŠ¨éå†
              </Button>
              <Button
                icon={<PauseCircleOutlined />}
                onClick={handlePause}
                disabled={!isTraversing}
              >
                {isPaused ? 'ç»§ç»­' : 'æš‚åœ'}
              </Button>
              <Button
                icon={<StepForwardOutlined />}
                onClick={handleNext}
                disabled={isTraversing && !isPaused || !iterator?.hasNext()}
              >
                ä¸‹ä¸€æ­¥
              </Button>
              <Button
                icon={<ReloadOutlined />}
                onClick={handleReset}
              >
                é‡ç½®
              </Button>
            </Space>
            
            <Alert
              message={
                <Space>
                  <span>è¿›åº¦ï¼š</span>
                  <Tag color="blue">{traversalPath.length} / {
                    iteratorType === 'leaf' ? 'å¶å­èŠ‚ç‚¹æ•°' : 'æ€»èŠ‚ç‚¹æ•°'
                  }</Tag>
                  {currentNode && (
                    <>
                      <span>å½“å‰ï¼š</span>
                      <Tag color="green">{currentNode.name} - {currentNode.position}</Tag>
                    </>
                  )}
                  {!iterator?.hasNext() && traversalPath.length > 0 && (
                    <Tag color="success">éå†å®Œæˆï¼</Tag>
                  )}
                </Space>
              }
              type="info"
            />
          </Space>
        </Card>
        
        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: 16 }}>
          {/* ç»„ç»‡æ¶æ„æ ‘ */}
          <Card type="inner" title="ç»„ç»‡æ¶æ„">
            <Tree
              treeData={[convertToTreeData(orgData)]}
              defaultExpandAll
              showLine
            />
          </Card>
          
          {/* éå†è·¯å¾„ */}
          <Card type="inner" title="éå†è·¯å¾„">
            <div style={{ maxHeight: 400, overflow: 'auto' }}>
              {traversalPath.length === 0 ? (
                <div style={{ textAlign: 'center', color: '#999', padding: 40 }}>
                  ç‚¹å‡»"è‡ªåŠ¨éå†"æˆ–"ä¸‹ä¸€æ­¥"å¼€å§‹éå†
                </div>
              ) : (
                traversalPath.map((node, index) => (
                  <div
                    key={`${node.id}-${index}`}
                    style={{
                      padding: '8px 12px',
                      marginBottom: 8,
                      backgroundColor: node.id === currentNode?.id ? '#e6f7ff' : '#fafafa',
                      border: node.id === currentNode?.id ? '1px solid #1890ff' : '1px solid #d9d9d9',
                      borderRadius: 4,
                    }}
                  >
                    <Space>
                      <Tag color="blue">{index + 1}</Tag>
                      <span><strong>{node.name}</strong></span>
                      <Tag>{node.position}</Tag>
                    </Space>
                  </div>
                ))
              )}
            </div>
          </Card>
        </div>
        
        {/* è¯´æ˜ */}
        <Card type="inner" title="ğŸ“‹ è¿­ä»£å™¨æ¨¡å¼è¯´æ˜" style={{ marginTop: 16 }}>
          <ul style={{ margin: 0, paddingLeft: 20 }}>
            <li>âœ… <strong>DFSIteratorã€BFSIterator ç­‰</strong> æ˜¯è¿­ä»£å™¨ï¼Œå°è£…ä¸åŒçš„éå†ç®—æ³•</li>
            <li>âœ… <strong>OrganizationTree</strong> æ˜¯é›†åˆï¼Œæä¾›åˆ›å»ºè¿­ä»£å™¨çš„æ–¹æ³•</li>
            <li>âœ… ç»Ÿä¸€çš„æ¥å£ï¼ˆnextã€hasNextã€currentã€resetï¼‰è®©éå†é€»è¾‘å¯æ§</li>
            <li>âœ… æ”¯æŒæš‚åœã€æ¢å¤ã€å•æ­¥æ‰§è¡Œï¼Œéå†è¿‡ç¨‹å®Œå…¨å¯æ§</li>
            <li>âœ… ä¸åŒéå†æ–¹å¼ç‹¬ç«‹å®ç°ï¼Œæ˜“äºæ‰©å±•æ–°çš„éå†ç®—æ³•</li>
            <li>âœ… éå†é€»è¾‘ä¸æ•°æ®ç»“æ„åˆ†ç¦»ï¼Œç¬¦åˆå•ä¸€èŒè´£åŸåˆ™</li>
          </ul>
        </Card>
      </Card>
    </div>
  );
};

export default OrgTreeIterator;
```

#### ğŸ¯ ä½¿ç”¨è¿­ä»£å™¨æ¨¡å¼åçš„å¥½å¤„

1. **ç»Ÿä¸€æ¥å£**ï¼šæ‰€æœ‰è¿­ä»£å™¨éƒ½å®ç°ç›¸åŒæ¥å£ï¼Œä½¿ç”¨æ–¹å¼ä¸€è‡´
2. **å¯æ§éå†**ï¼šæ”¯æŒæš‚åœã€æ¢å¤ã€å•æ­¥æ‰§è¡Œ
3. **æ˜“äºæ‰©å±•**ï¼šæ–°å¢éå†æ–¹å¼åªéœ€å®ç° Iterator æ¥å£
4. **èŒè´£åˆ†ç¦»**ï¼šéå†é€»è¾‘å’Œæ•°æ®ç»“æ„ç‹¬ç«‹

---

### åœºæ™¯äºŒï¼šåˆ†é¡µæ•°æ®åŠ è½½å™¨ï¼ˆæ— é™æ»šåŠ¨ï¼‰

å®ç°ä¸€ä¸ªæ”¯æŒåˆ†é¡µçš„æ•°æ®åŠ è½½å™¨ï¼Œç”¨äºæ— é™æ»šåŠ¨åˆ—è¡¨ï¼š

```typescript
import React, { useState, useRef, useEffect } from 'react';
import { Card, List, Button, Spin, Avatar, Tag, Space } from 'antd';
import { ReloadOutlined, DownOutlined } from '@ant-design/icons';

// æ•°æ®é¡¹
interface DataItem {
  id: number;
  name: string;
  avatar: string;
  description: string;
  tags: string[];
}

// åˆ†é¡µè¿­ä»£å™¨
class PaginationIterator implements Iterator<DataItem[]> {
  private currentPage: number;
  private pageSize: number;
  private totalPages: number;
  private dataSource: DataItem[];
  private currentBatch: DataItem[] | null;
  
  constructor(dataSource: DataItem[], pageSize: number = 10) {
    this.dataSource = dataSource;
    this.pageSize = pageSize;
    this.currentPage = 0;
    this.totalPages = Math.ceil(dataSource.length / pageSize);
    this.currentBatch = null;
  }
  
  next(): DataItem[] | null {
    if (!this.hasNext()) return null;
    
    const start = this.currentPage * this.pageSize;
    const end = start + this.pageSize;
    this.currentBatch = this.dataSource.slice(start, end);
    this.currentPage++;
    
    return this.currentBatch;
  }
  
  hasNext(): boolean {
    return this.currentPage < this.totalPages;
  }
  
  current(): DataItem[] | null {
    return this.currentBatch;
  }
  
  reset(): void {
    this.currentPage = 0;
    this.currentBatch = null;
  }
  
  // è·³è½¬åˆ°æŒ‡å®šé¡µ
  jumpTo(page: number): DataItem[] | null {
    if (page < 0 || page >= this.totalPages) return null;
    
    this.currentPage = page;
    const start = page * this.pageSize;
    const end = start + this.pageSize;
    this.currentBatch = this.dataSource.slice(start, end);
    this.currentPage++;
    
    return this.currentBatch;
  }
  
  getTotalPages(): number {
    return this.totalPages;
  }
  
  getCurrentPage(): number {
    return this.currentPage;
  }
}

// React ç»„ä»¶
const InfiniteScrollList: React.FC = () => {
  // ç”Ÿæˆæ¨¡æ‹Ÿæ•°æ®
  const generateMockData = (count: number): DataItem[] => {
    return Array.from({ length: count }, (_, i) => ({
      id: i + 1,
      name: `ç”¨æˆ· ${i + 1}`,
      avatar: ['ğŸ‘¨', 'ğŸ‘©', 'ğŸ‘¦', 'ğŸ‘§', 'ğŸ§‘'][i % 5],
      description: `è¿™æ˜¯ç”¨æˆ· ${i + 1} çš„ä¸ªäººç®€ä»‹ï¼ŒåŒ…å«ä¸€äº›æœ‰è¶£çš„å†…å®¹...`,
      tags: ['æ ‡ç­¾1', 'æ ‡ç­¾2', 'æ ‡ç­¾3'].slice(0, (i % 3) + 1),
    }));
  };
  
  const [allData] = useState(() => generateMockData(100));
  const [iterator] = useState(() => new PaginationIterator(allData, 10));
  const [displayData, setDisplayData] = useState<DataItem[]>([]);
  const [loading, setLoading] = useState(false);
  const [hasMore, setHasMore] = useState(true);
  
  const containerRef = useRef<HTMLDivElement>(null);
  
  // åŠ è½½ä¸‹ä¸€é¡µ
  const loadMore = async () => {
    if (!iterator.hasNext() || loading) return;
    
    setLoading(true);
    
    // æ¨¡æ‹Ÿç½‘ç»œè¯·æ±‚å»¶è¿Ÿ
    await new Promise(resolve => setTimeout(resolve, 500));
    
    const nextBatch = iterator.next();
    if (nextBatch) {
      setDisplayData(prev => [...prev, ...nextBatch]);
    }
    
    setHasMore(iterator.hasNext());
    setLoading(false);
  };
  
  // é‡ç½®
  const handleReset = () => {
    iterator.reset();
    setDisplayData([]);
    setHasMore(true);
    loadMore();
  };
  
  // ç›‘å¬æ»šåŠ¨äº‹ä»¶ï¼ˆæ— é™æ»šåŠ¨ï¼‰
  useEffect(() => {
    const handleScroll = () => {
      const container = containerRef.current;
      if (!container) return;
      
      const { scrollTop, scrollHeight, clientHeight } = container;
      
      // æ»šåŠ¨åˆ°åº•éƒ¨æ—¶åŠ è½½æ›´å¤š
      if (scrollTop + clientHeight >= scrollHeight - 100 && hasMore && !loading) {
        loadMore();
      }
    };
    
    const container = containerRef.current;
    container?.addEventListener('scroll', handleScroll);
    
    return () => {
      container?.removeEventListener('scroll', handleScroll);
    };
  }, [hasMore, loading]);
  
  // åˆå§‹åŠ è½½
  useEffect(() => {
    loadMore();
  }, []);
  
  return (
    <div style={{ padding: 24, backgroundColor: '#f0f2f5', minHeight: '100vh' }}>
      <Card
        title="ğŸ“œ æ— é™æ»šåŠ¨åˆ—è¡¨ï¼ˆåˆ†é¡µè¿­ä»£å™¨ï¼‰"
        style={{ maxWidth: 800, margin: '0 auto' }}
        extra={
          <Space>
            <Tag color="blue">
              å·²åŠ è½½ {displayData.length} / {allData.length}
            </Tag>
            <Button icon={<ReloadOutlined />} onClick={handleReset}>
              é‡ç½®
            </Button>
          </Space>
        }
      >
        <div
          ref={containerRef}
          style={{
            height: 600,
            overflow: 'auto',
            border: '1px solid #d9d9d9',
            borderRadius: 4,
            padding: 16,
          }}
        >
          <List
            dataSource={displayData}
            renderItem={(item) => (
              <List.Item key={item.id}>
                <List.Item.Meta
                  avatar={
                    <Avatar size={48} style={{ backgroundColor: '#1890ff' }}>
                      {item.avatar}
                    </Avatar>
                  }
                  title={item.name}
                  description={item.description}
                />
                <Space>
                  {item.tags.map(tag => (
                    <Tag key={tag}>{tag}</Tag>
                  ))}
                </Space>
              </List.Item>
            )}
          />
          
          {loading && (
            <div style={{ textAlign: 'center', padding: 20 }}>
              <Spin tip="åŠ è½½ä¸­..." />
            </div>
          )}
          
          {!hasMore && displayData.length > 0 && (
            <div style={{ textAlign: 'center', padding: 20, color: '#999' }}>
              å·²åŠ è½½å…¨éƒ¨æ•°æ®
            </div>
          )}
          
          {hasMore && !loading && (
            <div style={{ textAlign: 'center', padding: 20 }}>
              <Button
                icon={<DownOutlined />}
                onClick={loadMore}
              >
                åŠ è½½æ›´å¤š
              </Button>
            </div>
          )}
        </div>
        
        {/* è¯´æ˜ */}
        <Card type="inner" size="small" style={{ marginTop: 16 }}>
          <ul style={{ margin: 0, paddingLeft: 20, fontSize: 12 }}>
            <li>âœ… <strong>PaginationIterator</strong> å°è£…äº†åˆ†é¡µé€»è¾‘</li>
            <li>âœ… æ”¯æŒè‡ªåŠ¨åŠ è½½ï¼ˆæ»šåŠ¨åˆ°åº•éƒ¨ï¼‰å’Œæ‰‹åŠ¨åŠ è½½</li>
            <li>âœ… ç»Ÿä¸€çš„è¿­ä»£å™¨æ¥å£ï¼Œæ˜“äºæ›¿æ¢ä¸åŒçš„åŠ è½½ç­–ç•¥</li>
            <li>âœ… å¯ä»¥è½»æ¾æ‰©å±•ä¸ºè™šæ‹Ÿæ»šåŠ¨ã€æ‡’åŠ è½½ç­‰</li>
          </ul>
        </Card>
      </Card>
    </div>
  );
};

export default InfiniteScrollList;
```

---

### åœºæ™¯ä¸‰ï¼šè‡ªå®šä¹‰æ•°æ®ç»“æ„ï¼ˆç¯å½¢ç¼“å†²åŒºï¼‰

å®ç°ä¸€ä¸ªç¯å½¢ç¼“å†²åŒºï¼ˆå¸¸ç”¨äºæ—¥å¿—ã€å†å²è®°å½•ï¼‰ï¼š

```typescript
import React, { useState } from 'react';
import { Card, Button, Space, Input, List, Tag, message } from 'antd';
import { PlusOutlined, ArrowLeftOutlined, ArrowRightOutlined, ReloadOutlined } from '@ant-design/icons';

// ç¯å½¢ç¼“å†²åŒºèŠ‚ç‚¹
interface CircularNode<T> {
  value: T;
  next: CircularNode<T> | null;
}

// ç¯å½¢ç¼“å†²åŒºè¿­ä»£å™¨
class CircularBufferIterator<T> implements Iterator<T> {
  private currentNode: CircularNode<T> | null;
  private startNode: CircularNode<T> | null;
  private hasStarted: boolean;
  private visitedCount: number;
  private totalCount: number;
  
  constructor(head: CircularNode<T> | null, count: number) {
    this.currentNode = head;
    this.startNode = head;
    this.hasStarted = false;
    this.visitedCount = 0;
    this.totalCount = count;
  }
  
  next(): T | null {
    if (!this.hasNext()) return null;
    
    if (!this.currentNode) return null;
    
    const value = this.currentNode.value;
    this.currentNode = this.currentNode.next;
    this.visitedCount++;
    this.hasStarted = true;
    
    return value;
  }
  
  hasNext(): boolean {
    if (!this.currentNode) return false;
    if (!this.hasStarted) return true;
    return this.visitedCount < this.totalCount;
  }
  
  current(): T | null {
    return this.currentNode?.value || null;
  }
  
  reset(): void {
    this.currentNode = this.startNode;
    this.hasStarted = false;
    this.visitedCount = 0;
  }
}

// ç¯å½¢ç¼“å†²åŒº
class CircularBuffer<T> {
  private head: CircularNode<T> | null = null;
  private tail: CircularNode<T> | null = null;
  private size: number = 0;
  private capacity: number;
  
  constructor(capacity: number) {
    this.capacity = capacity;
  }
  
  // æ·»åŠ å…ƒç´ 
  push(value: T): void {
    const newNode: CircularNode<T> = { value, next: null };
    
    if (this.size === 0) {
      this.head = newNode;
      this.tail = newNode;
      newNode.next = newNode; // æŒ‡å‘è‡ªå·±
      this.size = 1;
    } else if (this.size < this.capacity) {
      // æœªæ»¡ï¼Œç›´æ¥æ·»åŠ 
      newNode.next = this.head;
      this.tail!.next = newNode;
      this.tail = newNode;
      this.size++;
    } else {
      // å·²æ»¡ï¼Œè¦†ç›–æœ€æ—§çš„
      newNode.next = this.head!.next;
      this.tail!.next = newNode;
      this.tail = newNode;
      this.head = this.head!.next;
    }
  }
  
  // åˆ›å»ºè¿­ä»£å™¨
  createIterator(): Iterator<T> {
    return new CircularBufferIterator(this.head, this.size);
  }
  
  // è·å–æ‰€æœ‰å…ƒç´ ï¼ˆç”¨äºæ˜¾ç¤ºï¼‰
  toArray(): T[] {
    if (!this.head) return [];
    
    const result: T[] = [];
    let current = this.head;
    let count = 0;
    
    do {
      result.push(current.value);
      current = current.next!;
      count++;
    } while (current !== this.head && count < this.size);
    
    return result;
  }
  
  getSize(): number {
    return this.size;
  }
  
  getCapacity(): number {
    return this.capacity;
  }
  
  clear(): void {
    this.head = null;
    this.tail = null;
    this.size = 0;
  }
}

// React ç»„ä»¶
const CircularBufferDemo: React.FC = () => {
  const [buffer] = useState(() => new CircularBuffer<string>(5));
  const [items, setItems] = useState<string[]>([]);
  const [inputValue, setInputValue] = useState('');
  const [iterator, setIterator] = useState<Iterator<string> | null>(null);
  const [currentValue, setCurrentValue] = useState<string | null>(null);
  const [iteratorIndex, setIteratorIndex] = useState(-1);
  
  // æ·»åŠ é¡¹
  const handleAdd = () => {
    if (!inputValue.trim()) {
      message.warning('è¯·è¾“å…¥å†…å®¹');
      return;
    }
    
    buffer.push(inputValue);
    setItems(buffer.toArray());
    setInputValue('');
    setIterator(null);
    setCurrentValue(null);
    setIteratorIndex(-1);
    
    message.success(`å·²æ·»åŠ : ${inputValue}`);
  };
  
  // å¼€å§‹éå†
  const handleStartIteration = () => {
    const newIterator = buffer.createIterator();
    setIterator(newIterator);
    setIteratorIndex(-1);
    setCurrentValue(null);
    message.info('è¿­ä»£å™¨å·²åˆ›å»º');
  };
  
  // ä¸‹ä¸€ä¸ª
  const handleNext = () => {
    if (!iterator || !iterator.hasNext()) {
      message.warning('æ²¡æœ‰æ›´å¤šå…ƒç´ äº†');
      return;
    }
    
    const value = iterator.next();
    setCurrentValue(value);
    setIteratorIndex(prev => prev + 1);
  };
  
  // é‡ç½®è¿­ä»£å™¨
  const handleResetIterator = () => {
    if (!iterator) return;
    iterator.reset();
    setIteratorIndex(-1);
    setCurrentValue(null);
    message.info('è¿­ä»£å™¨å·²é‡ç½®');
  };
  
  // æ¸…ç©ºç¼“å†²åŒº
  const handleClear = () => {
    buffer.clear();
    setItems([]);
    setIterator(null);
    setCurrentValue(null);
    setIteratorIndex(-1);
    message.info('ç¼“å†²åŒºå·²æ¸…ç©º');
  };
  
  return (
    <div style={{ padding: 24, backgroundColor: '#f0f2f5', minHeight: '100vh' }}>
      <Card
        title="ğŸ”„ ç¯å½¢ç¼“å†²åŒºï¼ˆè‡ªå®šä¹‰è¿­ä»£å™¨ï¼‰"
        style={{ maxWidth: 800, margin: '0 auto' }}
        extra={
          <Space>
            <Tag color="blue">
              å®¹é‡: {buffer.getSize()} / {buffer.getCapacity()}
            </Tag>
          </Space>
        }
      >
        {/* æ·»åŠ å…ƒç´  */}
        <Card type="inner" title="æ·»åŠ å…ƒç´ " style={{ marginBottom: 16 }}>
          <Space.Compact style={{ width: '100%' }}>
            <Input
              value={inputValue}
              onChange={(e) => setInputValue(e.target.value)}
              onPressEnter={handleAdd}
              placeholder="è¾“å…¥å†…å®¹ï¼Œç¼“å†²åŒºæ»¡æ—¶ä¼šè¦†ç›–æœ€æ—§çš„"
            />
            <Button type="primary" icon={<PlusOutlined />} onClick={handleAdd}>
              æ·»åŠ 
            </Button>
          </Space.Compact>
        </Card>
        
        {/* ç¼“å†²åŒºå†…å®¹ */}
        <Card type="inner" title="ç¼“å†²åŒºå†…å®¹" style={{ marginBottom: 16 }}>
          {items.length === 0 ? (
            <div style={{ textAlign: 'center', padding: 40, color: '#999' }}>
              ç¼“å†²åŒºä¸ºç©º
            </div>
          ) : (
            <List
              dataSource={items}
              renderItem={(item, index) => (
                <List.Item
                  style={{
                    backgroundColor: index === iteratorIndex ? '#e6f7ff' : 'transparent',
                    padding: '8px 12px',
                    borderRadius: 4,
                  }}
                >
                  <Space>
                    <Tag color={index === 0 ? 'red' : 'default'}>
                      {index === 0 ? 'æœ€æ—§' : index}
                    </Tag>
                    <span>{item}</span>
                    {index === iteratorIndex && (
                      <Tag color="green">å½“å‰ä½ç½®</Tag>
                    )}
                  </Space>
                </List.Item>
              )}
            />
          )}
        </Card>
        
        {/* è¿­ä»£å™¨æ§åˆ¶ */}
        <Card type="inner" title="è¿­ä»£å™¨æ§åˆ¶">
          <Space direction="vertical" style={{ width: '100%' }}>
            <Space>
              <Button
                type="primary"
                onClick={handleStartIteration}
                disabled={items.length === 0}
              >
                åˆ›å»ºè¿­ä»£å™¨
              </Button>
              <Button
                icon={<ArrowRightOutlined />}
                onClick={handleNext}
                disabled={!iterator || !iterator.hasNext()}
              >
                ä¸‹ä¸€ä¸ª
              </Button>
              <Button
                icon={<ReloadOutlined />}
                onClick={handleResetIterator}
                disabled={!iterator}
              >
                é‡ç½®è¿­ä»£å™¨
              </Button>
              <Button danger onClick={handleClear}>
                æ¸…ç©ºç¼“å†²åŒº
              </Button>
            </Space>
            
            {currentValue && (
              <Card size="small" style={{ backgroundColor: '#f0f2f5' }}>
                <Space>
                  <span>å½“å‰å€¼ï¼š</span>
                  <Tag color="green">{currentValue}</Tag>
                  <span>ä½ç½®ï¼š{iteratorIndex + 1} / {buffer.getSize()}</span>
                </Space>
              </Card>
            )}
          </Space>
        </Card>
        
        {/* è¯´æ˜ */}
        <Card type="inner" title="ğŸ“‹ è¿­ä»£å™¨æ¨¡å¼è¯´æ˜" style={{ marginTop: 16 }}>
          <ul style={{ margin: 0, paddingLeft: 20 }}>
            <li>âœ… <strong>CircularBuffer</strong> æ˜¯é›†åˆï¼Œå®ç°äº†ç¯å½¢ç¼“å†²åŒº</li>
            <li>âœ… <strong>CircularBufferIterator</strong> æ˜¯è¿­ä»£å™¨ï¼Œå°è£…äº†éå†é€»è¾‘</li>
            <li>âœ… ç¯å½¢ç»“æ„ï¼šæ»¡äº†ä¹‹åä¼šè¦†ç›–æœ€æ—§çš„å…ƒç´ </li>
            <li>âœ… è¿­ä»£å™¨å¯ä»¥ç‹¬ç«‹éå†ï¼Œä¸å½±å“ç¼“å†²åŒºæœ¬èº«</li>
            <li>âœ… æ”¯æŒé‡ç½®ã€æš‚åœã€ç»§ç»­ç­‰æ“ä½œ</li>
          </ul>
        </Card>
      </Card>
    </div>
  );
};

export default CircularBufferDemo;
```

## æ¨¡å¼æ€»ç»“

### âœ… ä¼˜ç‚¹

1. **ç»Ÿä¸€æ¥å£**ï¼šä¸åŒæ•°æ®ç»“æ„æä¾›ç»Ÿä¸€çš„éå†æ¥å£
2. **èŒè´£åˆ†ç¦»**ï¼šéå†é€»è¾‘ä¸æ•°æ®ç»“æ„åˆ†ç¦»
3. **å¯æ§éå†**ï¼šæ”¯æŒæš‚åœã€æ¢å¤ã€è·³è¿‡ç­‰æ“ä½œ
4. **å¤šä¸ªè¿­ä»£å™¨**ï¼šåŒä¸€é›†åˆå¯ä»¥åŒæ—¶åˆ›å»ºå¤šä¸ªç‹¬ç«‹çš„è¿­ä»£å™¨
5. **æ˜“äºæ‰©å±•**ï¼šæ–°å¢éå†æ–¹å¼åªéœ€å®ç° Iterator æ¥å£

### âŒ ç¼ºç‚¹

1. **å¢åŠ å¤æ‚åº¦**ï¼šç®€å•çš„éå†ä½¿ç”¨è¿­ä»£å™¨å¯èƒ½è¿‡åº¦è®¾è®¡
2. **æ€§èƒ½å¼€é”€**ï¼šè¿­ä»£å™¨å¯¹è±¡çš„åˆ›å»ºå’Œç»´æŠ¤æœ‰ä¸€å®šå¼€é”€
3. **ä¸é€‚åˆéšæœºè®¿é—®**ï¼šè¿­ä»£å™¨é€‚åˆé¡ºåºè®¿é—®ï¼Œä¸é€‚åˆéšæœºè®¿é—®

### ğŸ¯ é€‚ç”¨åœºæ™¯

è¿­ä»£å™¨æ¨¡å¼ç‰¹åˆ«é€‚åˆä»¥ä¸‹å‰ç«¯åœºæ™¯ï¼š

| åœºæ™¯ | è¯´æ˜ | å…¸å‹å®ç° |
|------|------|---------|
| **æ ‘å½¢æ•°æ®éå†** | ç»„ç»‡æ¶æ„ã€èœå•æ ‘ã€æ–‡ä»¶æ ‘ | DFS/BFS è¿­ä»£å™¨ |
| **åˆ†é¡µåŠ è½½** | æ— é™æ»šåŠ¨ã€æ‡’åŠ è½½ | åˆ†é¡µè¿­ä»£å™¨ |
| **å†å²è®°å½•** | æµè§ˆå™¨å†å²ã€æ“ä½œå†å² | å‰è¿›/åé€€è¿­ä»£å™¨ |
| **æ’­æ”¾åˆ—è¡¨** | éŸ³ä¹ã€è§†é¢‘æ’­æ”¾å™¨ | é¡ºåº/éšæœºæ’­æ”¾è¿­ä»£å™¨ |
| **æ•°æ®æµå¤„ç†** | æ—¥å¿—æµã€äº‹ä»¶æµ | æµå¼è¿­ä»£å™¨ |
| **å›¾éå†** | å…³ç³»å›¾ã€çŸ¥è¯†å›¾è°± | å›¾éå†è¿­ä»£å™¨ |
| **è‡ªå®šä¹‰æ•°æ®ç»“æ„** | ç¯å½¢ç¼“å†²åŒºã€é“¾è¡¨ | è‡ªå®šä¹‰è¿­ä»£å™¨ |

### ğŸ¤” ä»€ä¹ˆæ—¶å€™è¯¥ç”¨è¿­ä»£å™¨æ¨¡å¼ï¼Ÿ

**ä¸‰ä¸ªåˆ¤æ–­æ ‡å‡†ï¼š**

1. **éœ€è¦éå†é›†åˆå—ï¼Ÿ**
   - éœ€è¦è®¿é—®é›†åˆä¸­çš„æ¯ä¸ªå…ƒç´ 

2. **æœ‰å¤šç§éå†æ–¹å¼å—ï¼Ÿ**
   - æ·±åº¦ä¼˜å…ˆã€å¹¿åº¦ä¼˜å…ˆã€è¿‡æ»¤éå†ç­‰

3. **éœ€è¦æ§åˆ¶éå†è¿‡ç¨‹å—ï¼Ÿ**
   - æš‚åœã€æ¢å¤ã€è·³è¿‡ã€é‡ç½®

**å¿«é€Ÿå†³ç­–æ ‘ï¼š**

```
éœ€è¦éå†ä¸€ä¸ªé›†åˆå—ï¼Ÿ
    â”œâ”€ æ˜¯ â†’ éå†é€»è¾‘å¤æ‚å—ï¼ˆå¤šç§æ–¹å¼/éœ€è¦æ§åˆ¶ï¼‰ï¼Ÿ
    â”‚        â”œâ”€ æ˜¯ â†’ éœ€è¦éšè—å†…éƒ¨ç»“æ„å—ï¼Ÿ
    â”‚        â”‚        â”œâ”€ æ˜¯ â†’ âœ… ç”¨è¿­ä»£å™¨æ¨¡å¼ï¼
    â”‚        â”‚        â””â”€ å¦ â†’ ğŸ¤” ç®€å• for å¾ªç¯ä¹Ÿè¡Œ
    â”‚        â””â”€ å¦ â†’ âŒ ç®€å•éå†ï¼Œä¸éœ€è¦
    â””â”€ å¦ â†’ âŒ ä¸éœ€è¦
```

### ğŸ’¡ JavaScript/TypeScript åŸç”Ÿæ”¯æŒ

#### 1. å¯è¿­ä»£åè®®ï¼ˆIterable Protocolï¼‰

```typescript
// å®ç°å¯è¿­ä»£å¯¹è±¡
class MyCollection implements Iterable<number> {
  private items: number[] = [1, 2, 3, 4, 5];
  
  // å®ç° [Symbol.iterator] æ–¹æ³•
  [Symbol.iterator](): Iterator<number> {
    let index = 0;
    const items = this.items;
    
    return {
      next(): IteratorResult<number> {
        if (index < items.length) {
          return { value: items[index++], done: false };
        }
        return { value: undefined, done: true };
      }
    };
  }
}

// ä½¿ç”¨
const collection = new MyCollection();

// å¯ä»¥ä½¿ç”¨ for...of
for (const item of collection) {
  console.log(item);
}

// å¯ä»¥ä½¿ç”¨å±•å¼€è¿ç®—ç¬¦
const array = [...collection];

// å¯ä»¥ä½¿ç”¨ Array.from
const array2 = Array.from(collection);
```

#### 2. Generator å‡½æ•°ï¼ˆç®€åŒ–è¿­ä»£å™¨å®ç°ï¼‰

```typescript
class TreeNode {
  value: number;
  children: TreeNode[];
  
  constructor(value: number) {
    this.value = value;
    this.children = [];
  }
  
  // ä½¿ç”¨ Generator å®ç° DFS
  *dfs(): Generator<number> {
    yield this.value;
    for (const child of this.children) {
      yield* child.dfs();
    }
  }
  
  // ä½¿ç”¨ Generator å®ç° BFS
  *bfs(): Generator<number> {
    const queue = [this];
    while (queue.length > 0) {
      const node = queue.shift()!;
      yield node.value;
      queue.push(...node.children);
    }
  }
}

// ä½¿ç”¨
const root = new TreeNode(1);
root.children.push(new TreeNode(2), new TreeNode(3));

for (const value of root.dfs()) {
  console.log(value); // 1, 2, 3
}
```

#### 3. å¼‚æ­¥è¿­ä»£å™¨ï¼ˆAsync Iteratorï¼‰

```typescript
class AsyncDataLoader {
  private urls: string[];
  
  constructor(urls: string[]) {
    this.urls = urls;
  }
  
  // å®ç°å¼‚æ­¥è¿­ä»£å™¨
  async *[Symbol.asyncIterator]() {
    for (const url of this.urls) {
      const response = await fetch(url);
      const data = await response.json();
      yield data;
    }
  }
}

// ä½¿ç”¨
const loader = new AsyncDataLoader(['/api/1', '/api/2', '/api/3']);

for await (const data of loader) {
  console.log(data);
}
```

### ğŸ†š è¿­ä»£å™¨æ¨¡å¼ vs ç»„åˆæ¨¡å¼

| ç‰¹å¾ | è¿­ä»£å™¨æ¨¡å¼ | ç»„åˆæ¨¡å¼ |
|------|-----------|---------|
| **å…³æ³¨ç‚¹** | å¦‚ä½•éå†é›†åˆ | å¦‚ä½•ç»„ç»‡æ ‘å½¢ç»“æ„ |
| **æ ¸å¿ƒåŠŸèƒ½** | æä¾›éå†æ¥å£ | ç»Ÿä¸€å¤„ç†å•ä¸ªå¯¹è±¡å’Œç»„åˆå¯¹è±¡ |
| **ä½¿ç”¨åœºæ™¯** | éœ€è¦éå†å¤æ‚æ•°æ®ç»“æ„ | éœ€è¦è¡¨ç¤º"éƒ¨åˆ†-æ•´ä½“"å±‚æ¬¡ç»“æ„ |
| **å…¸å‹å®ç°** | DFS/BFS è¿­ä»£å™¨ | æ–‡ä»¶å¤¹/æ–‡ä»¶ã€èœå•/å­èœå• |
| **èƒ½å¦ç»“åˆ** | âœ… å¯ä»¥ç»“åˆï¼ˆç»„åˆæ¨¡å¼çš„æ ‘ç”¨è¿­ä»£å™¨éå†ï¼‰ | |

---

## ğŸ’¬ å°ç»“

è¿­ä»£å™¨æ¨¡å¼å°±åƒç»™é›†åˆè£…ä¸Šäº†"é¥æ§å™¨"ï¼Œä½ ä¸éœ€è¦çŸ¥é“é›†åˆå†…éƒ¨æ€ä¹ˆå­˜å‚¨ï¼Œåªéœ€è¦æŒ‰æŒ‰é’®ï¼ˆnextã€hasNextï¼‰å°±èƒ½é¡ºåºè®¿é—®æ‰€æœ‰å…ƒç´ ã€‚

åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œè¿­ä»£å™¨æ¨¡å¼èƒ½è®©ä½ çš„ä»£ç ï¼š
- ä»"éå†é€»è¾‘å’Œæ•°æ®ç»“æ„è€¦åˆ"å˜æˆ"éå†é€»è¾‘ç‹¬ç«‹"
- ä»"æ— æ³•æ§åˆ¶éå†è¿‡ç¨‹"å˜æˆ"å¯æš‚åœã€æ¢å¤ã€é‡ç½®"
- ä»"æ¯ç§éå†æ–¹å¼éƒ½è¦é‡å†™"å˜æˆ"ç»Ÿä¸€æ¥å£ï¼Œæ˜“äºæ‰©å±•"

**è®°ä½ä¸€å¥è¯**ï¼šå½“ä½ éœ€è¦ä»¥å¤šç§æ–¹å¼éå†ä¸€ä¸ªå¤æ‚é›†åˆæ—¶ï¼Œå°±è¯¥è€ƒè™‘è¿­ä»£å™¨æ¨¡å¼äº†ï¼

---

> ğŸ’¡ **æ€è€ƒé¢˜**ï¼š
> 1. JavaScript çš„ `for...of` å¾ªç¯å’Œè¿­ä»£å™¨æ¨¡å¼æœ‰ä»€ä¹ˆå…³ç³»ï¼Ÿ
> 2. Generator å‡½æ•°å¦‚ä½•ç®€åŒ–è¿­ä»£å™¨çš„å®ç°ï¼Ÿ
> 3. è¿­ä»£å™¨æ¨¡å¼å’Œç»„åˆæ¨¡å¼èƒ½å¦ç»“åˆä½¿ç”¨ï¼Ÿå¦‚ä½•ç»“åˆï¼Ÿ

---

> ğŸ“š **ç›¸å…³æ¨¡å¼**ï¼š
> - ç»„åˆæ¨¡å¼ï¼ˆCompositeï¼‰ï¼šå¸¸ä¸è¿­ä»£å™¨é…åˆï¼Œéå†æ ‘å½¢ç»“æ„
> - è®¿é—®è€…æ¨¡å¼ï¼ˆVisitorï¼‰ï¼šè¿­ä»£å™¨è´Ÿè´£éå†ï¼Œè®¿é—®è€…è´Ÿè´£å¯¹å…ƒç´ è¿›è¡Œæ“ä½œ
> - å¤‡å¿˜å½•æ¨¡å¼ï¼ˆMementoï¼‰ï¼šå¯ç”¨äºä¿å­˜è¿­ä»£å™¨çš„çŠ¶æ€

