# å¤‡å¿˜å½•æ¨¡å¼ï¼ˆMemento Patternï¼‰

> ã€Šå‰ç«¯è®¾è®¡æ¨¡å¼å®æˆ˜æ‰‹å†Œã€‹ç³»åˆ— - ç¬¬å››ç« 

---

## ä¸€å¥è¯å¤§ç™½è¯

**å°±åƒç©æ¸¸æˆçš„å­˜æ¡£åŠŸèƒ½**ï¼šä½ åœ¨æ¸¸æˆé‡Œæ‰“åˆ°ç¬¬ 10 å…³ï¼Œå­˜ä¸ªæ¡£ï¼›æ‰“åˆ°ç¬¬ 15 å…³åˆå­˜ä¸ªæ¡£ï¼›å¦‚æœç¬¬ 20 å…³å¤±è´¥äº†ï¼Œå¯ä»¥è¯»å–ä¹‹å‰çš„å­˜æ¡£é‡æ–°æ¥è¿‡ã€‚æ¸¸æˆä¸ä¼šæŠŠä½ çš„æ“ä½œè®°å½•å…¨éƒ¨é‡æ”¾ï¼Œè€Œæ˜¯ç›´æ¥æ¢å¤åˆ°æŸä¸ªå­˜æ¡£ç‚¹çš„å®Œæ•´çŠ¶æ€ã€‚

## å‰ç«¯ç—›ç‚¹

æƒ³è±¡ä¸€ä¸‹ï¼Œä½ åœ¨åšä¸€ä¸ªå¯Œæ–‡æœ¬ç¼–è¾‘å™¨ï¼Œéœ€è¦å®ç°æ’¤é”€/é‡åšåŠŸèƒ½ã€‚æœ€ç›´è§‚çš„æƒ³æ³•æ˜¯è®°å½•æ¯æ¬¡æ“ä½œï¼š

```typescript
// âŒ æ²¡æœ‰ä½¿ç”¨å¤‡å¿˜å½•æ¨¡å¼çš„ä»£ç ï¼šè®°å½•æ“ä½œå‘½ä»¤ï¼Œéœ€è¦é‡æ”¾
class TextEditor {
  private content: string = '';
  private operations: Array<{ type: string; value: string }> = [];
  
  insertText(text: string) {
    this.content += text;
    this.operations.push({ type: 'insert', value: text });
  }
  
  deleteText(length: number) {
    const deleted = this.content.slice(-length);
    this.content = this.content.slice(0, -length);
    this.operations.push({ type: 'delete', value: deleted });
  }
  
  // æ’¤é”€ï¼šéœ€è¦åå‘æ‰§è¡Œæ“ä½œ
  undo() {
    const lastOp = this.operations.pop();
    if (!lastOp) return;
    
    if (lastOp.type === 'insert') {
      // åå‘æ“ä½œï¼šåˆ é™¤ä¹‹å‰æ’å…¥çš„æ–‡æœ¬
      this.content = this.content.slice(0, -lastOp.value.length);
    } else if (lastOp.type === 'delete') {
      // åå‘æ“ä½œï¼šæ¢å¤ä¹‹å‰åˆ é™¤çš„æ–‡æœ¬
      this.content += lastOp.value;
    }
    // è¿˜æœ‰æ ¼å¼åŒ–ã€ç²˜è´´ã€å‰ªåˆ‡ç­‰æ“ä½œ...æ¯ä¸ªéƒ½è¦å†™åå‘é€»è¾‘ï¼
  }
}
```

**è¿™æ®µä»£ç çš„é—®é¢˜ï¼š**
1. ğŸ¤¯ **åå‘æ“ä½œå¤æ‚**ï¼šæ¯ç§æ“ä½œéƒ½è¦å†™å¯¹åº”çš„æ’¤é”€é€»è¾‘ï¼Œå®¹æ˜“å‡ºé”™
2. ğŸ› **éš¾ä»¥ç»´æŠ¤**ï¼šæ–°å¢æ“ä½œç±»å‹æ—¶ï¼Œæ’¤é”€é€»è¾‘ä¹Ÿè¦åŒæ­¥ä¿®æ”¹
3. ğŸ“¦ **çŠ¶æ€ä¸å®Œæ•´**ï¼šåªè®°å½•æ“ä½œï¼Œæ— æ³•ä¿å­˜å®Œæ•´çš„ç¼–è¾‘å™¨çŠ¶æ€ï¼ˆå¦‚å…‰æ ‡ä½ç½®ã€é€‰åŒºç­‰ï¼‰
4. ğŸ”„ **é‡æ”¾å¼€é”€å¤§**ï¼šä»å¤´é‡æ”¾æ‰€æœ‰æ“ä½œï¼Œæ€§èƒ½å·®

## æ¨¡å¼æ ¸å¿ƒæ¦‚å¿µ

**å¤‡å¿˜å½•æ¨¡å¼çš„æœ¬è´¨**ï¼šåœ¨ä¸ç ´åå°è£…çš„å‰æä¸‹ï¼Œæ•è·å¯¹è±¡çš„å†…éƒ¨çŠ¶æ€ï¼Œå¹¶åœ¨å¯¹è±¡ä¹‹å¤–ä¿å­˜è¿™ä¸ªçŠ¶æ€ï¼Œä»¥ä¾¿å°†æ¥æ¢å¤ã€‚

**ä¸‰ä¸ªæ ¸å¿ƒè§’è‰²ï¼š**
- **å‘èµ·äººï¼ˆOriginatorï¼‰**ï¼šéœ€è¦ä¿å­˜/æ¢å¤çŠ¶æ€çš„å¯¹è±¡ï¼ˆå¦‚ç¼–è¾‘å™¨ï¼‰
- **å¤‡å¿˜å½•ï¼ˆMementoï¼‰**ï¼šå­˜å‚¨å‘èµ·äººå†…éƒ¨çŠ¶æ€çš„å¯¹è±¡ï¼ˆå¦‚ç¼–è¾‘å™¨å¿«ç…§ï¼‰
- **ç®¡ç†è€…ï¼ˆCaretakerï¼‰**ï¼šè´Ÿè´£ä¿å­˜å’Œç®¡ç†å¤‡å¿˜å½•ï¼ˆå¦‚å†å²è®°å½•ç®¡ç†å™¨ï¼‰

**ç±»æ¯”**ï¼š
- ğŸ® **æ¸¸æˆå­˜æ¡£**ï¼šæ¸¸æˆï¼ˆOriginatorï¼‰â†’ å­˜æ¡£æ–‡ä»¶ï¼ˆMementoï¼‰â†’ å­˜æ¡£ç®¡ç†å™¨ï¼ˆCaretakerï¼‰
- ğŸ“¸ **ç…§ç›¸æœº**ï¼šåœºæ™¯ï¼ˆOriginatorï¼‰â†’ ç…§ç‰‡ï¼ˆMementoï¼‰â†’ ç›¸å†Œï¼ˆCaretakerï¼‰
- ğŸ’¾ **Word è‡ªåŠ¨ä¿å­˜**ï¼šæ–‡æ¡£ï¼ˆOriginatorï¼‰â†’ ä¸´æ—¶æ–‡ä»¶ï¼ˆMementoï¼‰â†’ ç‰ˆæœ¬å†å²ï¼ˆCaretakerï¼‰

**æ ¸å¿ƒæ€æƒ³ï¼š**
```
ä¿å­˜å®Œæ•´çŠ¶æ€ vs ä¿å­˜æ“ä½œå‘½ä»¤

å¤‡å¿˜å½•æ¨¡å¼ï¼šä¿å­˜å¿«ç…§
Time1: { content: "Hello" }
Time2: { content: "Hello World" }
Time3: { content: "Hello World!" }
æ’¤é”€åˆ° Time2 â†’ ç›´æ¥æ¢å¤å¿«ç…§ âœ… ç®€å•å¿«é€Ÿ

å‘½ä»¤æ¨¡å¼ï¼šè®°å½•æ“ä½œ
Time1: æ’å…¥ "Hello"
Time2: æ’å…¥ " World"
Time3: æ’å…¥ "!"
æ’¤é”€åˆ° Time2 â†’ åå‘æ‰§è¡Œ "åˆ é™¤ !" âŒ éœ€è¦å†™åå‘é€»è¾‘
```

## å‰ç«¯å®æˆ˜æ¡ˆä¾‹

### åœºæ™¯ä¸€ï¼šå¯Œæ–‡æœ¬ç¼–è¾‘å™¨ï¼ˆæ’¤é”€/é‡åšï¼‰

æˆ‘ä»¬è¦å®ç°ä¸€ä¸ªç®€å•çš„å¯Œæ–‡æœ¬ç¼–è¾‘å™¨ï¼Œæ”¯æŒæ’¤é”€å’Œé‡åšåŠŸèƒ½ï¼š

```typescript
// âœ… ä½¿ç”¨å¤‡å¿˜å½•æ¨¡å¼é‡æ„

import React, { useState, useRef } from 'react';
import { Card, Button, Space, Input, message, Tag, Slider } from 'antd';
import {
  UndoOutlined,
  RedoOutlined,
  BoldOutlined,
  ItalicOutlined,
  FontSizeOutlined,
  HistoryOutlined,
} from '@ant-design/icons';

const { TextArea } = Input;

// 1ï¸âƒ£ å¤‡å¿˜å½•ï¼šç¼–è¾‘å™¨çŠ¶æ€å¿«ç…§
interface EditorMemento {
  content: string;
  fontSize: number;
  isBold: boolean;
  isItalic: boolean;
  cursorPosition: number;
  timestamp: number;
}

// 2ï¸âƒ£ å‘èµ·äººï¼šç¼–è¾‘å™¨
class Editor {
  private content: string = '';
  private fontSize: number = 14;
  private isBold: boolean = false;
  private isItalic: boolean = false;
  private cursorPosition: number = 0;

  // è®¾ç½®å†…å®¹
  setContent(content: string): void {
    this.content = content;
  }

  getContent(): string {
    return this.content;
  }

  // è®¾ç½®æ ·å¼
  setFontSize(size: number): void {
    this.fontSize = size;
  }

  getFontSize(): number {
    return this.fontSize;
  }

  toggleBold(): void {
    this.isBold = !this.isBold;
  }

  isBoldEnabled(): boolean {
    return this.isBold;
  }

  toggleItalic(): void {
    this.isItalic = !this.isItalic;
  }

  isItalicEnabled(): boolean {
    return this.isItalic;
  }

  setCursorPosition(position: number): void {
    this.cursorPosition = position;
  }

  getCursorPosition(): number {
    return this.cursorPosition;
  }

  // åˆ›å»ºå¤‡å¿˜å½•ï¼ˆä¿å­˜å½“å‰çŠ¶æ€ï¼‰
  createMemento(): EditorMemento {
    return {
      content: this.content,
      fontSize: this.fontSize,
      isBold: this.isBold,
      isItalic: this.isItalic,
      cursorPosition: this.cursorPosition,
      timestamp: Date.now(),
    };
  }

  // ä»å¤‡å¿˜å½•æ¢å¤çŠ¶æ€
  restoreFromMemento(memento: EditorMemento): void {
    this.content = memento.content;
    this.fontSize = memento.fontSize;
    this.isBold = memento.isBold;
    this.isItalic = memento.isItalic;
    this.cursorPosition = memento.cursorPosition;
  }
}

// 3ï¸âƒ£ ç®¡ç†è€…ï¼šå†å²è®°å½•ç®¡ç†å™¨
class History {
  private mementos: EditorMemento[] = [];
  private currentIndex: number = -1;
  private maxSize: number = 50; // æœ€å¤šä¿å­˜50ä¸ªå†å²è®°å½•

  // ä¿å­˜æ–°çŠ¶æ€
  push(memento: EditorMemento): void {
    // å¦‚æœå½“å‰ä¸åœ¨æœ€æ–°çŠ¶æ€ï¼Œåˆ é™¤åé¢çš„å†å²
    if (this.currentIndex < this.mementos.length - 1) {
      this.mementos = this.mementos.slice(0, this.currentIndex + 1);
    }

    // æ·»åŠ æ–°çš„å¤‡å¿˜å½•
    this.mementos.push(memento);

    // é™åˆ¶å†å²è®°å½•æ•°é‡
    if (this.mementos.length > this.maxSize) {
      this.mementos.shift();
    } else {
      this.currentIndex++;
    }
  }

  // æ’¤é”€
  undo(): EditorMemento | null {
    if (this.currentIndex > 0) {
      this.currentIndex--;
      return this.mementos[this.currentIndex];
    }
    return null;
  }

  // é‡åš
  redo(): EditorMemento | null {
    if (this.currentIndex < this.mementos.length - 1) {
      this.currentIndex++;
      return this.mementos[this.currentIndex];
    }
    return null;
  }

  // æ˜¯å¦å¯ä»¥æ’¤é”€
  canUndo(): boolean {
    return this.currentIndex > 0;
  }

  // æ˜¯å¦å¯ä»¥é‡åš
  canRedo(): boolean {
    return this.currentIndex < this.mementos.length - 1;
  }

  // è·å–å†å²è®°å½•åˆ—è¡¨
  getHistory(): EditorMemento[] {
    return this.mementos;
  }

  getCurrentIndex(): number {
    return this.currentIndex;
  }

  // æ¸…ç©ºå†å²
  clear(): void {
    this.mementos = [];
    this.currentIndex = -1;
  }
}

// 4ï¸âƒ£ React ç»„ä»¶ï¼šå¯Œæ–‡æœ¬ç¼–è¾‘å™¨
const RichTextEditor: React.FC = () => {
  const editorRef = useRef(new Editor());
  const historyRef = useRef(new History());
  const textAreaRef = useRef<any>(null);

  const [content, setContent] = useState('');
  const [fontSize, setFontSize] = useState(14);
  const [isBold, setIsBold] = useState(false);
  const [isItalic, setIsItalic] = useState(false);
  const [canUndo, setCanUndo] = useState(false);
  const [canRedo, setCanRedo] = useState(false);
  const [showHistory, setShowHistory] = useState(false);

  // åˆå§‹åŒ–ï¼šä¿å­˜åˆå§‹çŠ¶æ€
  React.useEffect(() => {
    const initialMemento = editorRef.current.createMemento();
    historyRef.current.push(initialMemento);
  }, []);

  // ä¿å­˜å½“å‰çŠ¶æ€åˆ°å†å²
  const saveState = () => {
    const memento = editorRef.current.createMemento();
    historyRef.current.push(memento);
    updateUndoRedoButtons();
  };

  // æ›´æ–°æ’¤é”€/é‡åšæŒ‰é’®çŠ¶æ€
  const updateUndoRedoButtons = () => {
    setCanUndo(historyRef.current.canUndo());
    setCanRedo(historyRef.current.canRedo());
  };

  // ä» Editor åŒæ­¥çŠ¶æ€åˆ° React
  const syncFromEditor = () => {
    setContent(editorRef.current.getContent());
    setFontSize(editorRef.current.getFontSize());
    setIsBold(editorRef.current.isBoldEnabled());
    setIsItalic(editorRef.current.isItalicEnabled());
  };

  // å¤„ç†å†…å®¹å˜åŒ–
  const handleContentChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const newContent = e.target.value;
    const cursorPos = e.target.selectionStart || 0;
    
    editorRef.current.setContent(newContent);
    editorRef.current.setCursorPosition(cursorPos);
    setContent(newContent);
    
    saveState();
  };

  // å¤„ç†å­—ä½“å¤§å°å˜åŒ–
  const handleFontSizeChange = (value: number) => {
    editorRef.current.setFontSize(value);
    setFontSize(value);
    saveState();
  };

  // åˆ‡æ¢ç²—ä½“
  const handleToggleBold = () => {
    editorRef.current.toggleBold();
    setIsBold(editorRef.current.isBoldEnabled());
    saveState();
  };

  // åˆ‡æ¢æ–œä½“
  const handleToggleItalic = () => {
    editorRef.current.toggleItalic();
    setIsItalic(editorRef.current.isItalicEnabled());
    saveState();
  };

  // æ’¤é”€
  const handleUndo = () => {
    const memento = historyRef.current.undo();
    if (memento) {
      editorRef.current.restoreFromMemento(memento);
      syncFromEditor();
      updateUndoRedoButtons();
      message.success('å·²æ’¤é”€');
      
      // æ¢å¤å…‰æ ‡ä½ç½®
      setTimeout(() => {
        if (textAreaRef.current) {
          const textarea = textAreaRef.current.resizableTextArea.textArea;
          textarea.setSelectionRange(memento.cursorPosition, memento.cursorPosition);
        }
      }, 0);
    }
  };

  // é‡åš
  const handleRedo = () => {
    const memento = historyRef.current.redo();
    if (memento) {
      editorRef.current.restoreFromMemento(memento);
      syncFromEditor();
      updateUndoRedoButtons();
      message.success('å·²é‡åš');
      
      // æ¢å¤å…‰æ ‡ä½ç½®
      setTimeout(() => {
        if (textAreaRef.current) {
          const textarea = textAreaRef.current.resizableTextArea.textArea;
          textarea.setSelectionRange(memento.cursorPosition, memento.cursorPosition);
        }
      }, 0);
    }
  };

  // è·³è½¬åˆ°å†å²è®°å½•
  const jumpToHistory = (index: number) => {
    const history = historyRef.current.getHistory();
    const memento = history[index];
    
    historyRef.current['currentIndex'] = index;
    editorRef.current.restoreFromMemento(memento);
    syncFromEditor();
    updateUndoRedoButtons();
    setShowHistory(false);
    
    message.success(`å·²è·³è½¬åˆ°å†å²è®°å½• ${index + 1}`);
  };

  // è®¡ç®—æ–‡æœ¬æ ·å¼
  const textStyle: React.CSSProperties = {
    fontSize: `${fontSize}px`,
    fontWeight: isBold ? 'bold' : 'normal',
    fontStyle: isItalic ? 'italic' : 'normal',
    lineHeight: 1.6,
  };

  const history = historyRef.current.getHistory();
  const currentIndex = historyRef.current.getCurrentIndex();

  return (
    <div style={{ padding: 24, backgroundColor: '#f0f2f5', minHeight: '100vh' }}>
      <Card title="ğŸ“ å¯Œæ–‡æœ¬ç¼–è¾‘å™¨ï¼ˆå¤‡å¿˜å½•æ¨¡å¼ï¼‰" style={{ maxWidth: 900, margin: '0 auto' }}>
        {/* å·¥å…·æ  */}
        <Space style={{ marginBottom: 16 }}>
          <Button
            icon={<UndoOutlined />}
            onClick={handleUndo}
            disabled={!canUndo}
          >
            æ’¤é”€ (Ctrl+Z)
          </Button>
          <Button
            icon={<RedoOutlined />}
            onClick={handleRedo}
            disabled={!canRedo}
          >
            é‡åš (Ctrl+Y)
          </Button>
          
          <div style={{ width: 1, height: 30, backgroundColor: '#d9d9d9', margin: '0 8px' }} />
          
          <Button
            icon={<BoldOutlined />}
            type={isBold ? 'primary' : 'default'}
            onClick={handleToggleBold}
          >
            ç²—ä½“
          </Button>
          <Button
            icon={<ItalicOutlined />}
            type={isItalic ? 'primary' : 'default'}
            onClick={handleToggleItalic}
          >
            æ–œä½“
          </Button>
          
          <div style={{ width: 1, height: 30, backgroundColor: '#d9d9d9', margin: '0 8px' }} />
          
          <Button
            icon={<HistoryOutlined />}
            onClick={() => setShowHistory(!showHistory)}
          >
            å†å²è®°å½• ({history.length})
          </Button>
        </Space>

        {/* å­—ä½“å¤§å°è°ƒèŠ‚ */}
        <div style={{ marginBottom: 16 }}>
          <Space>
            <FontSizeOutlined />
            <span>å­—ä½“å¤§å°ï¼š{fontSize}px</span>
            <Slider
              min={12}
              max={32}
              value={fontSize}
              onChange={handleFontSizeChange}
              style={{ width: 200 }}
            />
          </Space>
        </div>

        {/* ç¼–è¾‘åŒºåŸŸ */}
        <TextArea
          ref={textAreaRef}
          value={content}
          onChange={handleContentChange}
          placeholder="è¯·è¾“å…¥å†…å®¹..."
          rows={12}
          style={textStyle}
        />

        {/* ç»Ÿè®¡ä¿¡æ¯ */}
        <div style={{ marginTop: 16, color: '#666' }}>
          <Space>
            <Tag>å­—ç¬¦æ•°ï¼š{content.length}</Tag>
            <Tag>å†å²è®°å½•æ•°ï¼š{history.length}</Tag>
            <Tag>å½“å‰ä½ç½®ï¼š{currentIndex + 1}/{history.length}</Tag>
          </Space>
        </div>

        {/* å†å²è®°å½•åˆ—è¡¨ */}
        {showHistory && (
          <Card
            type="inner"
            title="å†å²è®°å½•"
            style={{ marginTop: 16 }}
            extra={
              <Button size="small" onClick={() => setShowHistory(false)}>
                å…³é—­
              </Button>
            }
          >
            <div style={{ maxHeight: 300, overflow: 'auto' }}>
              {history.map((memento, index) => (
                <div
                  key={index}
                  style={{
                    padding: '8px 12px',
                    marginBottom: 8,
                    backgroundColor: index === currentIndex ? '#e6f7ff' : '#fafafa',
                    border: index === currentIndex ? '1px solid #1890ff' : '1px solid #d9d9d9',
                    borderRadius: 4,
                    cursor: 'pointer',
                  }}
                  onClick={() => jumpToHistory(index)}
                >
                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                    <div>
                      <Tag color={index === currentIndex ? 'blue' : 'default'}>
                        {index + 1}
                      </Tag>
                      <span style={{ fontSize: 12, color: '#999' }}>
                        {new Date(memento.timestamp).toLocaleTimeString()}
                      </span>
                    </div>
                    <div style={{ fontSize: 12, color: '#666' }}>
                      {memento.content.length} å­—ç¬¦
                    </div>
                  </div>
                  <div
                    style={{
                      marginTop: 4,
                      fontSize: 12,
                      color: '#333',
                      overflow: 'hidden',
                      textOverflow: 'ellipsis',
                      whiteSpace: 'nowrap',
                    }}
                  >
                    {memento.content || '(ç©º)'}
                  </div>
                </div>
              ))}
            </div>
          </Card>
        )}

        {/* è¯´æ˜ */}
        <Card type="inner" title="ğŸ“‹ å¤‡å¿˜å½•æ¨¡å¼è¯´æ˜" style={{ marginTop: 16 }}>
          <ul style={{ margin: 0, paddingLeft: 20 }}>
            <li>âœ… <strong>Editor</strong> æ˜¯å‘èµ·äººï¼ˆOriginatorï¼‰ï¼Œè´Ÿè´£ç®¡ç†ç¼–è¾‘å™¨çŠ¶æ€</li>
            <li>âœ… <strong>EditorMemento</strong> æ˜¯å¤‡å¿˜å½•ï¼ˆMementoï¼‰ï¼Œä¿å­˜å®Œæ•´çš„ç¼–è¾‘å™¨å¿«ç…§</li>
            <li>âœ… <strong>History</strong> æ˜¯ç®¡ç†è€…ï¼ˆCaretakerï¼‰ï¼Œè´Ÿè´£å­˜å‚¨å’Œç®¡ç†å†å²è®°å½•</li>
            <li>âœ… æ¯æ¬¡ç¼–è¾‘æ“ä½œéƒ½ä¿å­˜å®Œæ•´çŠ¶æ€ï¼Œæ’¤é”€æ—¶ç›´æ¥æ¢å¤å¿«ç…§</li>
            <li>âœ… æ”¯æŒè·³è½¬åˆ°ä»»æ„å†å²è®°å½•ç‚¹</li>
            <li>âœ… è‡ªåŠ¨é™åˆ¶å†å²è®°å½•æ•°é‡ï¼Œé¿å…å†…å­˜æº¢å‡º</li>
          </ul>
        </Card>
      </Card>
    </div>
  );
};

export default RichTextEditor;
```

#### ğŸ¯ ä½¿ç”¨å¤‡å¿˜å½•æ¨¡å¼åçš„å¥½å¤„

1. **æ’¤é”€é€»è¾‘ç®€å•**ï¼šä¸éœ€è¦ä¸ºæ¯ä¸ªæ“ä½œå†™åå‘é€»è¾‘ï¼Œç›´æ¥æ¢å¤å¿«ç…§
2. **çŠ¶æ€å®Œæ•´**ï¼šä¿å­˜çš„æ˜¯å®Œæ•´çŠ¶æ€ï¼ŒåŒ…æ‹¬å†…å®¹ã€æ ·å¼ã€å…‰æ ‡ä½ç½®ç­‰
3. **æ”¯æŒä»»æ„è·³è½¬**ï¼šå¯ä»¥è·³è½¬åˆ°ä»»æ„å†å²è®°å½•ç‚¹ï¼Œä¸åªæ˜¯ä¸Šä¸€æ­¥
4. **æ˜“äºæ‰©å±•**ï¼šæ–°å¢çŠ¶æ€å­—æ®µåªéœ€ä¿®æ”¹ Memento æ¥å£

---

### åœºæ™¯äºŒï¼šè¡¨å•è‰ç¨¿è‡ªåŠ¨ä¿å­˜

å¾ˆå¤šåå°ç®¡ç†ç³»ç»Ÿéœ€è¦è¡¨å•è‰ç¨¿åŠŸèƒ½ï¼Œé¿å…ç”¨æˆ·å¡«å†™åˆ°ä¸€åŠæ„å¤–å…³é—­é¡µé¢å¯¼è‡´æ•°æ®ä¸¢å¤±ï¼š

```typescript
import React, { useState, useEffect } from 'react';
import { Form, Input, Select, DatePicker, Button, Card, message, Tag, Space, Modal } from 'antd';
import { SaveOutlined, HistoryOutlined, DeleteOutlined } from '@ant-design/icons';

const { TextArea } = Input;
const { Option } = Select;

// è¡¨å•æ•°æ®å¤‡å¿˜å½•
interface FormMemento {
  data: Record<string, any>;
  timestamp: number;
  label: string;
}

// è¡¨å•è‰ç¨¿ç®¡ç†å™¨
class DraftManager {
  private storageKey: string;
  private maxDrafts: number = 10;

  constructor(storageKey: string) {
    this.storageKey = storageKey;
  }

  // ä¿å­˜è‰ç¨¿
  saveDraft(data: Record<string, any>, label: string = 'è‡ªåŠ¨ä¿å­˜'): void {
    const drafts = this.getDrafts();
    const newDraft: FormMemento = {
      data,
      timestamp: Date.now(),
      label,
    };

    drafts.unshift(newDraft);

    // é™åˆ¶è‰ç¨¿æ•°é‡
    if (drafts.length > this.maxDrafts) {
      drafts.pop();
    }

    localStorage.setItem(this.storageKey, JSON.stringify(drafts));
  }

  // è·å–æ‰€æœ‰è‰ç¨¿
  getDrafts(): FormMemento[] {
    const stored = localStorage.getItem(this.storageKey);
    return stored ? JSON.parse(stored) : [];
  }

  // åŠ è½½è‰ç¨¿
  loadDraft(index: number): FormMemento | null {
    const drafts = this.getDrafts();
    return drafts[index] || null;
  }

  // åˆ é™¤è‰ç¨¿
  deleteDraft(index: number): void {
    const drafts = this.getDrafts();
    drafts.splice(index, 1);
    localStorage.setItem(this.storageKey, JSON.stringify(drafts));
  }

  // æ¸…ç©ºæ‰€æœ‰è‰ç¨¿
  clearDrafts(): void {
    localStorage.removeItem(this.storageKey);
  }

  // è·å–æœ€æ–°è‰ç¨¿
  getLatestDraft(): FormMemento | null {
    const drafts = this.getDrafts();
    return drafts.length > 0 ? drafts[0] : null;
  }
}

// React ç»„ä»¶ï¼šå¸¦è‰ç¨¿åŠŸèƒ½çš„è¡¨å•
const DraftForm: React.FC = () => {
  const [form] = Form.useForm();
  const [draftManager] = useState(() => new DraftManager('user-form-drafts'));
  const [drafts, setDrafts] = useState<FormMemento[]>([]);
  const [showDrafts, setShowDrafts] = useState(false);
  const [autoSaveEnabled, setAutoSaveEnabled] = useState(true);

  // è‡ªåŠ¨ä¿å­˜å®šæ—¶å™¨
  useEffect(() => {
    if (!autoSaveEnabled) return;

    const timer = setInterval(() => {
      const values = form.getFieldsValue();
      const hasData = Object.values(values).some((v) => v !== undefined && v !== '');
      
      if (hasData) {
        draftManager.saveDraft(values, 'è‡ªåŠ¨ä¿å­˜');
        setDrafts(draftManager.getDrafts());
        console.log('ğŸ“ è¡¨å•å·²è‡ªåŠ¨ä¿å­˜');
      }
    }, 10000); // æ¯10ç§’è‡ªåŠ¨ä¿å­˜

    return () => clearInterval(timer);
  }, [form, draftManager, autoSaveEnabled]);

  // ç»„ä»¶æŒ‚è½½æ—¶åŠ è½½è‰ç¨¿åˆ—è¡¨
  useEffect(() => {
    setDrafts(draftManager.getDrafts());
    
    // æç¤ºç”¨æˆ·æœ‰æœªä¿å­˜çš„è‰ç¨¿
    const latestDraft = draftManager.getLatestDraft();
    if (latestDraft) {
      Modal.confirm({
        title: 'å‘ç°æœªå®Œæˆçš„è‰ç¨¿',
        content: `æœ€åä¿å­˜æ—¶é—´ï¼š${new Date(latestDraft.timestamp).toLocaleString()}`,
        okText: 'æ¢å¤è‰ç¨¿',
        cancelText: 'å¼€å§‹æ–°è¡¨å•',
        onOk: () => {
          form.setFieldsValue(latestDraft.data);
          message.success('è‰ç¨¿å·²æ¢å¤');
        },
      });
    }
  }, [draftManager, form]);

  // æ‰‹åŠ¨ä¿å­˜è‰ç¨¿
  const handleManualSave = () => {
    const values = form.getFieldsValue();
    draftManager.saveDraft(values, 'æ‰‹åŠ¨ä¿å­˜');
    setDrafts(draftManager.getDrafts());
    message.success('è‰ç¨¿å·²ä¿å­˜');
  };

  // åŠ è½½è‰ç¨¿
  const handleLoadDraft = (index: number) => {
    const draft = draftManager.loadDraft(index);
    if (draft) {
      form.setFieldsValue(draft.data);
      setShowDrafts(false);
      message.success('è‰ç¨¿å·²åŠ è½½');
    }
  };

  // åˆ é™¤è‰ç¨¿
  const handleDeleteDraft = (index: number, e: React.MouseEvent) => {
    e.stopPropagation();
    draftManager.deleteDraft(index);
    setDrafts(draftManager.getDrafts());
    message.success('è‰ç¨¿å·²åˆ é™¤');
  };

  // æ¸…ç©ºæ‰€æœ‰è‰ç¨¿
  const handleClearAllDrafts = () => {
    Modal.confirm({
      title: 'ç¡®è®¤æ¸…ç©ºæ‰€æœ‰è‰ç¨¿ï¼Ÿ',
      content: 'æ­¤æ“ä½œä¸å¯æ¢å¤',
      okText: 'ç¡®è®¤',
      okType: 'danger',
      cancelText: 'å–æ¶ˆ',
      onOk: () => {
        draftManager.clearDrafts();
        setDrafts([]);
        message.success('å·²æ¸…ç©ºæ‰€æœ‰è‰ç¨¿');
      },
    });
  };

  // æäº¤è¡¨å•
  const onFinish = (values: any) => {
    console.log('æäº¤è¡¨å•:', values);
    message.success('è¡¨å•æäº¤æˆåŠŸï¼');
    
    // æäº¤æˆåŠŸåæ¸…ç©ºè‰ç¨¿
    draftManager.clearDrafts();
    setDrafts([]);
    form.resetFields();
  };

  return (
    <div style={{ padding: 24, backgroundColor: '#f0f2f5', minHeight: '100vh' }}>
      <Card
        title="ğŸ“‹ ç”¨æˆ·ä¿¡æ¯è¡¨å•ï¼ˆè‡ªåŠ¨ä¿å­˜è‰ç¨¿ï¼‰"
        style={{ maxWidth: 800, margin: '0 auto' }}
        extra={
          <Space>
            <Tag color={autoSaveEnabled ? 'green' : 'default'}>
              {autoSaveEnabled ? 'è‡ªåŠ¨ä¿å­˜å·²å¼€å¯' : 'è‡ªåŠ¨ä¿å­˜å·²å…³é—­'}
            </Tag>
            <Button
              size="small"
              onClick={() => setAutoSaveEnabled(!autoSaveEnabled)}
            >
              {autoSaveEnabled ? 'å…³é—­' : 'å¼€å¯'}è‡ªåŠ¨ä¿å­˜
            </Button>
          </Space>
        }
      >
        {/* æ“ä½œæŒ‰é’® */}
        <Space style={{ marginBottom: 24 }}>
          <Button
            icon={<SaveOutlined />}
            onClick={handleManualSave}
          >
            æ‰‹åŠ¨ä¿å­˜è‰ç¨¿
          </Button>
          <Button
            icon={<HistoryOutlined />}
            onClick={() => setShowDrafts(true)}
          >
            è‰ç¨¿åˆ—è¡¨ ({drafts.length})
          </Button>
          {drafts.length > 0 && (
            <Button
              danger
              icon={<DeleteOutlined />}
              onClick={handleClearAllDrafts}
            >
              æ¸…ç©ºè‰ç¨¿
            </Button>
          )}
        </Space>

        {/* è¡¨å• */}
        <Form
          form={form}
          layout="vertical"
          onFinish={onFinish}
        >
          <Form.Item
            label="å§“å"
            name="name"
            rules={[{ required: true, message: 'è¯·è¾“å…¥å§“å' }]}
          >
            <Input placeholder="è¯·è¾“å…¥å§“å" />
          </Form.Item>

          <Form.Item
            label="é‚®ç®±"
            name="email"
            rules={[
              { required: true, message: 'è¯·è¾“å…¥é‚®ç®±' },
              { type: 'email', message: 'è¯·è¾“å…¥æ­£ç¡®çš„é‚®ç®±æ ¼å¼' },
            ]}
          >
            <Input placeholder="è¯·è¾“å…¥é‚®ç®±" />
          </Form.Item>

          <Form.Item
            label="éƒ¨é—¨"
            name="department"
            rules={[{ required: true, message: 'è¯·é€‰æ‹©éƒ¨é—¨' }]}
          >
            <Select placeholder="è¯·é€‰æ‹©éƒ¨é—¨">
              <Option value="tech">æŠ€æœ¯éƒ¨</Option>
              <Option value="product">äº§å“éƒ¨</Option>
              <Option value="design">è®¾è®¡éƒ¨</Option>
              <Option value="market">å¸‚åœºéƒ¨</Option>
            </Select>
          </Form.Item>

          <Form.Item
            label="å…¥èŒæ—¥æœŸ"
            name="joinDate"
            rules={[{ required: true, message: 'è¯·é€‰æ‹©å…¥èŒæ—¥æœŸ' }]}
          >
            <DatePicker style={{ width: '100%' }} />
          </Form.Item>

          <Form.Item
            label="ä¸ªäººç®€ä»‹"
            name="bio"
          >
            <TextArea rows={4} placeholder="è¯·è¾“å…¥ä¸ªäººç®€ä»‹" />
          </Form.Item>

          <Form.Item>
            <Button type="primary" htmlType="submit" block>
              æäº¤
            </Button>
          </Form.Item>
        </Form>

        {/* æç¤ºä¿¡æ¯ */}
        <Card type="inner" size="small" style={{ marginTop: 16 }}>
          <div style={{ fontSize: 12, color: '#666' }}>
            ğŸ’¡ è¡¨å•ä¼šæ¯ 10 ç§’è‡ªåŠ¨ä¿å­˜è‰ç¨¿ï¼Œåˆ·æ–°é¡µé¢åå¯æ¢å¤
          </div>
        </Card>
      </Card>

      {/* è‰ç¨¿åˆ—è¡¨å¼¹çª— */}
      <Modal
        title="è‰ç¨¿åˆ—è¡¨"
        open={showDrafts}
        onCancel={() => setShowDrafts(false)}
        footer={null}
        width={600}
      >
        {drafts.length === 0 ? (
          <div style={{ textAlign: 'center', padding: 40, color: '#999' }}>
            æš‚æ— è‰ç¨¿
          </div>
        ) : (
          <div style={{ maxHeight: 400, overflow: 'auto' }}>
            {drafts.map((draft, index) => (
              <Card
                key={index}
                size="small"
                style={{ marginBottom: 12, cursor: 'pointer' }}
                hoverable
                onClick={() => handleLoadDraft(index)}
              >
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                  <div>
                    <Tag color={index === 0 ? 'blue' : 'default'}>
                      {draft.label}
                    </Tag>
                    <span style={{ fontSize: 12, color: '#999' }}>
                      {new Date(draft.timestamp).toLocaleString()}
                    </span>
                  </div>
                  <Button
                    danger
                    size="small"
                    icon={<DeleteOutlined />}
                    onClick={(e) => handleDeleteDraft(index, e)}
                  />
                </div>
                <div style={{ marginTop: 8, fontSize: 12, color: '#666' }}>
                  å§“å: {draft.data.name || '-'} | 
                  é‚®ç®±: {draft.data.email || '-'} | 
                  éƒ¨é—¨: {draft.data.department || '-'}
                </div>
              </Card>
            ))}
          </div>
        )}
      </Modal>
    </div>
  );
};

export default DraftForm;
```

---

### åœºæ™¯ä¸‰ï¼šCanvas ç»˜å›¾å·¥å…·ï¼ˆçŠ¶æ€å¿«ç…§ï¼‰

å®ç°ä¸€ä¸ªç®€å•çš„ç”»æ¿ï¼Œæ”¯æŒæ’¤é”€/é‡åšå’Œä¿å­˜/åŠ è½½ï¼š

```typescript
import React, { useRef, useState, useEffect } from 'react';
import { Card, Button, Space, ColorPicker, Slider, message, Modal } from 'antd';
import {
  UndoOutlined,
  RedoOutlined,
  ClearOutlined,
  SaveOutlined,
  FolderOpenOutlined,
} from '@ant-design/icons';

// Canvas çŠ¶æ€å¤‡å¿˜å½•
interface CanvasMemento {
  imageData: string; // Base64 æ ¼å¼çš„å›¾ç‰‡æ•°æ®
  timestamp: number;
}

// Canvas ç®¡ç†å™¨
class CanvasManager {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;

  constructor(canvas: HTMLCanvasElement) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d')!;
  }

  // åˆ›å»ºå¤‡å¿˜å½•
  createMemento(): CanvasMemento {
    return {
      imageData: this.canvas.toDataURL(),
      timestamp: Date.now(),
    };
  }

  // ä»å¤‡å¿˜å½•æ¢å¤
  restoreFromMemento(memento: CanvasMemento): Promise<void> {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.drawImage(img, 0, 0);
        resolve();
      };
      img.src = memento.imageData;
    });
  }

  // æ¸…ç©ºç”»å¸ƒ
  clear(): void {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }

  // è·å–ä¸Šä¸‹æ–‡
  getContext(): CanvasRenderingContext2D {
    return this.ctx;
  }
}

// Canvas å†å²ç®¡ç†å™¨
class CanvasHistory {
  private mementos: CanvasMemento[] = [];
  private currentIndex: number = -1;
  private maxSize: number = 30;

  push(memento: CanvasMemento): void {
    if (this.currentIndex < this.mementos.length - 1) {
      this.mementos = this.mementos.slice(0, this.currentIndex + 1);
    }

    this.mementos.push(memento);

    if (this.mementos.length > this.maxSize) {
      this.mementos.shift();
    } else {
      this.currentIndex++;
    }
  }

  undo(): CanvasMemento | null {
    if (this.currentIndex > 0) {
      this.currentIndex--;
      return this.mementos[this.currentIndex];
    }
    return null;
  }

  redo(): CanvasMemento | null {
    if (this.currentIndex < this.mementos.length - 1) {
      this.currentIndex++;
      return this.mementos[this.currentIndex];
    }
    return null;
  }

  canUndo(): boolean {
    return this.currentIndex > 0;
  }

  canRedo(): boolean {
    return this.currentIndex < this.mementos.length - 1;
  }

  clear(): void {
    this.mementos = [];
    this.currentIndex = -1;
  }
}

// React ç»„ä»¶
const DrawingBoard: React.FC = () => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const canvasManagerRef = useRef<CanvasManager | null>(null);
  const historyRef = useRef(new CanvasHistory());

  const [isDrawing, setIsDrawing] = useState(false);
  const [color, setColor] = useState('#000000');
  const [lineWidth, setLineWidth] = useState(2);
  const [canUndo, setCanUndo] = useState(false);
  const [canRedo, setCanRedo] = useState(false);

  // åˆå§‹åŒ– Canvas
  useEffect(() => {
    if (canvasRef.current) {
      canvasManagerRef.current = new CanvasManager(canvasRef.current);
      
      // ä¿å­˜åˆå§‹ç©ºç™½çŠ¶æ€
      const initialMemento = canvasManagerRef.current.createMemento();
      historyRef.current.push(initialMemento);
    }
  }, []);

  // æ›´æ–°æ’¤é”€/é‡åšæŒ‰é’®çŠ¶æ€
  const updateButtons = () => {
    setCanUndo(historyRef.current.canUndo());
    setCanRedo(historyRef.current.canRedo());
  };

  // ä¿å­˜å½“å‰çŠ¶æ€
  const saveState = () => {
    if (canvasManagerRef.current) {
      const memento = canvasManagerRef.current.createMemento();
      historyRef.current.push(memento);
      updateButtons();
    }
  };

  // å¼€å§‹ç»˜åˆ¶
  const startDrawing = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!canvasManagerRef.current) return;
    
    const canvas = canvasRef.current!;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const ctx = canvasManagerRef.current.getContext();
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.strokeStyle = color;
    ctx.lineWidth = lineWidth;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    setIsDrawing(true);
  };

  // ç»˜åˆ¶ä¸­
  const draw = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!isDrawing || !canvasManagerRef.current) return;

    const canvas = canvasRef.current!;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const ctx = canvasManagerRef.current.getContext();
    ctx.lineTo(x, y);
    ctx.stroke();
  };

  // ç»“æŸç»˜åˆ¶
  const stopDrawing = () => {
    if (isDrawing) {
      setIsDrawing(false);
      saveState(); // ç»˜åˆ¶å®Œæˆåä¿å­˜çŠ¶æ€
    }
  };

  // æ’¤é”€
  const handleUndo = async () => {
    const memento = historyRef.current.undo();
    if (memento && canvasManagerRef.current) {
      await canvasManagerRef.current.restoreFromMemento(memento);
      updateButtons();
      message.success('å·²æ’¤é”€');
    }
  };

  // é‡åš
  const handleRedo = async () => {
    const memento = historyRef.current.redo();
    if (memento && canvasManagerRef.current) {
      await canvasManagerRef.current.restoreFromMemento(memento);
      updateButtons();
      message.success('å·²é‡åš');
    }
  };

  // æ¸…ç©ºç”»å¸ƒ
  const handleClear = () => {
    Modal.confirm({
      title: 'ç¡®è®¤æ¸…ç©ºç”»å¸ƒï¼Ÿ',
      content: 'æ¸…ç©ºåå¯ä»¥é€šè¿‡æ’¤é”€æ¢å¤',
      okText: 'ç¡®è®¤',
      cancelText: 'å–æ¶ˆ',
      onOk: () => {
        if (canvasManagerRef.current) {
          canvasManagerRef.current.clear();
          saveState();
          message.success('ç”»å¸ƒå·²æ¸…ç©º');
        }
      },
    });
  };

  // ä¿å­˜å›¾ç‰‡
  const handleSave = () => {
    if (canvasRef.current) {
      const dataUrl = canvasRef.current.toDataURL('image/png');
      const link = document.createElement('a');
      link.download = `drawing_${Date.now()}.png`;
      link.href = dataUrl;
      link.click();
      message.success('å›¾ç‰‡å·²ä¿å­˜');
    }
  };

  // åŠ è½½å›¾ç‰‡
  const handleLoad = () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.onchange = (e: any) => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
          const img = new Image();
          img.onload = () => {
            if (canvasManagerRef.current) {
              const ctx = canvasManagerRef.current.getContext();
              ctx.drawImage(img, 0, 0, 600, 400);
              saveState();
              message.success('å›¾ç‰‡å·²åŠ è½½');
            }
          };
          img.src = event.target?.result as string;
        };
        reader.readAsDataURL(file);
      }
    };
    input.click();
  };

  return (
    <div style={{ padding: 24, backgroundColor: '#f0f2f5', minHeight: '100vh' }}>
      <Card title="ğŸ¨ ç”»æ¿ï¼ˆå¤‡å¿˜å½•æ¨¡å¼ï¼‰" style={{ maxWidth: 700, margin: '0 auto' }}>
        {/* å·¥å…·æ  */}
        <Space style={{ marginBottom: 16 }} wrap>
          <Button
            icon={<UndoOutlined />}
            onClick={handleUndo}
            disabled={!canUndo}
          >
            æ’¤é”€
          </Button>
          <Button
            icon={<RedoOutlined />}
            onClick={handleRedo}
            disabled={!canRedo}
          >
            é‡åš
          </Button>
          <Button
            icon={<ClearOutlined />}
            onClick={handleClear}
          >
            æ¸…ç©º
          </Button>
          
          <div style={{ width: 1, height: 30, backgroundColor: '#d9d9d9' }} />
          
          <span>é¢œè‰²ï¼š</span>
          <ColorPicker
            value={color}
            onChange={(_, hex) => setColor(hex)}
          />
          
          <span>ç²—ç»†ï¼š</span>
          <Slider
            min={1}
            max={20}
            value={lineWidth}
            onChange={setLineWidth}
            style={{ width: 120 }}
          />
          
          <div style={{ width: 1, height: 30, backgroundColor: '#d9d9d9' }} />
          
          <Button icon={<SaveOutlined />} onClick={handleSave}>
            ä¿å­˜å›¾ç‰‡
          </Button>
          <Button icon={<FolderOpenOutlined />} onClick={handleLoad}>
            åŠ è½½å›¾ç‰‡
          </Button>
        </Space>

        {/* ç”»å¸ƒ */}
        <canvas
          ref={canvasRef}
          width={600}
          height={400}
          style={{
            border: '1px solid #d9d9d9',
            cursor: 'crosshair',
            display: 'block',
            backgroundColor: '#fff',
          }}
          onMouseDown={startDrawing}
          onMouseMove={draw}
          onMouseUp={stopDrawing}
          onMouseLeave={stopDrawing}
        />

        {/* è¯´æ˜ */}
        <Card type="inner" size="small" style={{ marginTop: 16 }}>
          <div style={{ fontSize: 12, color: '#666' }}>
            ğŸ’¡ åœ¨ç”»å¸ƒä¸Šç»˜åˆ¶ï¼Œæ¯æ¬¡æ¾å¼€é¼ æ ‡ä¼šè‡ªåŠ¨ä¿å­˜çŠ¶æ€ï¼Œæ”¯æŒæ’¤é”€/é‡åš
          </div>
        </Card>
      </Card>
    </div>
  );
};

export default DrawingBoard;
```

## æ¨¡å¼æ€»ç»“

### âœ… ä¼˜ç‚¹

1. **ç®€åŒ–æ’¤é”€é€»è¾‘**ï¼šä¸éœ€è¦ç¼–å†™å¤æ‚çš„åå‘æ“ä½œï¼Œç›´æ¥æ¢å¤å¿«ç…§å³å¯
2. **ä¿æŒå°è£…æ€§**ï¼šMemento å°è£…äº†å†…éƒ¨çŠ¶æ€ï¼Œå¤–éƒ¨æ— æ³•ç›´æ¥ä¿®æ”¹
3. **çŠ¶æ€å®Œæ•´æ€§**ï¼šä¿å­˜çš„æ˜¯å®Œæ•´çŠ¶æ€ï¼Œä¸ä¼šé—æ¼ä»»ä½•ä¿¡æ¯
4. **æ”¯æŒå¤šç‰ˆæœ¬ç®¡ç†**ï¼šå¯ä»¥åŒæ—¶ç»´æŠ¤å¤šä¸ªå†å²ç‰ˆæœ¬
5. **æ¢å¤é€Ÿåº¦å¿«**ï¼šç›´æ¥åŠ è½½å¿«ç…§ï¼Œä¸éœ€è¦é‡æ–°è®¡ç®—

### âŒ ç¼ºç‚¹

1. **å†…å­˜å¼€é”€å¤§**ï¼šæ¯ä¸ªå¿«ç…§éƒ½ä¿å­˜å®Œæ•´çŠ¶æ€ï¼Œå ç”¨å†…å­˜è¾ƒå¤š
2. **æ€§èƒ½é—®é¢˜**ï¼šé¢‘ç¹åˆ›å»ºå¿«ç…§ä¼šå½±å“æ€§èƒ½ï¼ˆç‰¹åˆ«æ˜¯å¤§å¯¹è±¡ï¼‰
3. **åºåˆ—åŒ–æˆæœ¬**ï¼šéœ€è¦åºåˆ—åŒ–/ååºåˆ—åŒ–å¯¹è±¡ï¼Œæœ‰ä¸€å®šå¼€é”€
4. **å†å²è®°å½•é™åˆ¶**ï¼šå¿…é¡»é™åˆ¶å†å²è®°å½•æ•°é‡ï¼Œå¦åˆ™å†…å­˜ä¼šçˆ†

### ğŸ¯ é€‚ç”¨åœºæ™¯

å¤‡å¿˜å½•æ¨¡å¼ç‰¹åˆ«é€‚åˆä»¥ä¸‹å‰ç«¯åœºæ™¯ï¼š

| åœºæ™¯ | è¯´æ˜ | å…¸å‹å®ç° |
|------|------|---------|
| **ç¼–è¾‘å™¨æ’¤é”€/é‡åš** | æ–‡æœ¬ã€å¯Œæ–‡æœ¬ã€ä»£ç ç¼–è¾‘å™¨ | CodeMirrorã€TinyMCEã€Monaco Editor |
| **è¡¨å•è‰ç¨¿ä¿å­˜** | è‡ªåŠ¨ä¿å­˜ç”¨æˆ·å¡«å†™çš„è¡¨å• | åå°ç®¡ç†ç³»ç»Ÿã€é—®å·è°ƒæŸ¥ |
| **ç»˜å›¾å·¥å…·** | Canvasã€SVG ç»˜å›¾åº”ç”¨ | Figmaã€Canvaã€Excalidraw |
| **æ¸¸æˆå­˜æ¡£** | ä¿å­˜æ¸¸æˆè¿›åº¦å’ŒçŠ¶æ€ | ç½‘é¡µæ¸¸æˆã€å°æ¸¸æˆ |
| **å·¥ä½œæµçŠ¶æ€** | å®¡æ‰¹æµç¨‹ã€ä»»åŠ¡æµè½¬ | æµç¨‹è®¾è®¡å™¨ã€å®¡æ‰¹ç³»ç»Ÿ |
| **é…ç½®ç®¡ç†** | ä¿å­˜å’Œæ¢å¤é…ç½®é¡¹ | ä¸»é¢˜è®¾ç½®ã€ç”¨æˆ·åå¥½ |
| **æµè§ˆå†å²** | å‰è¿›/åé€€å¯¼èˆª | è·¯ç”±å†å²ã€é¡µé¢çŠ¶æ€ |

### ğŸ¤” ä»€ä¹ˆæ—¶å€™è¯¥ç”¨å¤‡å¿˜å½•æ¨¡å¼ï¼Ÿ

**ä¸‰ä¸ªåˆ¤æ–­æ ‡å‡†ï¼š**

1. **éœ€è¦ä¿å­˜/æ¢å¤å¯¹è±¡çŠ¶æ€å—ï¼Ÿ**
   - æ’¤é”€/é‡åšã€è‰ç¨¿ä¿å­˜ã€å†å²è®°å½•

2. **ç›´æ¥æš´éœ²å†…éƒ¨çŠ¶æ€ä¼šç ´åå°è£…å—ï¼Ÿ**
   - å¯¹è±¡çš„å†…éƒ¨çŠ¶æ€ä¸åº”è¯¥è¢«å¤–éƒ¨ç›´æ¥è®¿é—®

3. **ä½¿ç”¨å‘½ä»¤æ¨¡å¼è®°å½•æ“ä½œå¤ªå¤æ‚å—ï¼Ÿ**
   - å¦‚æœåå‘æ“ä½œå¾ˆéš¾å®ç°ï¼Œç”¨å¤‡å¿˜å½•æ¨¡å¼æ›´ç®€å•

**å¿«é€Ÿå†³ç­–æ ‘ï¼š**

```
éœ€è¦å®ç°æ’¤é”€/é‡åšåŠŸèƒ½å—ï¼Ÿ
    â”œâ”€ æ˜¯ â†’ åå‘æ“ä½œå®¹æ˜“å®ç°å—ï¼Ÿ
    â”‚        â”œâ”€ æ˜¯ â†’ ğŸ¤” è€ƒè™‘å‘½ä»¤æ¨¡å¼ï¼ˆè®°å½•æ“ä½œï¼‰
    â”‚        â””â”€ å¦ â†’ âœ… ç”¨å¤‡å¿˜å½•æ¨¡å¼ï¼ˆä¿å­˜å¿«ç…§ï¼‰ï¼
    â””â”€ å¦ â†’ éœ€è¦ä¿å­˜çŠ¶æ€ä»¥ä¾¿æ¢å¤å—ï¼Ÿ
             â”œâ”€ æ˜¯ â†’ âœ… ç”¨å¤‡å¿˜å½•æ¨¡å¼ï¼
             â””â”€ å¦ â†’ âŒ ä¸éœ€è¦
```

### ğŸ’¡ æ€§èƒ½ä¼˜åŒ–æŠ€å·§

#### 1. å¢é‡å¿«ç…§ï¼ˆåªä¿å­˜å·®å¼‚ï¼‰

```typescript
interface IncrementalMemento {
  baseSnapshot: string;
  changes: Array<{ type: 'add' | 'delete'; data: any }>;
}
```

#### 2. å»¶è¿Ÿä¿å­˜ï¼ˆé˜²æŠ–ï¼‰

```typescript
const debouncedSave = debounce(() => {
  saveState();
}, 500); // 500ms å†…åªä¿å­˜ä¸€æ¬¡
```

#### 3. å‹ç¼©å¿«ç…§

```typescript
import pako from 'pako';

const compressed = pako.deflate(JSON.stringify(state));
const decompressed = JSON.parse(pako.inflate(compressed, { to: 'string' }));
```

#### 4. é™åˆ¶å†å²è®°å½•æ•°é‡

```typescript
if (history.length > MAX_HISTORY) {
  history.shift(); // åˆ é™¤æœ€æ—§çš„è®°å½•
}
```

### ğŸ†š å¤‡å¿˜å½•æ¨¡å¼ vs å‘½ä»¤æ¨¡å¼

| ç‰¹å¾ | å¤‡å¿˜å½•æ¨¡å¼ | å‘½ä»¤æ¨¡å¼ |
|------|-----------|---------|
| **ä¿å­˜å†…å®¹** | å®Œæ•´çŠ¶æ€å¿«ç…§ | æ“ä½œå‘½ä»¤ |
| **æ’¤é”€æ–¹å¼** | ç›´æ¥æ¢å¤å¿«ç…§ | æ‰§è¡Œåå‘å‘½ä»¤ |
| **å†…å­˜å ç”¨** | è¾ƒå¤§ï¼ˆä¿å­˜å®Œæ•´çŠ¶æ€ï¼‰ | è¾ƒå°ï¼ˆåªè®°å½•æ“ä½œï¼‰ |
| **å®ç°éš¾åº¦** | ç®€å• | å¤æ‚ï¼ˆéœ€è¦å†™åå‘é€»è¾‘ï¼‰ |
| **é€‚ç”¨åœºæ™¯** | çŠ¶æ€å¤æ‚ã€åå‘æ“ä½œéš¾ | çŠ¶æ€ç®€å•ã€åå‘æ“ä½œæ˜“ |
| **å…¸å‹åº”ç”¨** | å¯Œæ–‡æœ¬ç¼–è¾‘å™¨ã€ç”»å›¾å·¥å…· | ç®€å•æ–‡æœ¬ç¼–è¾‘å™¨ã€å‘½ä»¤è¡Œ |

---

## ğŸ’¬ å°ç»“

å¤‡å¿˜å½•æ¨¡å¼å°±åƒç»™å¯¹è±¡æ‹"å¿«ç…§"ï¼Œéœ€è¦æ¢å¤æ—¶ç›´æ¥è¯»å–ç…§ç‰‡ï¼Œè€Œä¸æ˜¯å€’å¸¦é‡æ”¾å½•åƒã€‚

åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œå¤‡å¿˜å½•æ¨¡å¼èƒ½è®©ä½ çš„ä»£ç ï¼š
- ä»"æ‰‹å†™å¤æ‚çš„æ’¤é”€é€»è¾‘"å˜æˆ"ä¿å­˜å¿«ç…§ï¼Œä¸€é”®æ¢å¤"
- ä»"çŠ¶æ€æ¢å¤å®¹æ˜“å‡ºé”™"å˜æˆ"å®Œæ•´çŠ¶æ€ï¼Œç»ä¸é—æ¼"
- ä»"ç”¨æˆ·æ‹…å¿ƒæ•°æ®ä¸¢å¤±"å˜æˆ"è‡ªåŠ¨ä¿å­˜è‰ç¨¿ï¼Œå®‰å…¨æ— å¿§"

**è®°ä½ä¸€å¥è¯**ï¼šå½“ä½ éœ€è¦ä¿å­˜å¯¹è±¡çŠ¶æ€ä»¥ä¾¿å°†æ¥æ¢å¤æ—¶ï¼Œå°±è¯¥è€ƒè™‘å¤‡å¿˜å½•æ¨¡å¼äº†ï¼

---

> ğŸ’¡ **æ€è€ƒé¢˜**ï¼š
> 1. å¤‡å¿˜å½•æ¨¡å¼å’Œå‘½ä»¤æ¨¡å¼ï¼Œåœ¨å®ç°æ’¤é”€åŠŸèƒ½æ—¶æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ
> 2. å¦‚ä½•ä¼˜åŒ–å¤‡å¿˜å½•æ¨¡å¼çš„å†…å­˜å ç”¨ï¼Ÿï¼ˆæç¤ºï¼šå¢é‡å¿«ç…§ã€å‹ç¼©ï¼‰
> 3. åœ¨ React ä¸­ï¼ŒuseRef å’Œ useState å“ªä¸ªæ›´é€‚åˆå®ç°å†å²è®°å½•ç®¡ç†ï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ

---

> ğŸ“š **ç›¸å…³æ¨¡å¼**ï¼š
> - å‘½ä»¤æ¨¡å¼ï¼ˆCommandï¼‰ï¼šå°†æ“ä½œå°è£…æˆå‘½ä»¤å¯¹è±¡ï¼Œä¹Ÿå¯ç”¨äºæ’¤é”€/é‡åš
> - åŸå‹æ¨¡å¼ï¼ˆPrototypeï¼‰ï¼šé€šè¿‡å…‹éš†åˆ›å»ºå¯¹è±¡å‰¯æœ¬ï¼Œå¯ç”¨äºå¿«ç…§
> - è¿­ä»£å™¨æ¨¡å¼ï¼ˆIteratorï¼‰ï¼šéå†å†å²è®°å½•æ—¶å¯ä»¥ç»“åˆä½¿ç”¨

